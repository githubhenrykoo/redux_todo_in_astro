# Git Activity Log - 44091930+alessandrorumampuk
Generated at: Wed Jul  2 00:48:42 UTC 2025
## Changes by 44091930+alessandrorumampuk
```diff
commit f47d1e5993fa713528fb6de33d2ae9338a53aebf
Author: Alessandro Rumampuk <44091930+alessandrorumampuk@users.noreply.github.com>
Date:   Tue Jul 1 13:36:34 2025 +0800

    Create README.md

diff --git a/documentconversion/README.md b/documentconversion/README.md
new file mode 100644
index 0000000..85d8783
--- /dev/null
+++ b/documentconversion/README.md
@@ -0,0 +1,117 @@
+# Document Conversion Tools
+
+This directory contains Python scripts for converting and loading documents into the MCard database. The tools support both Google Docs and local markdown files.
+
+## Scripts
+
+### 1. Google_Docs_to_MCard.py
+
+This script downloads content from public Google Docs and saves it to the MCard database in JSON format.
+
+#### Features
+- Downloads public Google Docs in markdown format
+- Automatically extracts document ID from various Google Docs URL formats
+- Saves content directly to MCard database with proper JSON structure
+- Generates SHA256 hashes for content identification
+- Uses standardized timestamp format (sha256|ISO8601_UTC|ASIA)
+- Provides detailed processing summaries
+
+#### Usage
+```bash
+python Google_Docs_to_MCard.py --doc-url DOC_URL [--db-path DB_PATH]
+
+Arguments:
+  --doc-url      Google Doc URL or document ID (required)
+  --db-path      Custom path for the database file (optional, default: ../public/data/cards.db)
+  --format       Output format (default: md, options: docx,odt,rtf,pdf,txt,html,epub,md)
+  --all-formats  Download and process all available formats
+  --output-dir   Directory to save downloaded files (default: data/downloads)
+```
+
+Example:
+```bash
+# Using a Google Docs URL
+python Google_Docs_to_MCard.py --doc-url "https://docs.google.com/document/d/YOUR_DOC_ID/edit"
+
+# Using a document ID directly
+python Google_Docs_to_MCard.py --doc-url "YOUR_DOC_ID"
+
+# Specifying a custom database path
+python Google_Docs_to_MCard.py --doc-url "YOUR_DOC_ID" --db-path "/custom/path/cards.db"
+```
+
+### 2. Local_to_MCard.py
+
+This script processes local markdown files and saves them to the MCard database.
+
+#### Features
+- Reads local markdown files
+- Saves content to MCard database with proper JSON structure
+- Uses the same hashing and timestamp format as Google_Docs_to_MCard.py
+- Provides detailed processing summaries
+
+#### Usage
+```bash
+python Local_to_MCard.py --input FILE_PATH [--db-path DB_PATH]
+
+Arguments:
+  --input     Path to the local markdown file (required)
+  --db-path   Custom path for the database file (optional, default: ../public/data/cards.db)
+```
+
+Example:
+```bash
+# Process a local markdown file
+python Local_to_MCard.py --input "path/to/your/file.md"
+
+# With custom database path
+python Local_to_MCard.py --input "path/to/your/file.md" --db-path "/custom/path/cards.db"
+```
+
+## Database Schema
+
+Both scripts use the same SQLite database schema:
+
+```sql
+CREATE TABLE card (
+    hash TEXT PRIMARY KEY,  -- SHA256 hash of content
+    content TEXT NOT NULL,  -- JSON formatted content
+    g_time TEXT NOT NULL   -- Timestamp in format: sha256|ISO8601_UTC|ASIA
+);
+```
+
+### Content JSON Structure
+
+Content is stored in the following JSON format:
+```json
+{
+    "dimensionType": "abstractSpecification",
+    "context": "actual_content_here",
+    "goal": "",
+    "successCriteria": ""
+}
+```
+
+## Requirements
+
+- Python 3.6+
+- Required Python packages:
+  - requests
+  - pathlib
+  - sqlite3 (usually included with Python)
+
+## Installation
+
+1. Clone the repository
+2. Install required packages:
+```bash
+pip install requests pathlib
+```
+
+## Notes
+
+- Both scripts create the database and required tables automatically if they don't exist
+- The database path defaults to `../public/data/cards.db` relative to the script location
+- For Google Docs, only public documents are supported
+- All content is stored as UTF-8 text
+- Timestamps are always in UTC with ASIA suffix

commit 81736094677eb1b1dac60b1b9663a39d5f728046
Author: Alessandro Rumampuk <44091930+alessandrorumampuk@users.noreply.github.com>
Date:   Tue Jul 1 13:36:22 2025 +0800

    Create Local_to_MCard.py

diff --git a/documentconversion/Local_to_MCard.py b/documentconversion/Local_to_MCard.py
new file mode 100644
index 0000000..46c1f9f
--- /dev/null
+++ b/documentconversion/Local_to_MCard.py
@@ -0,0 +1,333 @@
+#!/usr/bin/env python3
+"""
+Local Files to MCard Loader
+
+This script processes local files and adds them to the MCard database:
+1. Read local markdown files
+2. Add the content to the MCard database in the required JSON format
+3. Generate a summary of processed files
+
+Usage:
+    python local_to_mcard.py [--db-path DB_PATH] [--input FILE]
+
+Options:
+    --db-path    Custom path for the database file (optional)
+    --input      Path to the local markdown file to process
+"""
+import argparse
+import datetime
+import hashlib
+import json
+import logging
+import os
+import sqlite3
+import sys
+from pathlib import Path
+from typing import List, Dict, Any, Optional
+
+# Configure logging
+logging.basicConfig(
+    level=logging.INFO,
+    format='%(message)s',
+    datefmt='%Y-%m-%d %H:%M:%S'
+)
+
+# Supported file extensions
+SUPPORTED_EXTENSIONS = {
+    '.md': 'text/markdown'
+}
+
+# Default paths
+DEFAULT_DB_PATH = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 'public', 'data', 'cards.db')
+DEFAULT_DOWNLOAD_DIR = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 'data', 'downloads')
+
+# Set up logging
+logging.basicConfig(
+    level=logging.INFO,
+    format='%(message)s',
+    datefmt='%Y-%m-%d %H:%M:%S'
+)
+
+# Reduce log verbosity
+for logger_name in ['mcard.model.card_collection', 'mcard.engine.sqlite_engine', 'root']:
+    logging.getLogger(logger_name).setLevel(logging.WARNING)
+
+
+def read_local_file(file_path: str) -> Optional[str]:
+    """
+    Read content from a local markdown file.
+    
+    Args:
+        file_path (str): Path to the local markdown file
+        
+    Returns:
+        str: The file content as text, or None if reading failed
+    """
+    try:
+        path = Path(file_path)
+        if not path.exists():
+            print(f"File not found: {file_path}")
+            return None
+            
+        if path.suffix.lower() != '.md':
+            print(f"Unsupported file type: {path.suffix}. Only .md files are supported.")
+            return None
+            
+        print(f"Reading file: {path.name}...")
+        with open(path, 'r', encoding='utf-8') as f:
+            return f.read()
+            
+    except Exception as e:
+        print(f"Error reading file: {e}")
+        return None
+
+
+def download_public_doc(doc_id: str, output_format: str = 'md') -> Optional[str]:
+    """
+    Download a public Google Doc and return its content as text.
+    
+    Args:
+        doc_id (str): The ID of the Google Doc
+        output_format (str): The desired output format (default: md)
+        
+    Returns:
+        str: The document content as text, or None if download failed
+    """
+    # Validate the output format
+    if output_format not in EXPORT_FORMATS:
+        valid_formats = ', '.join(EXPORT_FORMATS.keys())
+        raise ValueError(f"Invalid format: {output_format}. Valid formats are: {valid_formats}")
+    
+    # Construct the export URL
+    export_url = f"https://docs.google.com/document/d/{doc_id}/export?format={EXPORT_FORMATS[output_format]}"
+    
+    try:
+        # Send a GET request to download the file
+        print(f"Downloading document as {output_format}...")
+        response = requests.get(export_url)
+        
+        # Check if the request was successful
+        response.raise_for_status()
+        
+        # Return the content directly as text
+        if output_format == 'md':
+            return response.text
+        else:
+            print(f"Format {output_format} not supported for direct text processing")
+            return None
+        
+    except requests.exceptions.RequestException as e:
+        print(f"Error downloading document: {e}")
+        if hasattr(e, 'response') and e.response and e.response.status_code == 404:
+            print("This might be because the document is not public or the document ID is incorrect.")
+        return None
+
+
+def download_all_formats(doc_url_or_id: str, output_dir: Optional[str] = None) -> List[str]:
+    """
+    Download a Google Doc in all supported formats.
+    
+    Args:
+        doc_url_or_id (str): Google Doc ID or URL
+        output_dir (str, optional): Directory to save the files. If None,
+                                   the files will be saved to the default downloads directory.
+        
+    Returns:
+        list: Paths to the downloaded files
+    """
+    # Extract the document ID
+    doc_id = extract_doc_id(doc_url_or_id)
+    
+    # Use default download directory if not specified
+    if not output_dir:
+        output_dir = DEFAULT_DOWNLOAD_DIR
+        
+    # Create output directory if it doesn't exist
+    os.makedirs(output_dir, exist_ok=True)
+    
+    # Download in all formats
+    downloaded_files = []
+    for format_name in EXPORT_FORMATS.keys():
+        try:
+            file_path = download_public_doc(doc_id, format_name, output_dir)
+            if file_path:
+                downloaded_files.append(file_path)
+        except Exception as e:
+            print(f"Error downloading {format_name} format: {e}")
+    
+    return downloaded_files
+
+
+def print_summary(processed_files: List[Dict[str, Any]]) -> None:
+    """Print a summary of the processed files."""
+    if not processed_files:
+        print("No files were processed.")
+        return
+        
+    print("\nProcessed Files Summary:")
+    print("=" * 100)
+    print(f"{'Original Filename':<40} {'MCard Hash':<40} {'Content Type'}")
+    print("-" * 100)
+    
+    type_count = {}
+    
+    for file_info in processed_files:
+        if file_info is None:
+            continue
+            
+        # Count content types
+        content_type = file_info.get('content_type', 'unknown')
+        type_count[content_type] = type_count.get(content_type, 0) + 1
+        
+        # Print file info
+        print(f"{file_info.get('filename', 'unknown'):<40} {file_info.get('hash', 'N/A'):<40} {content_type}")
+    
+    # Print type distribution
+    print("\nContent Type Distribution:")
+    print("=" * 40)
+    for content_type, count in type_count.items():
+        print(f"{content_type:<40}: {count}")
+    print("-" * 40)
+    print(f"Total: {len(processed_files)} files processed\n")
+
+
+def ensure_table_exists(db_path: str) -> None:
+    """
+    Create the card table if it doesn't exist.
+    """
+    conn = sqlite3.connect(db_path)
+    cursor = conn.cursor()
+    cursor.execute('''
+        CREATE TABLE IF NOT EXISTS card (
+            hash TEXT PRIMARY KEY,
+            content TEXT NOT NULL,
+            g_time TEXT NOT NULL
+        )
+    ''')
+    conn.commit()
+    conn.close()
+
+
+def process_content(content: str, filename: str, db_path: str) -> Dict[str, Any]:
+    """
+    Process downloaded files and add them to the MCard database.
+    
+    Args:
+        file_paths (List[str]): List of paths to downloaded files
+        db_path (str): Path to the database file
+        
+    Returns:
+        List[Dict[str, Any]]: Information about processed files
+    """
+    try:
+        print(f"Processing {filename}...")
+            
+        # Create metadata as a JSON string
+        metadata = json.dumps({
+            "dimensionType": "abstractSpecification",
+            "context": content,
+            "goal": "",
+            "successCriteria": ""
+        })
+        
+        # Create a unique hash based on content
+        content_hash = hashlib.sha256(content.encode('utf-8')).hexdigest()
+        
+        # Format timestamp in the required format
+        timestamp = datetime.datetime.now(datetime.timezone.utc).strftime('%Y-%m-%dT%H:%M:%S.%fZ')
+        g_time = f"sha256|{timestamp}|ASIA"
+            
+        # Add to database using SQLite
+        conn = sqlite3.connect(db_path)
+        cursor = conn.cursor()
+        
+        # Insert into the card table as text
+        cursor.execute(
+            'INSERT OR REPLACE INTO card (hash, content, g_time) VALUES (?, ?, ?)',
+            (content_hash, metadata, g_time)
+        )
+        
+        # Commit and close
+        conn.commit()
+        conn.close()
+            
+        result = {
+            'filename': filename,
+            'hash': content_hash,
+            'content_type': 'text/markdown'
+        }
+        
+        print(f"Successfully processed {filename}")
+        return result
+                
+    except Exception as e:
+        print(f"Error processing content: {str(e)}")
+        import traceback
+        print(f"Detailed error: {traceback.format_exc()}")
+        return None
+
+
+def main():
+    """Main function to process local files and add them to MCard."""
+    parser = argparse.ArgumentParser(
+        description="Process local markdown files and add them to MCard database.")
+    
+    parser.add_argument(
+        "--input",
+        required=True,
+        help="Path to the local markdown file to process"
+    )
+    
+    parser.add_argument(
+        "--db-path",
+        type=str,
+        help="Path to the database file (optional)"
+    )
+    
+    args = parser.parse_args()
+    
+    # Use direct SQLite connection to ensure correct database path
+    db_path = args.db_path if args.db_path else DEFAULT_DB_PATH
+    os.makedirs(os.path.dirname(db_path), exist_ok=True)
+    
+    # Ensure the table exists
+    ensure_table_exists(db_path)
+    
+    print("\nGoogle Docs to MCard Loader")
+    print("=" * 70)
+    
+    try:
+        # Read the local file
+        input_path = args.input
+        content = read_local_file(input_path)
+        
+        if not content:
+            print("No content was read. Please check the file path and try again.")
+            return 1
+            
+        # Process the content
+        print(f"\nAdding content to MCard database...")
+        processed_file = process_content(content, Path(input_path).name, db_path)
+        processed_files = [processed_file] if processed_file else []
+        
+        # Print summary
+        print_summary(processed_files)
+        
+        # Print collection stats
+        # Get the count of cards in the database
+        conn = sqlite3.connect(db_path)
+        cursor = conn.cursor()
+        cursor.execute('SELECT COUNT(*) FROM card')
+        count = cursor.fetchone()[0]
+        conn.close()
+        print(f"\nDatabase now contains {count} cards")
+        
+    except Exception as e:
+        print(f"Error processing Google Doc: {str(e)}")
+        return 1
+    
+    return 0
+
+
+if __name__ == "__main__":
+    sys.exit(main())

commit 174984110ea46d0b351dac09e77135497dbd61a0
Author: Alessandro Rumampuk <44091930+alessandrorumampuk@users.noreply.github.com>
Date:   Tue Jul 1 13:36:07 2025 +0800

    Create Google_Docs_to_MCard.py

diff --git a/documentconversion/Google_Docs_to_MCard.py b/documentconversion/Google_Docs_to_MCard.py
new file mode 100644
index 0000000..2c30956
--- /dev/null
+++ b/documentconversion/Google_Docs_to_MCard.py
@@ -0,0 +1,381 @@
+#!/usr/bin/env python3
+"""
+Google Docs to MCard Loader
+
+This script combines functionality from googledocs.py and Content_Loader.py to:
+1. Download public Google Docs documents in various formats
+2. Automatically add the downloaded documents to the MCard database
+3. Generate a summary of processed files
+
+Usage:
+    python googledocs_to_mcard.py [--db-path DB_PATH] [--doc-url DOC_URL] [--format FORMAT] [--all-formats]
+
+Options:
+    --db-path      Custom path for the database file (optional)
+    --doc-url      Google Doc URL or ID to download and process
+    --format       Output format (default: md, options: docx, odt, rtf, pdf, txt, html, epub, md)
+    --all-formats  Download and process all available formats
+    --output-dir   Directory to save downloaded files (default: data/downloads)
+"""
+import argparse
+import datetime
+import hashlib
+import json
+import logging
+import os
+import re
+import sqlite3
+import sys
+from pathlib import Path
+from typing import List, Dict, Any, Optional
+from urllib.parse import urlparse, parse_qs
+import requests
+
+# Configure logging
+logging.basicConfig(
+    level=logging.INFO,
+    format='%(message)s',
+    datefmt='%Y-%m-%d %H:%M:%S'
+)
+
+# Mapping of file extensions to export format parameters for Google Docs
+EXPORT_FORMATS = {
+    'docx': 'docx',
+    'odt': 'odt',
+    'rtf': 'rtf',
+    'pdf': 'pdf',
+    'txt': 'txt',
+    'html': 'zip',  # HTML is exported as a zip file
+    'epub': 'epub',
+    'md': 'md',
+}
+
+# Default paths
+DEFAULT_DB_PATH = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 'public', 'data', 'cards.db')
+DEFAULT_DOWNLOAD_DIR = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 'data', 'downloads')
+
+# Set up logging
+logging.basicConfig(
+    level=logging.INFO,
+    format='%(message)s',
+    datefmt='%Y-%m-%d %H:%M:%S'
+)
+
+# Reduce log verbosity
+for logger_name in ['mcard.model.card_collection', 'mcard.engine.sqlite_engine', 'root']:
+    logging.getLogger(logger_name).setLevel(logging.WARNING)
+
+
+def extract_doc_id(doc_url_or_id: str) -> str:
+    """
+    Extract the document ID from a Google Docs URL or return the ID if already provided.
+    
+    Args:
+        doc_url_or_id (str): Google Docs URL or document ID
+        
+    Returns:
+        str: The document ID
+    """
+    # Check if it's a URL
+    if doc_url_or_id.startswith('http'):
+        # Parse the URL
+        parsed_url = urlparse(doc_url_or_id)
+        
+        # Extract document ID from different URL formats
+        if 'docs.google.com' in parsed_url.netloc:
+            # Format: https://docs.google.com/document/d/{doc_id}/edit
+            match = re.search(r'/document/d/([^/]+)', parsed_url.path)
+            if match:
+                return match.group(1)
+                
+            # Check for the 'id' query parameter (older format)
+            query_params = parse_qs(parsed_url.query)
+            if 'id' in query_params:
+                return query_params['id'][0]
+        
+        # Format: https://drive.google.com/file/d/{doc_id}/view
+        if 'drive.google.com' in parsed_url.netloc:
+            match = re.search(r'/file/d/([^/]+)', parsed_url.path)
+            if match:
+                return match.group(1)
+    
+    # If not a URL or couldn't extract ID, assume it's already an ID
+    return doc_url_or_id
+
+
+def download_public_doc(doc_id: str, output_format: str = 'md') -> Optional[str]:
+    """
+    Download a public Google Doc and return its content as text.
+    
+    Args:
+        doc_id (str): The ID of the Google Doc
+        output_format (str): The desired output format (default: md)
+        
+    Returns:
+        str: The document content as text, or None if download failed
+    """
+    # Validate the output format
+    if output_format not in EXPORT_FORMATS:
+        valid_formats = ', '.join(EXPORT_FORMATS.keys())
+        raise ValueError(f"Invalid format: {output_format}. Valid formats are: {valid_formats}")
+    
+    # Construct the export URL
+    export_url = f"https://docs.google.com/document/d/{doc_id}/export?format={EXPORT_FORMATS[output_format]}"
+    
+    try:
+        # Send a GET request to download the file
+        print(f"Downloading document as {output_format}...")
+        response = requests.get(export_url)
+        
+        # Check if the request was successful
+        response.raise_for_status()
+        
+        # Return the content directly as text
+        if output_format == 'md':
+            return response.text
+        else:
+            print(f"Format {output_format} not supported for direct text processing")
+            return None
+        
+    except requests.exceptions.RequestException as e:
+        print(f"Error downloading document: {e}")
+        if hasattr(e, 'response') and e.response and e.response.status_code == 404:
+            print("This might be because the document is not public or the document ID is incorrect.")
+        return None
+
+
+def download_all_formats(doc_url_or_id: str, output_dir: Optional[str] = None) -> List[str]:
+    """
+    Download a Google Doc in all supported formats.
+    
+    Args:
+        doc_url_or_id (str): Google Doc ID or URL
+        output_dir (str, optional): Directory to save the files. If None,
+                                   the files will be saved to the default downloads directory.
+        
+    Returns:
+        list: Paths to the downloaded files
+    """
+    # Extract the document ID
+    doc_id = extract_doc_id(doc_url_or_id)
+    
+    # Use default download directory if not specified
+    if not output_dir:
+        output_dir = DEFAULT_DOWNLOAD_DIR
+        
+    # Create output directory if it doesn't exist
+    os.makedirs(output_dir, exist_ok=True)
+    
+    # Download in all formats
+    downloaded_files = []
+    for format_name in EXPORT_FORMATS.keys():
+        try:
+            file_path = download_public_doc(doc_id, format_name, output_dir)
+            if file_path:
+                downloaded_files.append(file_path)
+        except Exception as e:
+            print(f"Error downloading {format_name} format: {e}")
+    
+    return downloaded_files
+
+
+def print_summary(processed_files: List[Dict[str, Any]]) -> None:
+    """Print a summary of the processed files."""
+    if not processed_files:
+        print("No files were processed.")
+        return
+        
+    print("\nProcessed Files Summary:")
+    print("=" * 100)
+    print(f"{'Original Filename':<40} {'MCard Hash':<40} {'Content Type'}")
+    print("-" * 100)
+    
+    type_count = {}
+    
+    for file_info in processed_files:
+        if file_info is None:
+            continue
+            
+        # Count content types
+        content_type = file_info.get('content_type', 'unknown')
+        type_count[content_type] = type_count.get(content_type, 0) + 1
+        
+        # Print file info
+        print(f"{file_info.get('filename', 'unknown'):<40} {file_info.get('hash', 'N/A'):<40} {content_type}")
+    
+    # Print type distribution
+    print("\nContent Type Distribution:")
+    print("=" * 40)
+    for content_type, count in type_count.items():
+        print(f"{content_type:<40}: {count}")
+    print("-" * 40)
+    print(f"Total: {len(processed_files)} files processed\n")
+
+
+def ensure_table_exists(db_path: str) -> None:
+    """
+    Create the card table if it doesn't exist.
+    """
+    conn = sqlite3.connect(db_path)
+    cursor = conn.cursor()
+    cursor.execute('''
+        CREATE TABLE IF NOT EXISTS card (
+            hash TEXT PRIMARY KEY,
+            content TEXT NOT NULL,
+            g_time TEXT NOT NULL
+        )
+    ''')
+    conn.commit()
+    conn.close()
+
+
+def process_content(content: str, filename: str, db_path: str) -> Dict[str, Any]:
+    """
+    Process downloaded files and add them to the MCard database.
+    
+    Args:
+        file_paths (List[str]): List of paths to downloaded files
+        db_path (str): Path to the database file
+        
+    Returns:
+        List[Dict[str, Any]]: Information about processed files
+    """
+    try:
+        print(f"Processing {filename}...")
+            
+        # Create metadata as a JSON string
+        metadata = json.dumps({
+            "dimensionType":"abstractSpecification",
+            "context":content,
+            "goal":"",
+            "successCriteria":""
+        })
+        
+        # Create a unique hash based on content
+        content_hash = hashlib.sha256(content.encode('utf-8')).hexdigest()
+        
+        # Format timestamp in the required format
+        timestamp = datetime.datetime.now(datetime.timezone.utc).strftime('%Y-%m-%dT%H:%M:%S.%fZ')
+        g_time = f"sha256|{timestamp}|ASIA"
+            
+        # Add to database using SQLite
+        conn = sqlite3.connect(db_path)
+        cursor = conn.cursor()
+        
+        # Insert into the card table as text
+        cursor.execute(
+            'INSERT OR REPLACE INTO card (hash, content, g_time) VALUES (?, ?, ?)',
+            (content_hash, metadata, g_time)
+        )
+        
+        # Commit and close
+        conn.commit()
+        conn.close()
+            
+        result = {
+            'filename': filename,
+            'hash': content_hash,
+            'content_type': 'text/markdown'
+        }
+        
+        print(f"Successfully processed {filename}")
+        return result
+                
+    except Exception as e:
+        print(f"Error processing content: {str(e)}")
+        import traceback
+        print(f"Detailed error: {traceback.format_exc()}")
+        return None
+
+
+def main():
+    """Main function to download Google Docs and add them to MCard."""
+    parser = argparse.ArgumentParser(
+        description="Download Google Docs and add them to MCard database.")
+    
+    parser.add_argument(
+        "--doc-url",
+        required=True,
+        help="Google Doc URL or ID to download and process"
+    )
+    
+    parser.add_argument(
+        "--db-path",
+        type=str,
+        help="Path to the database file (optional)"
+    )
+    
+    parser.add_argument(
+        "--format",
+        choices=list(EXPORT_FORMATS.keys()),
+        default="md",
+        help="Output format (default: md)"
+    )
+    
+    parser.add_argument(
+        "--all-formats",
+        action="store_true",
+        help="Download and process all available formats"
+    )
+    
+    parser.add_argument(
+        "--output-dir",
+        type=str,
+        default=DEFAULT_DOWNLOAD_DIR,
+        help=f"Directory to save downloaded files (default: {DEFAULT_DOWNLOAD_DIR})"
+    )
+    
+    args = parser.parse_args()
+    
+    # Use direct SQLite connection to ensure correct database path
+    db_path = args.db_path if args.db_path else DEFAULT_DB_PATH
+    os.makedirs(os.path.dirname(db_path), exist_ok=True)
+    
+    # Ensure the table exists
+    ensure_table_exists(db_path)
+    
+    print("\nGoogle Docs to MCard Loader")
+    print("=" * 70)
+    
+    try:
+        # Extract the document ID
+        doc_id = extract_doc_id(args.doc_url)
+        print(f"Processing Google Doc ID: {doc_id}")
+        
+        # Create output directory if it doesn't exist
+        os.makedirs(args.output_dir, exist_ok=True)
+        
+        # Download and process the document
+        print(f"Downloading document in markdown format...")
+        content = download_public_doc(doc_id)
+        
+        if not content:
+            print("No content was downloaded. Please check the document URL and try again.")
+            return 1
+            
+        # Process the content
+        print(f"\nAdding content to MCard database...")
+        processed_file = process_content(content, f"gdoc_{doc_id}.md", db_path)
+        processed_files = [processed_file] if processed_file else []
+        
+        # Print summary
+        print_summary(processed_files)
+        
+        # Print collection stats
+        # Get the count of cards in the database
+        conn = sqlite3.connect(db_path)
+        cursor = conn.cursor()
+        cursor.execute('SELECT COUNT(*) FROM card')
+        count = cursor.fetchone()[0]
+        conn.close()
+        print(f"\nDatabase now contains {count} cards")
+        
+    except Exception as e:
+        print(f"Error processing Google Doc: {str(e)}")
+        return 1
+    
+    return 0
+
+
+if __name__ == "__main__":
+    sys.exit(main())

commit 663bae71dd465123156ea538b38814d7c06c1216
Author: Alessandro Rumampuk <44091930+alessandrorumampuk@users.noreply.github.com>
Date:   Tue Jul 1 13:21:58 2025 +0800

    Create ChatbotWrapper.jsx

diff --git a/src/components/panels/ChatbotWrapper.jsx b/src/components/panels/ChatbotWrapper.jsx
new file mode 100644
index 0000000..60e5000
--- /dev/null
+++ b/src/components/panels/ChatbotWrapper.jsx
@@ -0,0 +1,89 @@
+import React, { useState, useEffect } from 'react';
+import ModernChatbot from './chatbotmodern.jsx';
+import ClassicChatbot from './chatbotclassic.jsx';
+
+const ChatbotWrapper = ({ className = '' }) => {
+  // Get selected template from localStorage
+  const [selectedTemplate, setSelectedTemplate] = useState(() => {
+    return localStorage.getItem('chatbotTemplate');
+  });
+
+  // Save template preference
+  useEffect(() => {
+    if (selectedTemplate) {
+      localStorage.setItem('chatbotTemplate', selectedTemplate);
+    }
+  }, [selectedTemplate]);
+
+  const handleTemplateSelect = (template) => {
+    setSelectedTemplate(template);
+  };
+
+  return (
+    <div className="relative h-full w-full">
+      {/* Always show template selection until one is chosen */}
+      {!selectedTemplate && (
+        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50">
+          <div className="bg-white rounded-2xl p-6 max-w-md w-full mx-4 shadow-xl">
+            <h2 className="text-2xl font-bold mb-4 text-gray-800">Choose Chatbot Template</h2>
+            <div className="space-y-4">
+              <button
+                onClick={() => handleTemplateSelect('modern')}
+                className={`w-full p-4 rounded-xl border-2 transition-all ${
+                  selectedTemplate === 'modern'
+                    ? 'border-blue-500 bg-blue-50'
+                    : 'border-gray-200 hover:border-blue-300'
+                }`}
+              >
+                <div className="flex items-center space-x-3">
+                  <div className="flex-shrink-0">
+                    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-blue-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
+                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
+                    </svg>
+                  </div>
+                  <div className="text-left">
+                    <h3 className="font-semibold text-gray-800">1. Modern Template ($99)</h3>
+                    <p className="text-sm text-gray-500">Clean, modern design with gradient accents</p>
+                  </div>
+                </div>
+              </button>
+
+              <button
+                onClick={() => handleTemplateSelect('classic')}
+                className={`w-full p-4 rounded-xl border-2 transition-all ${
+                  selectedTemplate === 'classic'
+                    ? 'border-blue-500 bg-blue-50'
+                    : 'border-gray-200 hover:border-blue-300'
+                }`}
+              >
+                <div className="flex items-center space-x-3">
+                  <div className="flex-shrink-0">
+                    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-blue-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
+                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z" />
+                    </svg>
+                  </div>
+                  <div className="text-left">
+                    <h3 className="font-semibold text-gray-800">2. Classic Template (Free)</h3>
+                    <p className="text-sm text-gray-500">Traditional chat interface with dark theme</p>
+                  </div>
+                </div>
+              </button>
+            </div>
+
+            {!localStorage.getItem('chatbotTemplate') && (
+              <p className="mt-4 text-sm text-gray-500 text-center">
+                You can change the template later using the menu button
+              </p>
+            )}
+          </div>
+        </div>
+      )}
+
+      {/* Render Selected Template */}
+      {selectedTemplate === 'modern' && <ModernChatbot className={className} />}
+      {selectedTemplate === 'classic' && <ClassicChatbot className={className} />}
+    </div>
+  );
+};
+
+export default ChatbotWrapper;

commit 73946f5c455ac5b7b791b186c4386f605fef37cd
Author: Alessandro Rumampuk <44091930+alessandrorumampuk@users.noreply.github.com>
Date:   Tue Jul 1 13:21:40 2025 +0800

    Create chatbotclassic.jsx

diff --git a/src/components/panels/chatbotclassic.jsx b/src/components/panels/chatbotclassic.jsx
new file mode 100644
index 0000000..dfe1132
--- /dev/null
+++ b/src/components/panels/chatbotclassic.jsx
@@ -0,0 +1,635 @@
+import React, { useState, useEffect, useRef } from 'react';
+
+const ChatbotPanel = ({ className = '' }) => {
+  // Add isTyping state with other state declarations
+  const [isTyping, setIsTyping] = useState(false);
+  const [mentions, setMentions] = useState([]);
+  const [showCommands, setShowCommands] = useState(false);
+  
+  // Initialize messages from localStorage if available
+  const [messages, setMessages] = useState(() => {
+    const savedMessages = localStorage.getItem('chatHistory');
+    return savedMessages ? JSON.parse(savedMessages) : [
+      { 
+        role: 'system', 
+        content: `How can I help?`
+      }
+    ];
+  });
+
+  // Save messages to localStorage whenever they change
+  useEffect(() => {
+    localStorage.setItem('chatHistory', JSON.stringify(messages));
+  }, [messages]);
+
+  const [input, setInput] = useState('');
+  const [isLoading, setIsLoading] = useState(false);
+  const [error, setError] = useState(null);
+  const [models, setModels] = useState([]);
+  const [selectedModel, setSelectedModel] = useState('llama3:8b');
+  
+  const messagesEndRef = useRef(null);
+  const inputRef = useRef(null);
+  const terminalSocketRef = useRef(null);
+
+
+  // Scroll to bottom when messages change
+  useEffect(() => {
+    scrollToBottom();
+  }, [messages]);
+
+  // Check if Ollama is running and get available models
+  useEffect(() => {
+    checkOllamaStatus();
+  }, []);
+  
+  // Function to fetch data from the API endpoint for RAG
+  const fetchExternalData = async () => {
+    try {
+      console.log('Fetching data from API endpoint...');
+      // Use no-cache to ensure we always get fresh data
+      const response = await fetch('http://localhost:4321/api/card-collection?action=getPage&pageNumber=1', {
+        method: 'GET',
+        headers: {
+          'Cache-Control': 'no-cache',
+          'Content-Type': 'application/json',
+        },
+      });
+      
+      if (!response.ok) {
+        throw new Error(`Failed to fetch data: ${response.status} ${response.statusText}`);
+      }
+      
+      const data = await response.json();
+      console.log('External data fetched successfully:', data);
+      return data;
+    } catch (err) {
+      console.error('Error fetching external data:', err);
+      return null;
+    }
+  };
+  
+  // Function to process and extract relevant information from the API response
+  const processExternalData = (data) => {
+    console.log('Processing external data...');
+    
+    if (!data) {
+      console.warn('No data provided to processExternalData');
+      return null;
+    }
+    
+    if (!data.items || data.items.length === 0) {
+      console.warn('Data has no items array or empty items array');
+      return null;
+    }
+    
+    try {
+      // Extract content from the first item
+      const item = data.items[0];
+      console.log('Processing first item:', item);
+      
+      if (!item) {
+        console.warn('First item is undefined or null');
+        return null;
+      }
+      
+      let parsedContent;
+      
+      // Try to parse the content if it's a JSON string
+      try {
+        if (typeof item.content === 'string') {
+          console.log('Parsing item content as string');
+          parsedContent = JSON.parse(item.content);
+        } else {
+          console.log('Using item content directly as object');
+          parsedContent = item.content;
+        }
+        console.log('Parsed content:', parsedContent);
+      } catch (e) {
+        console.warn('Failed to parse content as JSON, using as is:', e);
+        parsedContent = item.content;
+      }
+      
+      // Format the data in a readable way
+      let formattedInfo = 'Here is the information I found:\n\n';
+      
+      // Handle calendar-like data with context structure
+      if (parsedContent && parsedContent.context) {
+        console.log('Found context structure in parsed content');
+        const context = parsedContent.context;
+        
+        // Process today, week, and month data if available
+        ['today', 'week', 'month'].forEach(timeframe => {
+          if (context[timeframe] && Array.isArray(context[timeframe]) && context[timeframe].length > 0) {
+            console.log(`Found ${context[timeframe].length} events for ${timeframe}`);
+            formattedInfo += `${timeframe.charAt(0).toUpperCase() + timeframe.slice(1)}:\n`;
+            
+            context[timeframe].forEach((event) => {
+              formattedInfo += `- ${event.summary || 'Event'}`;
+              if (event.start) formattedInfo += ` (${event.start}`;
+              if (event.end && event.end !== event.start) formattedInfo += ` to ${event.end}`;
+              if (event.start) formattedInfo += `)`;
+              formattedInfo += '\n';
+            });
+            
+            formattedInfo += '\n';
+          } else {
+            console.log(`No events found for ${timeframe}`);
+          }
+        });
+      } else {
+        console.log('No context structure found, processing as generic data');
+        // For other types of data, include all available fields
+        formattedInfo += `Title: ${item.title || 'N/A'}\n`;
+        formattedInfo += `Description: ${item.description || 'N/A'}\n`;
+        
+        if (typeof parsedContent === 'object' && parsedContent !== null) {
+          formattedInfo += 'Content:\n';
+          Object.entries(parsedContent).forEach(([key, value]) => {
+            formattedInfo += `- ${key}: ${JSON.stringify(value)}\n`;
+          });
+        } else {
+          formattedInfo += `Content: ${parsedContent || 'N/A'}\n`;
+        }
+      }
+      
+      console.log('Formatted info created successfully');
+      return formattedInfo;
+    } catch (err) {
+      console.error('Error processing external data:', err);
+      return null;
+    }
+  };
+
+  const checkOllamaStatus = async () => {
+    try {
+      const response = await fetch('http://127.0.0.1:11434/api/tags');
+      if (response.ok) {
+        const data = await response.json();
+        if (data.models && data.models.length > 0) {
+          setModels(data.models);
+          // If llama3:8b is available, use it
+          const llama3Model = data.models.find(model => model.name === 'llama3:8b');
+          if (llama3Model) {
+            setSelectedModel('llama3:8b');
+          } else {
+            // Otherwise use the first available model
+            setSelectedModel(data.models[0].name);
+          }
+        }
+      }
+    } catch (err) {
+      console.error('Error checking Ollama status:', err);
+      setError('Cannot connect to Ollama server. Make sure Ollama is running at http://127.0.0.1:11434');
+    }
+  };
+
+
+
+  const scrollToBottom = () => {
+    if (messagesEndRef.current) {
+      messagesEndRef.current.scrollIntoView({ behavior: 'instant', block: 'end' });
+    }
+  };
+  
+
+  const handleInputChange = (e) => {
+    setInput(e.target.value);
+    // Reset typing timer
+    setIsTyping(true);
+    const timer = setTimeout(() => setIsTyping(false), 1000);
+    return () => clearTimeout(timer);
+  };
+  
+
+
+  const handleKeyDown = (e) => {
+    if (e.key === 'Enter' && !e.shiftKey) {
+      e.preventDefault();
+      sendMessage();
+    }
+  };
+
+  useEffect(() => {
+    // Connect to terminal WebSocket server
+    connectToTerminal();
+    return () => {
+      if (terminalSocketRef.current) {
+        terminalSocketRef.current.close();
+      }
+    };
+  }, []);
+
+  const connectToTerminal = () => {
+    try {
+      const ws = new WebSocket('ws://localhost:3001');
+      terminalSocketRef.current = ws;
+
+      ws.onmessage = (event) => {
+        const message = JSON.parse(event.data);
+        if (message.type === 'output') {
+          setMessages(prev => [...prev, {
+            role: 'assistant',
+            content: message.data
+          }]);
+        }
+      };
+    } catch (err) {
+      console.error('Terminal connection error:', err);
+    }
+  };
+
+  // Add this function after other function declarations
+  // Update the processNaturalLanguageCommand function
+  const processNaturalLanguageCommand = (text) => {
+    // Helper function to calculate similarity between two strings
+    const calculateSimilarity = (str1, str2) => {
+      const s1 = str1.toLowerCase();
+      const s2 = str2.toLowerCase();
+      const len1 = s1.length;
+      const len2 = s2.length;
+      const matrix = Array(len1 + 1).fill().map(() => Array(len2 + 1).fill(0));
+
+      for (let i = 0; i <= len1; i++) matrix[i][0] = i;
+      for (let j = 0; j <= len2; j++) matrix[0][j] = j;
+
+      for (let i = 1; i <= len1; i++) {
+        for (let j = 1; j <= len2; j++) {
+          const cost = s1[i - 1] === s2[j - 1] ? 0 : 1;
+          matrix[i][j] = Math.min(
+            matrix[i - 1][j] + 1,
+            matrix[i][j - 1] + 1,
+            matrix[i - 1][j - 1] + cost
+          );
+        }
+      }
+      return 1 - (matrix[len1][len2] / Math.max(len1, len2));
+    };
+
+    // Find closest matching command
+    const findClosestCommand = (input) => {
+      const commands = Object.keys(commandMap);
+      let bestMatch = null;
+      let highestSimilarity = 0;
+
+      commands.forEach(cmd => {
+        const similarity = calculateSimilarity(input, cmd);
+        if (similarity > highestSimilarity && similarity > 0.6) { // Threshold of 60% similarity
+          highestSimilarity = similarity;
+          bestMatch = cmd;
+        }
+      });
+      return bestMatch;
+    };
+
+    const commandMap = {
+      'read': 'cat',
+      'show': 'cat',
+      'list': 'ls',
+      'show files': 'ls',
+      'show directory': 'ls',
+      'current directory': 'pwd',
+      'where am i': 'pwd',
+      'clear screen': 'clear',
+      'make directory': 'mkdir',
+      'create directory': 'mkdir',
+      'remove': 'rm',
+      'delete': 'rm',
+    };
+
+    // Fuzzy patterns for file operations
+    const patterns = {
+      read: /(?:r[ea]+d|sh[o0]w|d[i1]spl[ae]y|[o0]p[e3]n)\s+(?:c[o0]nt[e3]nts?\s+[o0]f\s+|th[e3]\s+)?(?:f[i1]l[e3]\s+)?["']?([^"']+?)["']?\s*$/i,
+      list: /(?:l[i1]st|sh[o0]w)\s+(?:f[i1]l[e3]s?|d[i1]r[e3]ct[o0]r[yi]?s?|c[o0]nt[e3]nts?)\s*(?:[i1]n\s+)?(.+)?/i,
+      mkdir: /(?:m[a4]k[e3]|cr[e3][a4]t[e3])\s+(?:[a4]\s+)?(?:n[e3]w\s+)?d[i1]r(?:[e3]ct[o0]r[yi])?\s+(?:n[a4]m[e3]d\s+)?(.+)/i,
+      remove: /(?:r[e3]m[o0]v[e3]|d[e3]l[e3]t[e3])\s+(?:th[e3]\s+)?(?:f[i1]l[e3]|d[i1]r[e3]ct[o0]r[yi])?\s+(.+)/i,
+      where: /w[he]{1,2}r[e]?\s+(?:am|is)\s+(?:i|me|we)/i
+    };
+
+    let command = '';
+    const input = text.toLowerCase().trim();
+
+    // First try to find exact match
+    if (commandMap[input]) {
+      return commandMap[input];
+    }
+
+    // Then try to find closest match for simple commands
+    const closestMatch = findClosestCommand(input);
+    if (closestMatch) {
+      return commandMap[closestMatch];
+    }
+
+    // Check patterns with fuzzy matching
+    if (patterns.where.test(input)) {
+      command = 'pwd';
+    } else if (patterns.read.test(input)) {
+      const match = input.match(patterns.read);
+      const filename = match[1].trim();
+      command = `cat "${filename}"`;
+    } else if (patterns.list.test(input)) {
+      const match = input.match(patterns.list);
+      command = `ls ${match[1] ? `"${match[1].trim()}"` : ''}`.trim();
+    } else if (patterns.mkdir.test(input)) {
+      const match = input.match(patterns.mkdir);
+      command = `mkdir "${match[1].trim()}"`;
+    } else if (patterns.remove.test(input)) {
+      const match = input.match(patterns.remove);
+      command = `rm "${match[1].trim()}"`;
+    }
+
+    return command;
+  };
+  
+  // Update the sendMessage function's command handling section
+  const sendMessage = async () => {
+    if (!input.trim() || isLoading) return;
+  
+    const userMessage = { role: 'user', content: input.trim() };
+    
+    setMessages(prev => [...prev, userMessage]);
+    setInput('');
+    setIsLoading(true);
+    setError(null);
+  
+    // Check for terminal commands (both direct and natural language)
+    const naturalCommand = processNaturalLanguageCommand(input.trim());
+    if (input.trim().startsWith('$') || naturalCommand) {
+      const command = input.trim().startsWith('$') ? input.trim().slice(1) : naturalCommand;
+      if (terminalSocketRef.current?.readyState === WebSocket.OPEN) {
+        terminalSocketRef.current.send(JSON.stringify({
+          type: 'input',
+          data: command + '\n'
+        }));
+      }
+      setIsLoading(false);
+      return;
+    }
+
+    try {
+      // Add thinking indicator
+      setMessages(prev => [...prev, { role: 'assistant', content: '...', isThinking: true }]);
+
+      // Implement RAG: Fetch external data to augment the response
+      console.log('Starting RAG process...');
+      
+      // Fetch external data and handle the response
+      const externalData = await fetchExternalData();
+      
+      // Prepare a string representation of the raw API response
+      let rawApiResponseStr = 'API Response: ';
+      if (!externalData) {
+        console.warn('No external data retrieved, proceeding without RAG context');
+        rawApiResponseStr += 'Failed to retrieve data from API';
+      } else {
+        console.log('Successfully retrieved external data for RAG');
+        rawApiResponseStr += JSON.stringify(externalData, null, 2);
+      }
+      
+      const contextInfo = processExternalData(externalData);
+      console.log('Processed context info:', contextInfo ? 'Available' : 'Not available');
+      
+      // Prepare messages array with external context if available
+      const messagesForModel = [];
+      
+      // Add system message with context information if available
+      messagesForModel.push({
+        role: 'system',
+        content: `You are a helpful assistant. ${contextInfo ? 'Here is some information that might be relevant to the user\'s query: ' + contextInfo : ''}`
+      });
+      
+      // Add a hidden message with the raw API data for the model to use
+      if (rawApiResponseStr) {
+        messagesForModel.push({
+          role: 'system',
+          content: `Additional context (not to be directly referenced in your response): Raw API response from http://localhost:4321/api/card-collection?action=getPage&pageNumber=1:\n\n${rawApiResponseStr}`
+        });
+      }
+      
+      // Add existing conversation history and user message
+      messagesForModel.push(
+        ...messages.filter(m => !m.isThinking && m.role !== 'system'),
+        userMessage
+      );
+
+      // Call Ollama API with the enhanced context
+      console.log('Sending request to Ollama API with', messagesForModel.length, 'messages');
+      console.log('First message role:', messagesForModel[0]?.role);
+      
+      const response = await fetch(`http://127.0.0.1:11434/api/chat`, {
+        method: 'POST',
+        headers: {
+          'Content-Type': 'application/json',
+        },
+        body: JSON.stringify({
+          model: selectedModel,
+          messages: messagesForModel,
+          stream: false
+        }),
+      });
+
+      if (!response.ok) {
+        throw new Error(`Error: ${response.statusText}`);
+      }
+
+      const data = await response.json();
+      console.log('Received response from Ollama API');
+      
+      // Check if we have a valid response with content
+      if (!data.message || !data.message.content) {
+        console.warn('Received empty or invalid response from Ollama');
+      }
+      
+      // Only show the model's response to the user (hide API data)
+      const assistantResponse = data.message?.content || 'No response from model';
+      
+      // Remove thinking indicator and add actual response
+      setMessages(prev => [
+        ...prev.filter(m => !m.isThinking),
+        { role: 'assistant', content: assistantResponse }
+      ]);
+    } catch (err) {
+      console.error('Error sending message:', err);
+      
+      // Still fetch API data for debugging but don't show it to the user
+      try {
+        const externalData = await fetchExternalData();
+        if (externalData) {
+          console.log('API data retrieved during error recovery:', externalData);
+        }
+      } catch (apiErr) {
+        console.error('Error fetching API data during error recovery:', apiErr);
+      }
+      
+      // Remove thinking indicator and add error message without API data
+      const errorMessage = `Error: ${err.message}. Make sure Ollama is running with the ${selectedModel} model.`;
+      
+      setMessages(prev => [
+        ...prev.filter(m => !m.isThinking),
+        { role: 'error', content: errorMessage }
+      ]);
+      setError(`${err.message}. Make sure Ollama is running with the ${selectedModel} model.`);
+    } finally {
+      setIsLoading(false);
+    }
+  };
+
+  const clearChat = () => {
+    const initialMessage = { role: 'system', content: 'How can I help?' };
+    setMessages([initialMessage]);
+    localStorage.setItem('chatHistory', JSON.stringify([initialMessage]));
+  };
+
+  const handleModelChange = (e) => {
+    setSelectedModel(e.target.value);
+  };
+
+  // Add this after other function declarations
+  // Remove the duplicate state declaration and move it to the top with other states
+  const [selectedText, setSelectedText] = useState('');
+  
+  // Keep the handleMentionClick function, but remove the JSX block that's outside return
+  const handleMentionClick = (word) => {
+    const selection = window.getSelection().toString().trim();
+    const textToAdd = selection || word;
+    setInput(prev => prev + (prev ? ' ' : '') + textToAdd);
+    inputRef.current?.focus();
+  };
+  
+  // Add this with other state declarations at the top
+  const [isWordSelectEnabled, setIsWordSelectEnabled] = useState(true);
+  
+  // Add this near the handleModelChange function
+  const toggleWordSelect = () => {
+    setIsWordSelectEnabled(prev => !prev);
+  };
+  
+  // Update the header section in the return statement
+  // In the return statement, wrap the elements in a parent div
+  return (
+    <div className={`h-full w-full flex flex-col bg-gray-900 text-gray-200 overflow-hidden ${className}`}>
+      <div className="p-2 bg-gray-800 border-b border-gray-700 flex flex-col">
+        <div className="flex items-center mb-2">
+          <div className="text-center flex-grow"><b>Chatbot</b></div>
+          <select 
+            value={selectedModel}
+            onChange={handleModelChange}
+            className="mr-2 px-2 py-1 text-xs bg-gray-700 text-white rounded"
+          >
+            {models.length > 0 ? (
+              models.map(model => (
+                <option key={model.name} value={model.name}>
+                  {model.name}
+                </option>
+              ))
+            ) : (
+              <option key="llama3:8b" value="llama3:8b">llama3:8b</option>
+            )}
+          </select>
+          <button 
+            onClick={clearChat}
+            className="px-2 py-1 text-xs bg-gray-700 hover:bg-gray-600 rounded"
+          >
+            Clear
+          </button>
+        </div>
+
+      </div>
+      
+      {error && (
+        <div className="bg-red-900 text-red-100 p-2 text-sm">
+          {error}
+
+        </div>
+      )}
+      
+      <div className="flex-1 p-4 overflow-y-auto min-h-0">
+        {messages.map((message, index) => (
+          <div key={index} className={`mb-4 ${
+            message.role === 'user' ? 'text-right' : 
+            message.role === 'error' ? 'text-center' : 
+            'text-left'
+          }`}>
+            <div className={`inline-block px-4 py-2 rounded-lg max-w-[80%] ${
+              message.role === 'user' ? 'bg-blue-600 text-white rounded-br-none' : 
+              message.role === 'system' ? 'bg-gray-700 text-gray-200' : 
+              message.role === 'error' ? 'bg-red-600 text-white' : 
+              'bg-gray-800 text-gray-200 rounded-bl-none'
+            } ${message.isThinking ? 'animate-pulse' : ''}`}>
+              <div 
+                className="whitespace-pre-wrap"
+                onMouseUp={() => {
+                  if (!isWordSelectEnabled) return;
+                  const selection = window.getSelection().toString().trim();
+                  if (selection) {
+                    setInput(prev => prev + (prev ? ' ' : '') + selection);
+                    inputRef.current?.focus();
+                  }
+                }}
+              >
+                {message.role === 'assistant' && !message.isThinking ? (
+                  message.content.split(' ').map((word, i) => (
+                    <React.Fragment key={i}>
+                      <span 
+                        className={`${isWordSelectEnabled ? 'cursor-pointer hover:text-yellow-400' : ''} transition-colors`}
+                        onClick={() => isWordSelectEnabled && handleMentionClick(word)}
+                      >
+                        {word}
+                      </span>
+                      {' '}
+                    </React.Fragment>
+                  ))
+                ) : (
+                  message.content
+                )}
+              </div>
+            </div>
+          </div>
+        ))}
+        <div ref={messagesEndRef} />
+      </div>
+      
+      <div className="p-4 border-t border-gray-700">
+        <div className="flex items-start">
+          <div className="relative flex-grow">
+            <textarea
+              ref={inputRef}
+              value={input}
+              onChange={(e) => {
+                handleInputChange(e);
+                setIsTyping(true);
+              }}
+              onKeyDown={handleKeyDown}
+              placeholder="Type your message here..."
+              className="w-full p-2 bg-gray-800 text-white rounded-lg resize-none h-12 max-h-32 min-h-[3rem] pr-10"
+              rows={1}
+              disabled={isLoading}
+            />
+          </div>
+          <button
+            onClick={sendMessage}
+            disabled={isLoading || !input.trim()}
+            className={`ml-2 px-4 py-2 rounded-lg transition-all duration-200 ${
+              isLoading || !input.trim() 
+                ? 'bg-gray-700 text-gray-500 cursor-not-allowed' 
+                : 'bg-blue-600 text-white hover:bg-blue-700 hover:shadow-lg'
+            }`}
+          >
+            {isLoading ? (
+              <svg className="animate-spin h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
+                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
+                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
+              </svg>
+            ) : (
+              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
+                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
+              </svg>
+            )}
+          </button>
+        </div>
+      </div>
+    </div>
+  );
+};
+
+export default ChatbotPanel;

commit ab9615d0205b278048be3180ae88a70464c31edb
Author: Alessandro Rumampuk <44091930+alessandrorumampuk@users.noreply.github.com>
Date:   Tue Jul 1 13:21:24 2025 +0800

    Create chatbotmodern.jsx

diff --git a/src/components/panels/chatbotmodern.jsx b/src/components/panels/chatbotmodern.jsx
new file mode 100644
index 0000000..87032de
--- /dev/null
+++ b/src/components/panels/chatbotmodern.jsx
@@ -0,0 +1,666 @@
+import React, { useState, useEffect, useRef } from 'react';
+
+const ChatbotPanel = ({ className = '' }) => {
+  // Add isTyping state with other state declarations
+  const [isTyping, setIsTyping] = useState(false);
+  const [mentions, setMentions] = useState([]);
+  const [showCommands, setShowCommands] = useState(false);
+  
+  // Initialize messages from localStorage if available
+  const [messages, setMessages] = useState(() => {
+    const savedMessages = localStorage.getItem('chatHistory');
+    return savedMessages ? JSON.parse(savedMessages) : [
+      { 
+        role: 'system', 
+        content: `How can I help?`
+      }
+    ];
+  });
+
+  // Save messages to localStorage whenever they change
+  useEffect(() => {
+    localStorage.setItem('chatHistory', JSON.stringify(messages));
+  }, [messages]);
+
+  const [input, setInput] = useState('');
+  const [isLoading, setIsLoading] = useState(false);
+  const [error, setError] = useState(null);
+  const [models, setModels] = useState([]);
+  const [selectedModel, setSelectedModel] = useState('llama3:8b');
+  
+  const messagesEndRef = useRef(null);
+  const inputRef = useRef(null);
+  const terminalSocketRef = useRef(null);
+
+
+  // Scroll to bottom when messages change
+  useEffect(() => {
+    scrollToBottom();
+  }, [messages]);
+
+  // Check if Ollama is running and get available models
+  useEffect(() => {
+    checkOllamaStatus();
+  }, []);
+  
+  // Function to fetch data from the API endpoint for RAG
+  const fetchExternalData = async () => {
+    try {
+      console.log('Fetching data from API endpoint...');
+      // Use no-cache to ensure we always get fresh data
+      const response = await fetch('http://localhost:4321/api/card-collection?action=getPage&pageNumber=1', {
+        method: 'GET',
+        headers: {
+          'Cache-Control': 'no-cache',
+          'Content-Type': 'application/json',
+        },
+      });
+      
+      if (!response.ok) {
+        throw new Error(`Failed to fetch data: ${response.status} ${response.statusText}`);
+      }
+      
+      const data = await response.json();
+      console.log('External data fetched successfully:', data);
+      return data;
+    } catch (err) {
+      console.error('Error fetching external data:', err);
+      return null;
+    }
+  };
+  
+  // Function to process and extract relevant information from the API response
+  const processExternalData = (data) => {
+    console.log('Processing external data...');
+    
+    if (!data) {
+      console.warn('No data provided to processExternalData');
+      return null;
+    }
+    
+    if (!data.items || data.items.length === 0) {
+      console.warn('Data has no items array or empty items array');
+      return null;
+    }
+    
+    try {
+      // Extract content from the first item
+      const item = data.items[0];
+      console.log('Processing first item:', item);
+      
+      if (!item) {
+        console.warn('First item is undefined or null');
+        return null;
+      }
+      
+      let parsedContent;
+      
+      // Try to parse the content if it's a JSON string
+      try {
+        if (typeof item.content === 'string') {
+          console.log('Parsing item content as string');
+          parsedContent = JSON.parse(item.content);
+        } else {
+          console.log('Using item content directly as object');
+          parsedContent = item.content;
+        }
+        console.log('Parsed content:', parsedContent);
+      } catch (e) {
+        console.warn('Failed to parse content as JSON, using as is:', e);
+        parsedContent = item.content;
+      }
+      
+      // Format the data in a readable way
+      let formattedInfo = 'Here is the information I found:\n\n';
+      
+      // Handle calendar-like data with context structure
+      if (parsedContent && parsedContent.context) {
+        console.log('Found context structure in parsed content');
+        const context = parsedContent.context;
+        
+        // Process today, week, and month data if available
+        ['today', 'week', 'month'].forEach(timeframe => {
+          if (context[timeframe] && Array.isArray(context[timeframe]) && context[timeframe].length > 0) {
+            console.log(`Found ${context[timeframe].length} events for ${timeframe}`);
+            formattedInfo += `${timeframe.charAt(0).toUpperCase() + timeframe.slice(1)}:\n`;
+            
+            context[timeframe].forEach((event) => {
+              formattedInfo += `- ${event.summary || 'Event'}`;
+              if (event.start) formattedInfo += ` (${event.start}`;
+              if (event.end && event.end !== event.start) formattedInfo += ` to ${event.end}`;
+              if (event.start) formattedInfo += `)`;
+              formattedInfo += '\n';
+            });
+            
+            formattedInfo += '\n';
+          } else {
+            console.log(`No events found for ${timeframe}`);
+          }
+        });
+      } else {
+        console.log('No context structure found, processing as generic data');
+        // For other types of data, include all available fields
+        formattedInfo += `Title: ${item.title || 'N/A'}\n`;
+        formattedInfo += `Description: ${item.description || 'N/A'}\n`;
+        
+        if (typeof parsedContent === 'object' && parsedContent !== null) {
+          formattedInfo += 'Content:\n';
+          Object.entries(parsedContent).forEach(([key, value]) => {
+            formattedInfo += `- ${key}: ${JSON.stringify(value)}\n`;
+          });
+        } else {
+          formattedInfo += `Content: ${parsedContent || 'N/A'}\n`;
+        }
+      }
+      
+      console.log('Formatted info created successfully');
+      return formattedInfo;
+    } catch (err) {
+      console.error('Error processing external data:', err);
+      return null;
+    }
+  };
+
+  const checkOllamaStatus = async () => {
+    try {
+      const response = await fetch('http://127.0.0.1:11434/api/tags');
+      if (response.ok) {
+        const data = await response.json();
+        if (data.models && data.models.length > 0) {
+          setModels(data.models);
+          // If llama3:8b is available, use it
+          const llama3Model = data.models.find(model => model.name === 'llama3:8b');
+          if (llama3Model) {
+            setSelectedModel('llama3:8b');
+          } else {
+            // Otherwise use the first available model
+            setSelectedModel(data.models[0].name);
+          }
+        }
+      }
+    } catch (err) {
+      console.error('Error checking Ollama status:', err);
+      setError('Cannot connect to Ollama server. Make sure Ollama is running at http://127.0.0.1:11434');
+    }
+  };
+
+
+
+  const scrollToBottom = () => {
+    if (messagesEndRef.current) {
+      messagesEndRef.current.scrollIntoView({ behavior: 'instant', block: 'end' });
+    }
+  };
+  
+
+  const handleInputChange = (e) => {
+    setInput(e.target.value);
+    // Reset typing timer
+    setIsTyping(true);
+    const timer = setTimeout(() => setIsTyping(false), 1000);
+    return () => clearTimeout(timer);
+  };
+  
+
+
+  const handleKeyDown = (e) => {
+    if (e.key === 'Enter' && !e.shiftKey) {
+      e.preventDefault();
+      sendMessage();
+    }
+  };
+
+  useEffect(() => {
+    // Connect to terminal WebSocket server
+    connectToTerminal();
+    return () => {
+      if (terminalSocketRef.current) {
+        terminalSocketRef.current.close();
+      }
+    };
+  }, []);
+
+  const connectToTerminal = () => {
+    try {
+      const ws = new WebSocket('ws://localhost:3001');
+      terminalSocketRef.current = ws;
+
+      ws.onmessage = (event) => {
+        const message = JSON.parse(event.data);
+        if (message.type === 'output') {
+          setMessages(prev => [...prev, {
+            role: 'assistant',
+            content: message.data
+          }]);
+        }
+      };
+    } catch (err) {
+      console.error('Terminal connection error:', err);
+    }
+  };
+
+  // Add this function after other function declarations
+  // Update the processNaturalLanguageCommand function
+  const processNaturalLanguageCommand = (text) => {
+    // Helper function to calculate similarity between two strings
+    const calculateSimilarity = (str1, str2) => {
+      const s1 = str1.toLowerCase();
+      const s2 = str2.toLowerCase();
+      const len1 = s1.length;
+      const len2 = s2.length;
+      const matrix = Array(len1 + 1).fill().map(() => Array(len2 + 1).fill(0));
+
+      for (let i = 0; i <= len1; i++) matrix[i][0] = i;
+      for (let j = 0; j <= len2; j++) matrix[0][j] = j;
+
+      for (let i = 1; i <= len1; i++) {
+        for (let j = 1; j <= len2; j++) {
+          const cost = s1[i - 1] === s2[j - 1] ? 0 : 1;
+          matrix[i][j] = Math.min(
+            matrix[i - 1][j] + 1,
+            matrix[i][j - 1] + 1,
+            matrix[i - 1][j - 1] + cost
+          );
+        }
+      }
+      return 1 - (matrix[len1][len2] / Math.max(len1, len2));
+    };
+
+    // Find closest matching command
+    const findClosestCommand = (input) => {
+      const commands = Object.keys(commandMap);
+      let bestMatch = null;
+      let highestSimilarity = 0;
+
+      commands.forEach(cmd => {
+        const similarity = calculateSimilarity(input, cmd);
+        if (similarity > highestSimilarity && similarity > 0.6) { // Threshold of 60% similarity
+          highestSimilarity = similarity;
+          bestMatch = cmd;
+        }
+      });
+      return bestMatch;
+    };
+
+    const commandMap = {
+      'read': 'cat',
+      'show': 'cat',
+      'list': 'ls',
+      'show files': 'ls',
+      'show directory': 'ls',
+      'current directory': 'pwd',
+      'where am i': 'pwd',
+      'clear screen': 'clear',
+      'make directory': 'mkdir',
+      'create directory': 'mkdir',
+      'remove': 'rm',
+      'delete': 'rm',
+    };
+
+    // Fuzzy patterns for file operations
+    const patterns = {
+      read: /(?:r[ea]+d|sh[o0]w|d[i1]spl[ae]y|[o0]p[e3]n)\s+(?:c[o0]nt[e3]nts?\s+[o0]f\s+|th[e3]\s+)?(?:f[i1]l[e3]\s+)?["']?([^"']+?)["']?\s*$/i,
+      list: /(?:l[i1]st|sh[o0]w)\s+(?:f[i1]l[e3]s?|d[i1]r[e3]ct[o0]r[yi]?s?|c[o0]nt[e3]nts?)\s*(?:[i1]n\s+)?(.+)?/i,
+      mkdir: /(?:m[a4]k[e3]|cr[e3][a4]t[e3])\s+(?:[a4]\s+)?(?:n[e3]w\s+)?d[i1]r(?:[e3]ct[o0]r[yi])?\s+(?:n[a4]m[e3]d\s+)?(.+)/i,
+      remove: /(?:r[e3]m[o0]v[e3]|d[e3]l[e3]t[e3])\s+(?:th[e3]\s+)?(?:f[i1]l[e3]|d[i1]r[e3]ct[o0]r[yi])?\s+(.+)/i,
+      where: /w[he]{1,2}r[e]?\s+(?:am|is)\s+(?:i|me|we)/i
+    };
+
+    let command = '';
+    const input = text.toLowerCase().trim();
+
+    // First try to find exact match
+    if (commandMap[input]) {
+      return commandMap[input];
+    }
+
+    // Then try to find closest match for simple commands
+    const closestMatch = findClosestCommand(input);
+    if (closestMatch) {
+      return commandMap[closestMatch];
+    }
+
+    // Check patterns with fuzzy matching
+    if (patterns.where.test(input)) {
+      command = 'pwd';
+    } else if (patterns.read.test(input)) {
+      const match = input.match(patterns.read);
+      const filename = match[1].trim();
+      command = `cat "${filename}"`;
+    } else if (patterns.list.test(input)) {
+      const match = input.match(patterns.list);
+      command = `ls ${match[1] ? `"${match[1].trim()}"` : ''}`.trim();
+    } else if (patterns.mkdir.test(input)) {
+      const match = input.match(patterns.mkdir);
+      command = `mkdir "${match[1].trim()}"`;
+    } else if (patterns.remove.test(input)) {
+      const match = input.match(patterns.remove);
+      command = `rm "${match[1].trim()}"`;
+    }
+
+    return command;
+  };
+  
+  // Update the sendMessage function's command handling section
+  const sendMessage = async () => {
+    if (!input.trim() || isLoading) return;
+  
+    const userMessage = { role: 'user', content: input.trim() };
+    
+    setMessages(prev => [...prev, userMessage]);
+    setInput('');
+    setIsLoading(true);
+    setError(null);
+  
+    // Check for terminal commands (both direct and natural language)
+    const naturalCommand = processNaturalLanguageCommand(input.trim());
+    if (input.trim().startsWith('$') || naturalCommand) {
+      const command = input.trim().startsWith('$') ? input.trim().slice(1) : naturalCommand;
+      if (terminalSocketRef.current?.readyState === WebSocket.OPEN) {
+        terminalSocketRef.current.send(JSON.stringify({
+          type: 'input',
+          data: command + '\n'
+        }));
+      }
+      setIsLoading(false);
+      return;
+    }
+
+    try {
+      // Add thinking indicator
+      setMessages(prev => [...prev, { role: 'assistant', content: '...', isThinking: true }]);
+
+      // Implement RAG: Fetch external data to augment the response
+      console.log('Starting RAG process...');
+      
+      // Fetch external data and handle the response
+      const externalData = await fetchExternalData();
+      
+      // Prepare a string representation of the raw API response
+      let rawApiResponseStr = 'API Response: ';
+      if (!externalData) {
+        console.warn('No external data retrieved, proceeding without RAG context');
+        rawApiResponseStr += 'Failed to retrieve data from API';
+      } else {
+        console.log('Successfully retrieved external data for RAG');
+        rawApiResponseStr += JSON.stringify(externalData, null, 2);
+      }
+      
+      const contextInfo = processExternalData(externalData);
+      console.log('Processed context info:', contextInfo ? 'Available' : 'Not available');
+      
+      // Prepare messages array with external context if available
+      const messagesForModel = [];
+      
+      // Add system message with context information if available
+      messagesForModel.push({
+        role: 'system',
+        content: `You are a helpful assistant. ${contextInfo ? 'Here is some information that might be relevant to the user\'s query: ' + contextInfo : ''}`
+      });
+      
+      // Add a hidden message with the raw API data for the model to use
+      if (rawApiResponseStr) {
+        messagesForModel.push({
+          role: 'system',
+          content: `Additional context (not to be directly referenced in your response): Raw API response from http://localhost:4321/api/card-collection?action=getPage&pageNumber=1:\n\n${rawApiResponseStr}`
+        });
+      }
+      
+      // Add existing conversation history and user message
+      messagesForModel.push(
+        ...messages.filter(m => !m.isThinking && m.role !== 'system'),
+        userMessage
+      );
+
+      // Call Ollama API with the enhanced context
+      console.log('Sending request to Ollama API with', messagesForModel.length, 'messages');
+      console.log('First message role:', messagesForModel[0]?.role);
+      
+      const response = await fetch(`http://127.0.0.1:11434/api/chat`, {
+        method: 'POST',
+        headers: {
+          'Content-Type': 'application/json',
+        },
+        body: JSON.stringify({
+          model: selectedModel,
+          messages: messagesForModel,
+          stream: false
+        }),
+      });
+
+      if (!response.ok) {
+        throw new Error(`Error: ${response.statusText}`);
+      }
+
+      const data = await response.json();
+      console.log('Received response from Ollama API');
+      
+      // Check if we have a valid response with content
+      if (!data.message || !data.message.content) {
+        console.warn('Received empty or invalid response from Ollama');
+      }
+      
+      // Only show the model's response to the user (hide API data)
+      const assistantResponse = data.message?.content || 'No response from model';
+      
+      // Remove thinking indicator and add actual response
+      setMessages(prev => [
+        ...prev.filter(m => !m.isThinking),
+        { role: 'assistant', content: assistantResponse }
+      ]);
+    } catch (err) {
+      console.error('Error sending message:', err);
+      
+      // Still fetch API data for debugging but don't show it to the user
+      try {
+        const externalData = await fetchExternalData();
+        if (externalData) {
+          console.log('API data retrieved during error recovery:', externalData);
+        }
+      } catch (apiErr) {
+        console.error('Error fetching API data during error recovery:', apiErr);
+      }
+      
+      // Remove thinking indicator and add error message without API data
+      const errorMessage = `Error: ${err.message}. Make sure Ollama is running with the ${selectedModel} model.`;
+      
+      setMessages(prev => [
+        ...prev.filter(m => !m.isThinking),
+        { role: 'error', content: errorMessage }
+      ]);
+      setError(`${err.message}. Make sure Ollama is running with the ${selectedModel} model.`);
+    } finally {
+      setIsLoading(false);
+    }
+  };
+
+  const clearChat = () => {
+    const initialMessage = { role: 'system', content: 'How can I help?' };
+    setMessages([initialMessage]);
+    localStorage.setItem('chatHistory', JSON.stringify([initialMessage]));
+  };
+
+  const handleModelChange = (e) => {
+    setSelectedModel(e.target.value);
+  };
+
+  // Add this after other function declarations
+  // Remove the duplicate state declaration and move it to the top with other states
+  const [selectedText, setSelectedText] = useState('');
+  
+  // Keep the handleMentionClick function, but remove the JSX block that's outside return
+  const handleMentionClick = (word) => {
+    const selection = window.getSelection().toString().trim();
+    const textToAdd = selection || word;
+    setInput(prev => prev + (prev ? ' ' : '') + textToAdd);
+    inputRef.current?.focus();
+  };
+  
+  // Add this with other state declarations at the top
+  const [isWordSelectEnabled, setIsWordSelectEnabled] = useState(true);
+  
+  // Add this near the handleModelChange function
+  const toggleWordSelect = () => {
+    setIsWordSelectEnabled(prev => !prev);
+  };
+  
+  // Update the header section in the return statement
+  // In the return statement, wrap the elements in a parent div
+  return (
+    <div className={`h-full w-full flex flex-col bg-gradient-to-b from-white to-gray-100 text-gray-800 overflow-hidden ${className}`}>
+      <div className="p-4 bg-opacity-90 backdrop-blur-sm bg-white border-b border-gray-200 shadow-md">
+        <div className="flex items-center justify-between">
+          <div className="flex items-center space-x-3">
+            <div className="text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-500">
+              AI Assistant
+            </div>
+            <div className="h-2 w-2 rounded-full bg-green-500 animate-pulse"></div>
+          </div>
+          <div className="flex items-center space-x-3">
+            <select 
+              value={selectedModel}
+              onChange={handleModelChange}
+              className="px-3 py-1.5 text-sm bg-white text-gray-800 rounded-lg border border-gray-300 hover:border-gray-400 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500"
+            >
+              {models.length > 0 ? (
+                models.map(model => (
+                  <option key={model.name} value={model.name}>
+                    {model.name}
+                  </option>
+                ))
+              ) : (
+                <option key="llama3:8b" value="llama3:8b">llama3:8b</option>
+              )}
+            </select>
+            <button 
+              onClick={clearChat}
+              className="px-3 py-1.5 text-sm bg-white hover:bg-gray-50 text-gray-800 rounded-lg border border-gray-300 hover:border-gray-400 transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-red-500 flex items-center space-x-1"
+            >
+              <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
+                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
+              </svg>
+              <span>Clear Chat</span>
+            </button>
+          </div>
+        </div>
+
+      </div>
+      
+      {error && (
+        <div className="bg-red-900 text-red-100 p-2 text-sm">
+          {error}
+
+        </div>
+      )}
+      
+      <div className="flex-1 p-4 overflow-y-auto min-h-0 space-y-4 scrollbar-thin scrollbar-thumb-gray-400 scrollbar-track-gray-200">
+        {messages.map((message, index) => (
+          <div key={index} className={`flex ${message.role === 'user' ? 'justify-end' : 'justify-start'} ${
+            message.role === 'user' ? 'items-end' : 
+            message.role === 'error' ? 'items-center justify-center' : 
+            'items-start'
+          }`}>
+            {message.role === 'assistant' && !message.isThinking && (
+              <div className="flex-shrink-0 w-8 h-8 rounded-full bg-gradient-to-r from-blue-400 to-purple-500 flex items-center justify-center mr-2">
+                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
+                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
+                </svg>
+              </div>
+            )}
+            <div className={`px-4 py-3 rounded-2xl shadow-sm max-w-[80%] backdrop-blur-sm ${
+              message.role === 'user' ? 'bg-gradient-to-r from-blue-500 to-blue-600 text-white rounded-br-none' : 
+              message.role === 'system' ? 'bg-gray-100 text-gray-800' : 
+              message.role === 'error' ? 'bg-red-500 text-white' : 
+              'bg-white text-gray-800 rounded-bl-none'
+            } ${message.isThinking ? 'animate-pulse' : ''}`}>
+              <div 
+                className="whitespace-pre-wrap"
+                onMouseUp={() => {
+                  if (!isWordSelectEnabled) return;
+                  const selection = window.getSelection().toString().trim();
+                  if (selection) {
+                    setInput(prev => prev + (prev ? ' ' : '') + selection);
+                    inputRef.current?.focus();
+                  }
+                }}
+              >
+                {message.role === 'assistant' && !message.isThinking ? (
+                  message.content.split(' ').map((word, i) => (
+                    <React.Fragment key={i}>
+                      <span 
+                        className={`${isWordSelectEnabled ? 'cursor-pointer hover:text-yellow-400' : ''} transition-colors`}
+                        onClick={() => isWordSelectEnabled && handleMentionClick(word)}
+                      >
+                        {word}
+                      </span>
+                      {' '}
+                    </React.Fragment>
+                  ))
+                ) : (
+                  message.content
+                )}
+              </div>
+            </div>
+          </div>
+        ))}
+        <div ref={messagesEndRef} />
+      </div>
+      
+      <div className="p-4 border-t border-gray-200 backdrop-blur-sm bg-white">
+        <div className="flex items-start max-w-4xl mx-auto">
+          <div className="relative flex-grow">
+            <textarea
+              ref={inputRef}
+              value={input}
+              onChange={(e) => {
+                handleInputChange(e);
+                setIsTyping(true);
+              }}
+              onKeyDown={handleKeyDown}
+              placeholder="Type your message here... (Press Enter to send)"
+              className="w-full p-3 bg-gray-50 text-gray-800 rounded-2xl resize-none h-12 max-h-32 min-h-[3rem] pr-12 border border-gray-300 focus:border-blue-500 focus:ring-2 focus:ring-blue-500/20 transition-all duration-200 placeholder-gray-500"
+              rows={1}
+              disabled={isLoading}
+            />
+            {isTyping && (
+              <div className="absolute right-3 bottom-3 text-xs text-gray-500">
+                typing...
+              </div>
+            )}
+          </div>
+          <button
+            onClick={sendMessage}
+            disabled={isLoading || !input.trim()}
+            className={`ml-3 p-3 rounded-xl transition-all duration-300 transform hover:scale-105 ${
+              isLoading || !input.trim() 
+                ? 'bg-gray-100 text-gray-400 cursor-not-allowed' 
+                : 'bg-gradient-to-r from-blue-500 to-blue-600 text-white hover:from-blue-600 hover:to-blue-700 hover:shadow-lg shadow-sm'
+            }`}
+          >
+            <div className="relative w-5 h-5">
+              {isLoading ? (
+                <div className="absolute inset-0 flex items-center justify-center">
+                  <div className="h-5 w-5 relative">
+                    <div className="absolute inset-0 opacity-75 animate-ping rounded-full bg-white"></div>
+                    <svg className="relative animate-spin" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
+                      <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
+                      <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
+                    </svg>
+                  </div>
+                </div>
+              ) : (
+                <div className="absolute inset-0 flex items-center justify-center transition-transform duration-200 hover:scale-110">
+                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor">
+                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
+                  </svg>
+                </div>
+              )}
+            </div>
+          </button>
+        </div>
+      </div>
+    </div>
+  );
+};
+
+export default ChatbotPanel;
```
