# Git Activity Log - Henry Koo
Generated at: Tue Mar 18 00:41:50 UTC 2025
## Changes by Henry Koo
```diff
commit 2eb5dd85e38b3b45ecc505f4c200b5d6116de96a
Author: Henrykoo <lckoo1230@gmail.com>
Date:   Mon Mar 17 17:48:18 2025 +0800

    Fix service worker registration issues and enhance PWA capabilities

diff --git a/astro.config.mjs b/astro.config.mjs
index dd7e18f..80773e3 100644
--- a/astro.config.mjs
+++ b/astro.config.mjs
@@ -1,15 +1,19 @@
 // @ts-check
 import { defineConfig } from 'astro/config';
 import react from '@astrojs/react';
-import path from 'path';
 import AstroPWA from '@vite-pwa/astro';
+import path from 'path';
 
 // https://astro.build/config
 export default defineConfig({
   integrations: [
     react(),
     AstroPWA({
-      registerType: 'autoUpdate',
+      mode: 'production',
+      base: '/',
+      scope: '/',
+      includeAssets: ['favicon.svg', 'pwa-192x192.png', 'pwa-512x512.png'],
+      registerType: 'prompt',
       manifest: {
         name: 'Redux Todo in Astro',
         short_name: 'Redux Todo',
@@ -27,20 +31,15 @@ export default defineConfig({
             src: 'pwa-512x512.png',
             sizes: '512x512',
             type: 'image/png',
-          },
-          {
-            src: 'pwa-512x512.png',
-            sizes: '512x512',
-            type: 'image/png',
-            purpose: 'maskable',
           }
         ]
       },
       workbox: {
-        // Use navigation fallback to the offline page
-        navigateFallback: '/offline',
-        globPatterns: ['**/*.{js,css,html,svg,png,ico,jpg,jpeg}'],
-        // Customize caching strategies for different resources
+        navigateFallback: '/',
+        globPatterns: ['**/*.{css,js,html,svg,png,ico,txt}'],
+        cleanupOutdatedCaches: true,
+        clientsClaim: true,
+        skipWaiting: true,
         runtimeCaching: [
           {
             urlPattern: /^https:\/\/fonts\.googleapis\.com\/.*/i,
@@ -50,6 +49,9 @@ export default defineConfig({
               expiration: {
                 maxEntries: 10,
                 maxAgeSeconds: 60 * 60 * 24 * 365 // 1 year
+              },
+              cacheableResponse: {
+                statuses: [0, 200]
               }
             }
           },
@@ -57,10 +59,68 @@ export default defineConfig({
             urlPattern: /^https:\/\/fonts\.gstatic\.com\/.*/i,
             handler: 'CacheFirst',
             options: {
-              cacheName: 'gstatic-fonts-cache',
+              cacheName: 'google-fonts-cache',
               expiration: {
                 maxEntries: 10,
                 maxAgeSeconds: 60 * 60 * 24 * 365 // 1 year
+              },
+              cacheableResponse: {
+                statuses: [0, 200]
+              }
+            }
+          },
+          {
+            urlPattern: ({ url }) => {
+              return url.origin === self.location.origin && 
+                    (url.pathname.endsWith('.png') || 
+                     url.pathname.endsWith('.jpg') || 
+                     url.pathname.endsWith('.svg') || 
+                     url.pathname.endsWith('.webp'));
+            },
+            handler: 'CacheFirst',
+            options: {
+              cacheName: 'images-cache',
+              expiration: {
+                maxEntries: 50,
+                maxAgeSeconds: 60 * 60 * 24 * 30 // 30 days
+              }
+            }
+          },
+          {
+            urlPattern: new RegExp('/_astro/'),
+            handler: 'CacheFirst',
+            options: {
+              cacheName: 'astro-assets-cache',
+              expiration: {
+                maxEntries: 50,
+                maxAgeSeconds: 60 * 60 * 24 * 90 // 90 days
+              }
+            }
+          },
+          {
+            urlPattern: ({ url }) => {
+              return url.origin === self.location.origin && url.pathname.startsWith('/api');
+            },
+            handler: 'NetworkFirst',
+            options: {
+              cacheName: 'api-cache',
+              expiration: {
+                maxEntries: 50,
+                maxAgeSeconds: 60 * 60 // 1 hour
+              },
+              networkTimeoutSeconds: 10
+            }
+          },
+          {
+            urlPattern: ({ url }) => {
+              return url.origin === self.location.origin;
+            },
+            handler: 'NetworkFirst',
+            options: {
+              cacheName: 'pages-cache',
+              expiration: {
+                maxEntries: 20,
+                maxAgeSeconds: 60 * 60 * 24 // 24 hours
               }
             }
           }
@@ -69,8 +129,9 @@ export default defineConfig({
       devOptions: {
         enabled: true,
         type: 'module',
-      },
-    }),
+        navigateFallback: '/',
+      }
+    })
   ],
   vite: {
     resolve: {
diff --git a/package.json b/package.json
index 754aee9..e4f45dc 100644
--- a/package.json
+++ b/package.json
@@ -14,38 +14,31 @@
   "dependencies": {
     "@astrojs/react": "latest",
     "@radix-ui/react-dialog": "^1.1.4",
-    "@radix-ui/react-label": "^2.1.1",
-    "@radix-ui/react-slot": "^1.1.1",
-    "@reduxjs/toolkit": "^2.5.0",
+    "@react-spring/web": "^9.7.3",
+    "@reduxjs/toolkit": "^2.6.1",
     "astro": "^5.3.0",
-    "class-variance-authority": "^0.7.1",
-    "clsx": "^2.1.1",
-    "lucide-react": "^0.473.0",
-    "react": "^19.0.0",
-    "react-dom": "^19.0.0",
+    "class-variance-authority": "^0.7.0",
+    "classnames": "^2.3.1",
+    "jimp": "^0.22.8",
+    "lucide-react": "^0.284.0",
+    "react": "^18.2.0",
+    "react-dom": "^18.2.0",
     "react-draggable": "^4.4.6",
-    "react-icons": "^5.4.0",
-    "react-redux": "^9.2.0",
+    "react-icons": "^5.5.0",
+    "react-redux": "^8.1.2",
     "react-resizable-panels": "^2.1.7",
     "react-split": "^2.0.14",
     "redux-persist": "^6.0.0",
-    "tailwind-merge": "^2.6.0",
-    "tailwindcss": "^3.4.17"
+    "tailwind-merge": "^1.14.0",
+    "tailwindcss-animate": "^1.0.7"
   },
   "devDependencies": {
-    "@babel/preset-env": "^7.26.9",
-    "@babel/preset-react": "^7.26.3",
-    "@typescript-eslint/eslint-plugin": "^8.26.0",
-    "@typescript-eslint/parser": "^8.26.0",
-    "@vite-pwa/astro": "^0.2.0",
-    "autoprefixer": "^10.4.20",
-    "babel-jest": "^29.7.0",
-    "eslint": "^9.21.0",
-    "eslint-plugin-astro": "^1.3.1",
-    "eslint-plugin-react": "^7.37.4",
-    "jest": "^29.7.0",
-    "jest-environment-jsdom": "^29.7.0",
-    "jsdom": "^26.0.0",
-    "tailwindcss-animate": "^1.0.7"
+    "@tailwindcss/typography": "^0.5.10",
+    "@types/react": "^18.2.21",
+    "@vite-pwa/astro": "^0.5.0",
+    "autoprefixer": "^10.4.15",
+    "jest": "^29.5.0",
+    "postcss": "^8.4.29",
+    "tailwindcss": "^3.3.3"
   }
 }
diff --git a/public/custom-sw.js b/public/custom-sw.js
new file mode 100644
index 0000000..a15dc7e
--- /dev/null
+++ b/public/custom-sw.js
@@ -0,0 +1,128 @@
+// This is a custom service worker implementation
+
+const CACHE_NAME = 'redux-todo-app-v1';
+const urlsToCache = [
+  '/',
+  '/index.html',
+  '/favicon.svg',
+  '/manifest.webmanifest',
+  '/pwa-192x192.png',
+  '/pwa-512x512.png'
+];
+
+// Install event - cache assets
+self.addEventListener('install', event => {
+  console.log('[Custom ServiceWorker] Install');
+  event.waitUntil(
+    caches.open(CACHE_NAME)
+      .then(cache => {
+        console.log('[Custom ServiceWorker] Caching app shell');
+        return cache.addAll(urlsToCache);
+      })
+      .then(() => {
+        console.log('[Custom ServiceWorker] Cached app shell');
+        return self.skipWaiting();
+      })
+  );
+});
+
+// Activate event - clean up old caches
+self.addEventListener('activate', event => {
+  console.log('[Custom ServiceWorker] Activate');
+  event.waitUntil(
+    caches.keys().then(cacheNames => {
+      return Promise.all(
+        cacheNames.filter(cacheName => {
+          return cacheName !== CACHE_NAME;
+        }).map(cacheName => {
+          console.log('[Custom ServiceWorker] Removing old cache', cacheName);
+          return caches.delete(cacheName);
+        })
+      );
+    }).then(() => {
+      console.log('[Custom ServiceWorker] Claiming clients');
+      // Take control of all clients ASAP
+      return self.clients.claim();
+    })
+  );
+});
+
+// Fetch event - serve from cache, fall back to network
+self.addEventListener('fetch', event => {
+  console.log('[Custom ServiceWorker] Fetch', event.request.url);
+  
+  // Skip cross-origin requests
+  if (!event.request.url.startsWith(self.location.origin)) {
+    return;
+  }
+  
+  event.respondWith(
+    caches.match(event.request)
+      .then(response => {
+        // Cache hit - return response
+        if (response) {
+          console.log('[Custom ServiceWorker] Cache hit for', event.request.url);
+          return response;
+        }
+        
+        // Clone the request because it's a one-time use stream
+        const fetchRequest = event.request.clone();
+        
+        return fetch(fetchRequest).then(response => {
+          // Check if we received a valid response
+          if (!response || response.status !== 200 || response.type !== 'basic') {
+            return response;
+          }
+          
+          // Clone the response because it's a one-time use stream
+          const responseToCache = response.clone();
+          
+          caches.open(CACHE_NAME)
+            .then(cache => {
+              console.log('[Custom ServiceWorker] Caching new resource:', event.request.url);
+              cache.put(event.request, responseToCache);
+            });
+            
+          return response;
+        });
+      })
+  );
+});
+
+// Message event handler
+self.addEventListener('message', event => {
+  console.log('[Custom ServiceWorker] Message received:', event.data);
+  
+  if (event.data && event.data.type === 'SKIP_WAITING') {
+    console.log('[Custom ServiceWorker] Skip waiting message received');
+    self.skipWaiting();
+  }
+});
+
+// Push notification event handler
+self.addEventListener('push', event => {
+  console.log('[Custom ServiceWorker] Push received:', event);
+  
+  const title = 'Redux Todo App';
+  const options = {
+    body: event.data ? event.data.text() : 'New content available!',
+    icon: '/pwa-192x192.png',
+    badge: '/pwa-192x192.png'
+  };
+  
+  event.waitUntil(
+    self.registration.showNotification(title, options)
+  );
+});
+
+// Notification click event handler
+self.addEventListener('notificationclick', event => {
+  console.log('[Custom ServiceWorker] Notification click:', event);
+  event.notification.close();
+  
+  event.waitUntil(
+    clients.openWindow('/')
+  );
+});
+
+console.log('[Custom ServiceWorker] Loaded successfully');
diff --git a/public/sw-register.js b/public/sw-register.js
index f2988d1..1527685 100644
--- a/public/sw-register.js
+++ b/public/sw-register.js
@@ -1,11 +1,50 @@
-// Manual Service Worker Registration for PWA
+// Improved Service Worker Registration for PWA
 if ('serviceWorker' in navigator) {
-  window.addEventListener('load', function() {
-    navigator.serviceWorker.register('/sw.js')
-      .then(function(registration) {
-        console.log('ServiceWorker registration successful with scope: ', registration.scope);
+  window.addEventListener('load', async function() {
+    console.log('Attempting to register service worker...');
+    
+    // First unregister any existing service workers to ensure clean state
+    try {
+      const registrations = await navigator.serviceWorker.getRegistrations();
+      for (const registration of registrations) {
+        console.log('Unregistering previous service worker');
+        await registration.unregister();
+      }
+      console.log('All previous service workers unregistered');
+    } catch (err) {
+      console.warn('Error unregistering existing service workers:', err);
+    }
+    
+    // Now register the service worker
+    const registerServiceWorker = async () => {
+      try {
+        // First try the Workbox-generated service worker
+        const registration = await navigator.serviceWorker.register('/sw.js', {
+          scope: '/',
+          updateViaCache: 'none' // Prevent caching issues
+        });
+        
+        console.log('ServiceWorker registration successful with scope:', registration.scope);
+        
+        // Force update check
+        registration.update();
+        
+        // Listen for updates
+        registration.addEventListener('updatefound', () => {
+          const newWorker = registration.installing;
+          console.log('New service worker is being installed');
+          
+          newWorker.addEventListener('statechange', () => {
+            console.log('Service worker state changed:', newWorker.state);
+          });
+        });
+        
+        // Handle messages from service worker
+        navigator.serviceWorker.addEventListener('message', function(event) {
+          console.log('Message from service worker:', event.data);
+        });
         
-        // Listen for new worker activation
+        // Set up refresh on controller change
         let refreshing = false;
         navigator.serviceWorker.addEventListener('controllerchange', function() {
           if (!refreshing) {
@@ -15,16 +54,32 @@ if ('serviceWorker' in navigator) {
           }
         });
         
-        // Handle messages from service worker
-        navigator.serviceWorker.addEventListener('message', function(event) {
-          if (event.data && event.data.type === 'CACHE_UPDATED') {
-            console.log('New content is available; please refresh.');
-            // Here you could show a notification to the user
-          }
-        });
-      })
-      .catch(function(error) {
-        console.error('ServiceWorker registration failed: ', error);
-      });
+        return registration;
+      } catch (err) {
+        console.error('Service worker registration failed:', err);
+        
+        // Try to fallback to custom service worker
+        try {
+          console.log('Attempting to register custom service worker...');
+          const registration = await navigator.serviceWorker.register('/custom-sw.js', {
+            scope: '/'
+          });
+          console.log('Custom service worker registration successful with scope:', registration.scope);
+          return registration;
+        } catch (fallbackErr) {
+          console.error('All service worker registration attempts failed:', fallbackErr);
+          throw fallbackErr;
+        }
+      }
+    };
+    
+    try {
+      await registerServiceWorker();
+      console.log('Service worker registration complete');
+    } catch (err) {
+      console.error('Service worker registration process failed:', err);
+    }
   });
+} else {
+  console.warn('Service workers are not supported by this browser');
 }
diff --git a/src/components/PwaUpdater.jsx b/src/components/PwaUpdater.jsx
index 1890817..6ededec 100644
--- a/src/components/PwaUpdater.jsx
+++ b/src/components/PwaUpdater.jsx
@@ -8,115 +8,114 @@ const PwaUpdater = () => {
   const [needsRefresh, setNeedsRefresh] = useState(false);
   const [swRegistration, setSwRegistration] = useState(null);
 
-  // Register service worker
+  // Monitor service worker updates rather than registering a new one
   useEffect(() => {
-    const registerSW = async () => {
+    const monitorSW = async () => {
       if ('serviceWorker' in navigator) {
         try {
-          // Try to register the service worker
-          const registration = await navigator.serviceWorker.register('/sw.js', {
-            scope: '/'
-          });
+          // Check for existing registrations
+          const registrations = await navigator.serviceWorker.getRegistrations();
           
-          console.log('Service Worker registered with scope:', registration.scope);
-          setSwRegistration(registration);
-          
-          // Handle updates
-          registration.addEventListener('updatefound', () => {
-            const newWorker = registration.installing;
-            console.log('Service Worker update found!');
+          if (registrations.length > 0) {
+            console.log('Found existing service worker registration');
+            const registration = registrations[0];
+            setSwRegistration(registration);
             
-            newWorker.addEventListener('statechange', () => {
-              if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
-                console.log('New content is available, please refresh.');
-                setNeedsRefresh(true);
-              }
-            });
-          });
-          
-          // Set up automatic checks for updates
-          const checkForUpdates = () => {
-            if (registration.update) {
-              registration.update().catch(err => {
-                console.error('Error checking for service worker updates:', err);
+            // Handle updates
+            registration.addEventListener('updatefound', () => {
+              const newWorker = registration.installing;
+              console.log('Service Worker update found!');
+              
+              newWorker.addEventListener('statechange', () => {
+                console.log('Service worker state:', newWorker.state);
+                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
+                  console.log('New content is available, please refresh.');
+                  setNeedsRefresh(true);
+                }
               });
-            }
-          };
-          
-          // Check for updates every hour
-          const updateInterval = setInterval(checkForUpdates, 60 * 60 * 1000);
-          
-          return () => {
-            clearInterval(updateInterval);
-          };
-          
+            });
+            
+            // Set up automatic checks for updates
+            const checkForUpdates = () => {
+              if (registration.update) {
+                console.log('Checking for service worker updates...');
+                registration.update().catch(err => {
+                  console.error('Error checking for service worker updates:', err);
+                });
+              }
+            };
+            
+            // Check for updates immediately and then every hour
+            checkForUpdates();
+            const updateInterval = setInterval(checkForUpdates, 60 * 60 * 1000);
+            
+            return () => {
+              clearInterval(updateInterval);
+            };
+          } else {
+            console.log('No existing service worker registration found');
+          }
         } catch (error) {
-          console.error('Service Worker registration failed:', error);
+          console.error('Error monitoring service worker:', error);
         }
       } else {
-        console.log('Service workers are not supported by this browser');
+        console.warn('Service workers not supported in this browser');
       }
     };
     
-    registerSW();
+    monitorSW();
   }, []);
 
-  // Handle update click
-  const handleUpdate = () => {
+  // Handler for the refresh button
+  const handleRefresh = () => {
     if (swRegistration && swRegistration.waiting) {
-      // Send message to service worker to skip waiting
+      // Send message to waiting service worker to skip waiting and become active
       swRegistration.waiting.postMessage({ type: 'SKIP_WAITING' });
+    } else {
+      // Fallback to regular page refresh
+      window.location.reload();
     }
-    
-    // Reload the page to apply the update
-    window.location.reload();
+    setNeedsRefresh(false);
   };
 
-  if (!needsRefresh) {
-    return null;
-  }
-
   return (
-    <div className="pwa-update-toast">
-      <div className="pwa-update-toast-content">
-        <p>A new version is available!</p>
-        <button onClick={handleUpdate}>Update & Refresh</button>
-        <button onClick={() => setNeedsRefresh(false)}>Dismiss</button>
-      </div>
-      <style jsx>{`
-        .pwa-update-toast {
-          position: fixed;
-          bottom: 20px;
-          right: 20px;
-          z-index: 9999;
-          background-color: #fff;
-          color: #333;
-          padding: 16px;
-          border-radius: 8px;
-          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
-          max-width: 300px;
-        }
-        .pwa-update-toast-content {
-          display: flex;
-          flex-direction: column;
-          gap: 8px;
-        }
-        button {
-          padding: 8px 16px;
-          border: none;
-          border-radius: 4px;
-          cursor: pointer;
-        }
-        button:first-of-type {
-          background-color: #4f46e5;
-          color: white;
-        }
-        button:last-of-type {
-          background-color: transparent;
-          color: #666;
-        }
-      `}</style>
-    </div>
+    <>
+      {needsRefresh && (
+        <div 
+          style={{
+            position: 'fixed',
+            bottom: '24px',
+            left: '24px',
+            right: '24px',
+            padding: '16px',
+            borderRadius: '4px',
+            backgroundColor: '#2563eb',
+            color: 'white',
+            boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1)',
+            display: 'flex',
+            justifyContent: 'space-between',
+            alignItems: 'center',
+            zIndex: 9999
+          }}
+        >
+          <p style={{ margin: 0 }}>New version available! Update to get the latest features.</p>
+          <button
+            onClick={handleRefresh}
+            style={{
+              backgroundColor: 'white',
+              color: '#2563eb',
+              border: 'none',
+              padding: '8px 16px',
+              borderRadius: '4px',
+              fontWeight: 'bold',
+              cursor: 'pointer'
+            }}
+          >
+            Refresh
+          </button>
+        </div>
+      )}
+    </>
   );
 };
 
diff --git a/src/pwa.js b/src/pwa.js
index ad2982a..ffde047 100644
--- a/src/pwa.js
+++ b/src/pwa.js
@@ -51,62 +51,58 @@ export class NetworkStatusMonitor {
     // Create notification element
     const notificationEl = document.createElement('div');
     notificationEl.className = `pwa-notification ${type}`;
-    notificationEl.innerHTML = `
-      <div class="pwa-notification-content">
-        <span>${message}</span>
-        <button class="pwa-notification-close">×</button>
-      </div>
-    `;
+    notificationEl.textContent = message;
+    
+    // Style notification
+    Object.assign(notificationEl.style, {
+      position: 'fixed',
+      top: '20px',
+      right: '20px',
+      padding: '12px 20px',
+      borderRadius: '4px',
+      zIndex: 9999,
+      color: 'white',
+      backgroundColor: type === 'success' ? '#4caf50' : '#ff9800',
+      boxShadow: '0 2px 10px rgba(0,0,0,0.2)',
+      transition: 'all 0.5s ease-in-out'
+    });
     
     // Add to DOM
     document.body.appendChild(notificationEl);
     
-    // Set up close button
-    const closeButton = notificationEl.querySelector('.pwa-notification-close');
-    closeButton.addEventListener('click', () => {
-      notificationEl.remove();
-    });
-    
-    // Auto-remove after 5 seconds
+    // Remove after 3 seconds
     setTimeout(() => {
-      if (document.body.contains(notificationEl)) {
-        notificationEl.remove();
-      }
-    }, 5000);
-  }
-  
-  // Method to register sync function
-  registerSyncFunction(syncFunction) {
-    this.syncPendingData = syncFunction;
+      notificationEl.style.opacity = '0';
+      setTimeout(() => {
+        document.body.removeChild(notificationEl);
+      }, 500);
+    }, 3000);
   }
 }
 
 // Service Worker Management
 export class PWAManager {
   constructor() {
-    this.registerServiceWorker();
+    this.monitorServiceWorker();
   }
   
-  async registerServiceWorker() {
+  async monitorServiceWorker() {
     if ('serviceWorker' in navigator) {
       try {
-        const registration = await navigator.serviceWorker.register('/sw.js', {
-          scope: '/'
-        });
+        // Check for existing registrations first
+        const registrations = await navigator.serviceWorker.getRegistrations();
         
-        if (registration.installing) {
-          console.log('Service worker installing');
-        } else if (registration.waiting) {
-          console.log('Service worker installed');
-        } else if (registration.active) {
-          console.log('Service worker active');
+        if (registrations.length > 0) {
+          console.log('PWAManager: Found existing service worker registration');
+          // Use the existing registration
+          const registration = registrations[0];
+          this.setupPeriodicSync(registration);
+        } else {
+          console.log('PWAManager: No existing service worker found, not registering a new one');
+          // We'll rely on the sw-register.js script to handle registration
         }
-        
-        // Set up update checking
-        this.setupPeriodicSync(registration);
-        
       } catch (error) {
-        console.error('Service worker registration failed:', error);
+        console.error('PWAManager: Error while checking service worker registrations:', error);
       }
     }
   }
@@ -115,7 +111,7 @@ export class PWAManager {
     // Check for updates every hour
     setInterval(() => {
       registration.update();
-      console.log('Checking for service worker updates...');
+      console.log('PWAManager: Checking for service worker updates...');
     }, 60 * 60 * 1000);
     
     // Handle new updates
@@ -141,7 +137,7 @@ export function initializePWA() {
     // Start network status monitoring
     const networkMonitor = new NetworkStatusMonitor();
     
-    // Initialize service worker
+    // Initialize service worker monitoring (but not registration)
     const pwaManager = new PWAManager();
     
     return {
@@ -149,7 +145,6 @@ export function initializePWA() {
       pwaManager
     };
   }
-  return null;
 }
 
 // Default export for easy importing

commit 1d0c613059ed9266dac220cf1c66a3c2cde69d32
Author: Henrykoo <lckoo1230@gmail.com>
Date:   Mon Mar 17 14:06:03 2025 +0800

    new pwa

diff --git a/public/sw-register.js b/public/sw-register.js
new file mode 100644
index 0000000..f2988d1
--- /dev/null
+++ b/public/sw-register.js
@@ -0,0 +1,30 @@
+// Manual Service Worker Registration for PWA
+if ('serviceWorker' in navigator) {
+  window.addEventListener('load', function() {
+    navigator.serviceWorker.register('/sw.js')
+      .then(function(registration) {
+        console.log('ServiceWorker registration successful with scope: ', registration.scope);
+        
+        // Listen for new worker activation
+        let refreshing = false;
+        navigator.serviceWorker.addEventListener('controllerchange', function() {
+          if (!refreshing) {
+            console.log('New service worker activated, reloading page for fresh content...');
+            refreshing = true;
+            window.location.reload();
+          }
+        });
+        
+        // Handle messages from service worker
+        navigator.serviceWorker.addEventListener('message', function(event) {
+          if (event.data && event.data.type === 'CACHE_UPDATED') {
+            console.log('New content is available; please refresh.');
+            // Here you could show a notification to the user
+          }
+        });
+      })
+      .catch(function(error) {
+        console.error('ServiceWorker registration failed: ', error);
+      });
+  });
+}
diff --git a/src/components/InstallPwa.jsx b/src/components/InstallPwa.jsx
index f0e4da5..5bac604 100644
--- a/src/components/InstallPwa.jsx
+++ b/src/components/InstallPwa.jsx
@@ -1,90 +1,195 @@
-// src/components/InstallPwa.jsx
 import React, { useState, useEffect } from 'react';
 
-/**
- * Component that shows an installation prompt for the PWA
- * when the app can be installed on the device.
- */
 const InstallPwa = () => {
   const [installPrompt, setInstallPrompt] = useState(null);
-  const [showInstallBanner, setShowInstallBanner] = useState(false);
+  const [showInstallButton, setShowInstallButton] = useState(false);
+  const [isIos, setIsIos] = useState(false);
 
   useEffect(() => {
-    // Store the beforeinstallprompt event so it can be triggered later
-    const handleBeforeInstallPrompt = (event) => {
-      // Prevent the default browser install prompt
-      event.preventDefault();
+    // Check if on iOS
+    const checkIos = () => {
+      const ua = window.navigator.userAgent;
+      const iOS = !!ua.match(/iPad/i) || !!ua.match(/iPhone/i);
+      const webkit = !!ua.match(/WebKit/i);
+      const iOSSafari = iOS && webkit && !ua.match(/CriOS/i) && !ua.match(/OPiOS/i) && !ua.match(/FxiOS/i);
+      
+      setIsIos(iOSSafari);
+    };
+
+    // Listen for beforeinstallprompt event
+    const handleBeforeInstallPrompt = (e) => {
+      // Prevent the mini-infobar from appearing on mobile
+      e.preventDefault();
       // Store the event for later use
-      setInstallPrompt(event);
-      // Show our custom install banner
-      setShowInstallBanner(true);
+      setInstallPrompt(e);
+      // Show the install button
+      setShowInstallButton(true);
+      
+      console.log('BeforeInstallPrompt event fired and captured');
     };
 
-    // Add event listener for the beforeinstallprompt event
-    window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
+    // Check if already installed
+    const checkIfInstalled = () => {
+      if (window.matchMedia('(display-mode: standalone)').matches || 
+          window.navigator.standalone === true) {
+        console.log('App is already installed');
+        setShowInstallButton(false);
+      }
+    };
+
+    checkIos();
+    checkIfInstalled();
 
-    // Add event listener for the appinstalled event
-    window.addEventListener('appinstalled', () => {
-      // Hide the install banner after the app is installed
-      setShowInstallBanner(false);
-      setInstallPrompt(null);
-      // Log the installation to analytics
-      console.log('PWA was installed');
-    });
+    // Add event listener for beforeinstallprompt
+    window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
 
-    // Clean up event listeners on component unmount
+    // Clean up
     return () => {
       window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
-      window.removeEventListener('appinstalled', () => {
-        setShowInstallBanner(false);
-      });
     };
   }, []);
 
+  // Handle install button click
   const handleInstallClick = async () => {
-    if (!installPrompt) return;
-    
-    // Show the browser's install prompt
+    if (!installPrompt) {
+      console.log('No installation prompt available');
+      return;
+    }
+
+    // Show the prompt
     installPrompt.prompt();
     
     // Wait for the user to respond to the prompt
     const { outcome } = await installPrompt.userChoice;
-    
-    // Optionally, send analytics about the outcome
     console.log(`User response to the install prompt: ${outcome}`);
     
-    // Clear the saved prompt since it can't be used again
+    // We no longer need the prompt, clear it
     setInstallPrompt(null);
-    setShowInstallBanner(false);
+    setShowInstallButton(false);
   };
 
-  // Don't show anything if there's no install prompt available
-  if (!showInstallBanner) {
+  // If running in standalone mode or no install prompt, don't show anything
+  if (!showInstallButton && !isIos) {
     return null;
   }
 
   return (
-    <div className="fixed bottom-0 left-0 right-0 p-4 bg-white border-t border-gray-200 shadow-lg z-50 mb-12">
-      <div className="flex items-center justify-between">
-        <div>
-          <p className="font-medium">Install this app on your device</p>
-          <p className="text-sm text-gray-600">For easier access and offline use</p>
+    <div className="install-pwa-prompt">
+      <div className="install-pwa-content">
+        <div className="install-pwa-header">
+          <img 
+            src="/pwa-192x192.png" 
+            alt="App Icon" 
+            className="install-pwa-icon" 
+          />
+          <div className="install-pwa-text">
+            <h3>Install Redux Todo App</h3>
+            <p>Get quick access and work offline</p>
+          </div>
         </div>
-        <div className="flex space-x-2">
-          <button
-            onClick={() => setShowInstallBanner(false)}
-            className="px-4 py-2 text-sm text-gray-600 border border-gray-300 rounded-md hover:bg-gray-100 transition-colors"
-          >
-            Not now
+        
+        {isIos ? (
+          <div className="ios-instructions">
+            <p>To install this app on your iOS device:</p>
+            <ol>
+              <li>Tap the share icon <span className="share-icon">⎅</span> at the bottom of the screen</li>
+              <li>Scroll and tap "Add to Home Screen"</li>
+              <li>Tap "Add" in the top right</li>
+            </ol>
+          </div>
+        ) : (
+          <button onClick={handleInstallClick} className="install-button">
+            Install App
           </button>
-          <button
-            onClick={handleInstallClick}
-            className="px-4 py-2 text-sm text-white bg-purple-600 rounded-md hover:bg-purple-700 transition-colors"
-          >
-            Install
-          </button>
-        </div>
+        )}
+        
+        <button 
+          onClick={() => setShowInstallButton(false)} 
+          className="dismiss-button"
+        >
+          Not now
+        </button>
       </div>
+      
+      <style jsx>{`
+        .install-pwa-prompt {
+          position: fixed;
+          bottom: 20px;
+          left: 20px;
+          background-color: white;
+          border-radius: 8px;
+          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
+          padding: 16px;
+          max-width: 350px;
+          z-index: 1000;
+        }
+        
+        .install-pwa-content {
+          display: flex;
+          flex-direction: column;
+          gap: 16px;
+        }
+        
+        .install-pwa-header {
+          display: flex;
+          align-items: center;
+          gap: 12px;
+        }
+        
+        .install-pwa-icon {
+          width: 40px;
+          height: 40px;
+          border-radius: 8px;
+        }
+        
+        .install-pwa-text h3 {
+          margin: 0;
+          font-size: 16px;
+          font-weight: 600;
+        }
+        
+        .install-pwa-text p {
+          margin: 4px 0 0 0;
+          font-size: 14px;
+          color: #666;
+        }
+        
+        .ios-instructions {
+          font-size: 14px;
+          background-color: #f5f5f5;
+          padding: 12px;
+          border-radius: 6px;
+        }
+        
+        .ios-instructions ol {
+          margin: 8px 0 0 20px;
+          padding: 0;
+        }
+        
+        .share-icon {
+          font-size: 18px;
+        }
+        
+        .install-button {
+          background-color: #4f46e5;
+          color: white;
+          border: none;
+          border-radius: 6px;
+          padding: 10px;
+          font-weight: 500;
+          cursor: pointer;
+        }
+        
+        .dismiss-button {
+          background-color: transparent;
+          border: none;
+          color: #666;
+          padding: 8px;
+          cursor: pointer;
+          align-self: center;
+          font-size: 14px;
+        }
+      `}</style>
     </div>
   );
 };
diff --git a/src/components/PwaUpdater.jsx b/src/components/PwaUpdater.jsx
index 3f3fa56..1890817 100644
--- a/src/components/PwaUpdater.jsx
+++ b/src/components/PwaUpdater.jsx
@@ -1,4 +1,3 @@
-// src/components/PwaUpdater.jsx
 import React, { useState, useEffect } from 'react';
 
 /**
@@ -7,28 +6,68 @@ import React, { useState, useEffect } from 'react';
  */
 const PwaUpdater = () => {
   const [needsRefresh, setNeedsRefresh] = useState(false);
+  const [swRegistration, setSwRegistration] = useState(null);
 
+  // Register service worker
   useEffect(() => {
-    // Check if service worker is supported
-    if ('serviceWorker' in navigator) {
-      // Listen for the controllerchange event on the navigator.serviceWorker
-      // This event fires when a new service worker has taken control
-      navigator.serviceWorker.addEventListener('controllerchange', () => {
-        // If we have a new service worker, we need to refresh
-        if (needsRefresh === false) {
-          setNeedsRefresh(true);
+    const registerSW = async () => {
+      if ('serviceWorker' in navigator) {
+        try {
+          // Try to register the service worker
+          const registration = await navigator.serviceWorker.register('/sw.js', {
+            scope: '/'
+          });
+          
+          console.log('Service Worker registered with scope:', registration.scope);
+          setSwRegistration(registration);
+          
+          // Handle updates
+          registration.addEventListener('updatefound', () => {
+            const newWorker = registration.installing;
+            console.log('Service Worker update found!');
+            
+            newWorker.addEventListener('statechange', () => {
+              if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
+                console.log('New content is available, please refresh.');
+                setNeedsRefresh(true);
+              }
+            });
+          });
+          
+          // Set up automatic checks for updates
+          const checkForUpdates = () => {
+            if (registration.update) {
+              registration.update().catch(err => {
+                console.error('Error checking for service worker updates:', err);
+              });
+            }
+          };
+          
+          // Check for updates every hour
+          const updateInterval = setInterval(checkForUpdates, 60 * 60 * 1000);
+          
+          return () => {
+            clearInterval(updateInterval);
+          };
+          
+        } catch (error) {
+          console.error('Service Worker registration failed:', error);
         }
-      });
-
-      // Listen for the custom updatefound event from the PWA plugin
-      window.addEventListener('updatefound', () => {
-        setNeedsRefresh(true);
-      });
-    }
-  }, [needsRefresh]);
+      } else {
+        console.log('Service workers are not supported by this browser');
+      }
+    };
+    
+    registerSW();
+  }, []);
 
+  // Handle update click
   const handleUpdate = () => {
-    setNeedsRefresh(false);
+    if (swRegistration && swRegistration.waiting) {
+      // Send message to service worker to skip waiting
+      swRegistration.waiting.postMessage({ type: 'SKIP_WAITING' });
+    }
+    
     // Reload the page to apply the update
     window.location.reload();
   };
@@ -38,16 +77,45 @@ const PwaUpdater = () => {
   }
 
   return (
-    <div className="fixed bottom-0 left-0 right-0 p-4 bg-white border-t border-gray-200 shadow-lg z-50">
-      <div className="flex items-center justify-between">
-        <p className="font-medium">A new version of this app is available!</p>
-        <button
-          onClick={handleUpdate}
-          className="px-4 py-2 text-sm text-white bg-purple-600 rounded-md hover:bg-purple-700 transition-colors"
-        >
-          Update Now
-        </button>
+    <div className="pwa-update-toast">
+      <div className="pwa-update-toast-content">
+        <p>A new version is available!</p>
+        <button onClick={handleUpdate}>Update & Refresh</button>
+        <button onClick={() => setNeedsRefresh(false)}>Dismiss</button>
       </div>
+      <style jsx>{`
+        .pwa-update-toast {
+          position: fixed;
+          bottom: 20px;
+          right: 20px;
+          z-index: 9999;
+          background-color: #fff;
+          color: #333;
+          padding: 16px;
+          border-radius: 8px;
+          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
+          max-width: 300px;
+        }
+        .pwa-update-toast-content {
+          display: flex;
+          flex-direction: column;
+          gap: 8px;
+        }
+        button {
+          padding: 8px 16px;
+          border: none;
+          border-radius: 4px;
+          cursor: pointer;
+        }
+        button:first-of-type {
+          background-color: #4f46e5;
+          color: white;
+        }
+        button:last-of-type {
+          background-color: transparent;
+          color: #666;
+        }
+      `}</style>
     </div>
   );
 };
diff --git a/src/layouts/BaseLayout.astro b/src/layouts/BaseLayout.astro
index caa46b9..785c196 100644
--- a/src/layouts/BaseLayout.astro
+++ b/src/layouts/BaseLayout.astro
@@ -17,8 +17,8 @@ const { title } = Astro.props;
 		<link rel="icon" href="/favicon.svg" type="image/svg+xml" />
 		<link rel="apple-touch-icon" href="/pwa-192x192.png" />
 		<link rel="manifest" href="/manifest.webmanifest" />
-		<!-- PWA Script -->
-		<script src="../pwa.js"></script>
+		<!-- Manual Service Worker Registration -->
+		<script is:inline src="/sw-register.js"></script>
 	</head>   
 	<body class="bg-background text-foreground">     
 		<slot />
@@ -27,4 +27,18 @@ const { title } = Astro.props;
 		<!-- PWA install prompt component -->
 		<InstallPwa client:only="react" />
 	</body> 
-</html>
\ No newline at end of file
+</html>
+
+<script>
+	// Import and initialize PWA functionality
+	import { initializePWA } from '../pwa.js';
+	
+	// Only run in browser, not during SSR
+	if (typeof window !== 'undefined') {
+		// Initialize when the page is fully loaded
+		window.addEventListener('load', () => {
+			const pwa = initializePWA();
+			console.log('PWA initialized successfully', pwa);
+		});
+	}
+</script>
\ No newline at end of file
diff --git a/src/pwa.js b/src/pwa.js
index c930742..ad2982a 100644
--- a/src/pwa.js
+++ b/src/pwa.js
@@ -4,7 +4,7 @@
 console.log('PWA initialization');
 
 // NetworkStatus monitor to handle online/offline events
-class NetworkStatusMonitor {
+export class NetworkStatusMonitor {
   constructor() {
     this.isOnline = navigator.onLine;
     
@@ -49,39 +49,29 @@ class NetworkStatusMonitor {
   
   showNotification(message, type) {
     // Create notification element
-    const notification = document.createElement('div');
-    notification.className = `pwa-notification ${type}`;
-    notification.textContent = message;
+    const notificationEl = document.createElement('div');
+    notificationEl.className = `pwa-notification ${type}`;
+    notificationEl.innerHTML = `
+      <div class="pwa-notification-content">
+        <span>${message}</span>
+        <button class="pwa-notification-close">×</button>
+      </div>
+    `;
     
-    // Style the notification
-    Object.assign(notification.style, {
-      position: 'fixed',
-      top: '20px',
-      right: '20px',
-      padding: '12px 16px',
-      backgroundColor: type === 'success' ? '#4CAF50' : '#FF9800',
-      color: 'white',
-      borderRadius: '4px',
-      boxShadow: '0 2px 4px rgba(0,0,0,0.2)',
-      zIndex: '9999',
-      opacity: '0',
-      transition: 'opacity 0.3s ease'
-    });
-    
-    // Add to document
-    document.body.appendChild(notification);
+    // Add to DOM
+    document.body.appendChild(notificationEl);
     
-    // Trigger animation
-    setTimeout(() => {
-      notification.style.opacity = '1';
-    }, 10);
+    // Set up close button
+    const closeButton = notificationEl.querySelector('.pwa-notification-close');
+    closeButton.addEventListener('click', () => {
+      notificationEl.remove();
+    });
     
-    // Remove after 5 seconds
+    // Auto-remove after 5 seconds
     setTimeout(() => {
-      notification.style.opacity = '0';
-      setTimeout(() => {
-        document.body.removeChild(notification);
-      }, 300);
+      if (document.body.contains(notificationEl)) {
+        notificationEl.remove();
+      }
     }, 5000);
   }
   
@@ -92,7 +82,7 @@ class NetworkStatusMonitor {
 }
 
 // Service Worker Management
-class PWAManager {
+export class PWAManager {
   constructor() {
     this.registerServiceWorker();
   }
@@ -146,14 +136,21 @@ class PWAManager {
 }
 
 // Initialize the PWA components
-if (typeof window !== 'undefined') {
-  // Start network status monitoring
-  const networkMonitor = new NetworkStatusMonitor();
-  
-  // Register service worker
-  const pwaManager = new PWAManager();
-  
-  // Make them available globally
-  window.networkMonitor = networkMonitor;
-  window.pwaManager = pwaManager;
+export function initializePWA() {
+  if (typeof window !== 'undefined') {
+    // Start network status monitoring
+    const networkMonitor = new NetworkStatusMonitor();
+    
+    // Initialize service worker
+    const pwaManager = new PWAManager();
+    
+    return {
+      networkMonitor,
+      pwaManager
+    };
+  }
+  return null;
 }
+
+// Default export for easy importing
+export default initializePWA;

commit f663a45b32fe2d7f4407e15591b41a33604eec73
Author: Henrykoo <lckoo1230@gmail.com>
Date:   Mon Mar 17 11:32:56 2025 +0800

    setting up pwa

diff --git a/PWA-README.md b/PWA-README.md
new file mode 100644
index 0000000..4ae5f9e
--- /dev/null
+++ b/PWA-README.md
@@ -0,0 +1,73 @@
+# Progressive Web App (PWA) Implementation Guide
+
+This document outlines how the PWA features are implemented in this Astro project.
+
+## PWA Architecture
+
+The PWA implementation consists of the following key components:
+
+1. **Vite PWA Plugin for Astro**: Handles service worker generation and asset caching
+2. **Web App Manifest**: Defines how the app appears when installed on a device
+3. **PWA Icons**: Various sizes for different device requirements
+4. **Offline Page**: Fallback when the user is offline
+5. **Update Notification**: Component that notifies users when an app update is available
+6. **Install Prompt**: Component that provides a custom install experience
+7. **Network Status Monitoring**: Handles online/offline transitions
+
+## Key Files
+
+- `astro.config.mjs`: PWA configuration using @vite-pwa/astro
+- `public/manifest.webmanifest`: Web app manifest file
+- `public/pwa-*.png`: PWA icons in different sizes
+- `src/pwa.js`: Main PWA initialization script
+- `src/pages/offline.astro`: Offline fallback page
+- `src/components/PwaUpdater.jsx`: Update notification component
+- `src/components/InstallPwa.jsx`: Install prompt component
+
+## Caching Strategy
+
+The application uses a combined caching strategy:
+
+- **Navigation routes**: Fall back to the offline page when offline
+- **Static assets**: Cache-first strategy for app assets
+- **Google Fonts**: Cache-first with 1-year expiration
+- **API responses**: Network-first with fallback to cache (configured in service worker)
+
+## How to Test PWA Features
+
+1. **Install Testing**:
+   - Open Chrome DevTools
+   - Go to Application > Manifest to see if it's properly set up
+   - Use the "Add to home screen" option to test installation
+
+2. **Offline Testing**:
+   - In Chrome DevTools, go to Network tab
+   - Check "Offline" checkbox
+   - Refresh the page to see the offline experience
+
+3. **Update Testing**:
+   - Make changes to the codebase
+   - Run a new build
+   - The update notification should appear when you refresh the page
+
+## Customization
+
+To customize the PWA behavior:
+
+1. **Icons**: Replace the `pwa-*.png` files in the `public` directory with your own icons
+2. **Manifest**: Edit `public/manifest.webmanifest` to change app name, colors, etc.
+3. **Caching**: Modify the `workbox` section in `astro.config.mjs` to adjust caching behavior
+4. **Offline Experience**: Modify `src/pages/offline.astro` to change the offline page
+
+## Common Issues and Solutions
+
+- **Service worker not updating**: Try clearing the Application > Storage in Chrome DevTools
+- **Install banner not showing**: Make sure your app meets the [installability criteria](https://web.dev/install-criteria/)
+- **Assets not caching properly**: Check the caching configuration in `astro.config.mjs`
+
+## Resources
+
+- [Vite PWA Plugin Documentation](https://vite-pwa-org.netlify.app/frameworks/astro.html)
+- [Workbox Documentation](https://developers.google.com/web/tools/workbox)
+- [Web App Manifest Documentation](https://developer.mozilla.org/en-US/docs/Web/Manifest)
+- [PWA Checklist by Google](https://web.dev/pwa-checklist/)
diff --git a/astro.config.mjs b/astro.config.mjs
index e121606..dd7e18f 100644
--- a/astro.config.mjs
+++ b/astro.config.mjs
@@ -2,10 +2,76 @@
 import { defineConfig } from 'astro/config';
 import react from '@astrojs/react';
 import path from 'path';
+import AstroPWA from '@vite-pwa/astro';
 
 // https://astro.build/config
 export default defineConfig({
-  integrations: [react()],
+  integrations: [
+    react(),
+    AstroPWA({
+      registerType: 'autoUpdate',
+      manifest: {
+        name: 'Redux Todo in Astro',
+        short_name: 'Redux Todo',
+        description: 'A Todo application built with Astro and Redux',
+        theme_color: '#ffffff',
+        background_color: '#ffffff',
+        display: 'standalone',
+        icons: [
+          {
+            src: 'pwa-192x192.png',
+            sizes: '192x192',
+            type: 'image/png',
+          },
+          {
+            src: 'pwa-512x512.png',
+            sizes: '512x512',
+            type: 'image/png',
+          },
+          {
+            src: 'pwa-512x512.png',
+            sizes: '512x512',
+            type: 'image/png',
+            purpose: 'maskable',
+          }
+        ]
+      },
+      workbox: {
+        // Use navigation fallback to the offline page
+        navigateFallback: '/offline',
+        globPatterns: ['**/*.{js,css,html,svg,png,ico,jpg,jpeg}'],
+        // Customize caching strategies for different resources
+        runtimeCaching: [
+          {
+            urlPattern: /^https:\/\/fonts\.googleapis\.com\/.*/i,
+            handler: 'CacheFirst',
+            options: {
+              cacheName: 'google-fonts-cache',
+              expiration: {
+                maxEntries: 10,
+                maxAgeSeconds: 60 * 60 * 24 * 365 // 1 year
+              }
+            }
+          },
+          {
+            urlPattern: /^https:\/\/fonts\.gstatic\.com\/.*/i,
+            handler: 'CacheFirst',
+            options: {
+              cacheName: 'gstatic-fonts-cache',
+              expiration: {
+                maxEntries: 10,
+                maxAgeSeconds: 60 * 60 * 24 * 365 // 1 year
+              }
+            }
+          }
+        ]
+      },
+      devOptions: {
+        enabled: true,
+        type: 'module',
+      },
+    }),
+  ],
   vite: {
     resolve: {
       alias: {
diff --git a/package.json b/package.json
index 284f2cc..754aee9 100644
--- a/package.json
+++ b/package.json
@@ -4,11 +4,12 @@
   "version": "0.0.1",
   "scripts": {
     "dev": "astro dev",
-    "build": "astro build",
+    "build": "npm run generate-pwa-icons && astro build",
     "serve": "astro serve",
     "preview": "astro preview",
     "astro": "astro",
-    "test": "jest"
+    "test": "jest",
+    "generate-pwa-icons": "node scripts/generate-pwa-icons.js"
   },
   "dependencies": {
     "@astrojs/react": "latest",
@@ -36,6 +37,7 @@
     "@babel/preset-react": "^7.26.3",
     "@typescript-eslint/eslint-plugin": "^8.26.0",
     "@typescript-eslint/parser": "^8.26.0",
+    "@vite-pwa/astro": "^0.2.0",
     "autoprefixer": "^10.4.20",
     "babel-jest": "^29.7.0",
     "eslint": "^9.21.0",
diff --git a/public/manifest.webmanifest b/public/manifest.webmanifest
new file mode 100644
index 0000000..1030db3
--- /dev/null
+++ b/public/manifest.webmanifest
@@ -0,0 +1,28 @@
+{
+  "name": "Redux Todo in Astro",
+  "short_name": "Redux Todo",
+  "description": "A Todo application built with Astro and Redux",
+  "theme_color": "#ffffff",
+  "background_color": "#ffffff",
+  "display": "standalone",
+  "start_url": "/",
+  "scope": "/",
+  "icons": [
+    {
+      "src": "/pwa-192x192.png",
+      "sizes": "192x192",
+      "type": "image/png"
+    },
+    {
+      "src": "/pwa-512x512.png",
+      "sizes": "512x512",
+      "type": "image/png"
+    },
+    {
+      "src": "/pwa-512x512.png",
+      "sizes": "512x512",
+      "type": "image/png",
+      "purpose": "maskable"
+    }
+  ]
+}
diff --git a/public/pwa-192x192.png b/public/pwa-192x192.png
new file mode 100644
index 0000000..7dbfee8
--- /dev/null
+++ b/public/pwa-192x192.png
@@ -0,0 +1 @@
+This is a placeholder for a proper PNG image
\ No newline at end of file
diff --git a/public/pwa-512x512.png b/public/pwa-512x512.png
new file mode 100644
index 0000000..7dbfee8
--- /dev/null
+++ b/public/pwa-512x512.png
@@ -0,0 +1 @@
+This is a placeholder for a proper PNG image
\ No newline at end of file
diff --git a/public/pwa-icons.svg b/public/pwa-icons.svg
new file mode 100644
index 0000000..9469289
--- /dev/null
+++ b/public/pwa-icons.svg
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<svg width="512" height="512" viewBox="0 0 512 512" version="1.1" xmlns="http://www.w3.org/2000/svg">
+  <rect x="0" y="0" width="512" height="512" fill="#764ABC" />
+  <path fill="#FFFFFF" d="M341.47,256c0,47.53-38.53,86.07-86.07,86.07s-86.07-38.53-86.07-86.07s38.53-86.07,86.07-86.07
+  S341.47,208.47,341.47,256z M256,213.33c-23.56,0-42.67,19.1-42.67,42.67c0,23.56,19.1,42.67,42.67,42.67
+  c23.56,0,42.67-19.1,42.67-42.67C298.67,232.43,279.56,213.33,256,213.33z M128,138.67h256v234.67H128V138.67z"/>
+</svg>
diff --git a/scripts/generate-pwa-icons.js b/scripts/generate-pwa-icons.js
new file mode 100644
index 0000000..e3c8ba2
--- /dev/null
+++ b/scripts/generate-pwa-icons.js
@@ -0,0 +1,51 @@
+// scripts/generate-pwa-icons.js
+import { promises as fs } from 'fs';
+import path from 'path';
+import { fileURLToPath } from 'url';
+
+// Since we're using ES modules
+const __dirname = path.dirname(fileURLToPath(import.meta.url));
+const publicDir = path.resolve(__dirname, '../public');
+
+/**
+ * This is a simplistic placeholder implementation.
+ * In a real project, you would use a proper image processing library
+ * like Sharp to convert the SVG to PNG files of different sizes.
+ * 
+ * For now, we'll just create empty files as placeholders.
+ */
+async function generateIcons() {
+  try {
+    // Create a simple implementation - in a real project you would use a library like sharp
+    // to properly resize and convert images
+    
+    // Get SVG content
+    const svgContent = await fs.readFile(path.join(publicDir, 'pwa-icons.svg'), 'utf-8');
+    
+    // Create PNG files (this is just a placeholder - they would be blank files)
+    // In a real project, use sharp or another image processing library
+    console.log('Creating PWA icon files...');
+    
+    const iconSizes = [
+      { size: 192, name: 'pwa-192x192.png' },
+      { size: 512, name: 'pwa-512x512.png' },
+    ];
+    
+    // Create blank PNG files as placeholders
+    // Note: These won't be real images, just empty placeholders
+    for (const icon of iconSizes) {
+      const outputPath = path.join(publicDir, icon.name);
+      
+      // Create an empty file as a placeholder
+      // In a real project, you would convert the SVG to a proper PNG here
+      await fs.writeFile(outputPath, 'This is a placeholder for a proper PNG image');
+      console.log(`Created placeholder for ${icon.name}`);
+    }
+    
+    console.log('PWA icons created successfully!');
+  } catch (error) {
+    console.error('Error generating PWA icons:', error);
+  }
+}
+
+generateIcons();
diff --git a/src/components/InstallPwa.jsx b/src/components/InstallPwa.jsx
new file mode 100644
index 0000000..f0e4da5
--- /dev/null
+++ b/src/components/InstallPwa.jsx
@@ -0,0 +1,92 @@
+// src/components/InstallPwa.jsx
+import React, { useState, useEffect } from 'react';
+
+/**
+ * Component that shows an installation prompt for the PWA
+ * when the app can be installed on the device.
+ */
+const InstallPwa = () => {
+  const [installPrompt, setInstallPrompt] = useState(null);
+  const [showInstallBanner, setShowInstallBanner] = useState(false);
+
+  useEffect(() => {
+    // Store the beforeinstallprompt event so it can be triggered later
+    const handleBeforeInstallPrompt = (event) => {
+      // Prevent the default browser install prompt
+      event.preventDefault();
+      // Store the event for later use
+      setInstallPrompt(event);
+      // Show our custom install banner
+      setShowInstallBanner(true);
+    };
+
+    // Add event listener for the beforeinstallprompt event
+    window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
+
+    // Add event listener for the appinstalled event
+    window.addEventListener('appinstalled', () => {
+      // Hide the install banner after the app is installed
+      setShowInstallBanner(false);
+      setInstallPrompt(null);
+      // Log the installation to analytics
+      console.log('PWA was installed');
+    });
+
+    // Clean up event listeners on component unmount
+    return () => {
+      window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
+      window.removeEventListener('appinstalled', () => {
+        setShowInstallBanner(false);
+      });
+    };
+  }, []);
+
+  const handleInstallClick = async () => {
+    if (!installPrompt) return;
+    
+    // Show the browser's install prompt
+    installPrompt.prompt();
+    
+    // Wait for the user to respond to the prompt
+    const { outcome } = await installPrompt.userChoice;
+    
+    // Optionally, send analytics about the outcome
+    console.log(`User response to the install prompt: ${outcome}`);
+    
+    // Clear the saved prompt since it can't be used again
+    setInstallPrompt(null);
+    setShowInstallBanner(false);
+  };
+
+  // Don't show anything if there's no install prompt available
+  if (!showInstallBanner) {
+    return null;
+  }
+
+  return (
+    <div className="fixed bottom-0 left-0 right-0 p-4 bg-white border-t border-gray-200 shadow-lg z-50 mb-12">
+      <div className="flex items-center justify-between">
+        <div>
+          <p className="font-medium">Install this app on your device</p>
+          <p className="text-sm text-gray-600">For easier access and offline use</p>
+        </div>
+        <div className="flex space-x-2">
+          <button
+            onClick={() => setShowInstallBanner(false)}
+            className="px-4 py-2 text-sm text-gray-600 border border-gray-300 rounded-md hover:bg-gray-100 transition-colors"
+          >
+            Not now
+          </button>
+          <button
+            onClick={handleInstallClick}
+            className="px-4 py-2 text-sm text-white bg-purple-600 rounded-md hover:bg-purple-700 transition-colors"
+          >
+            Install
+          </button>
+        </div>
+      </div>
+    </div>
+  );
+};
+
+export default InstallPwa;
diff --git a/src/components/PwaUpdater.jsx b/src/components/PwaUpdater.jsx
new file mode 100644
index 0000000..3f3fa56
--- /dev/null
+++ b/src/components/PwaUpdater.jsx
@@ -0,0 +1,55 @@
+// src/components/PwaUpdater.jsx
+import React, { useState, useEffect } from 'react';
+
+/**
+ * Component that shows a notification when a new version of the app is available
+ * and provides a button to reload and update to the latest version.
+ */
+const PwaUpdater = () => {
+  const [needsRefresh, setNeedsRefresh] = useState(false);
+
+  useEffect(() => {
+    // Check if service worker is supported
+    if ('serviceWorker' in navigator) {
+      // Listen for the controllerchange event on the navigator.serviceWorker
+      // This event fires when a new service worker has taken control
+      navigator.serviceWorker.addEventListener('controllerchange', () => {
+        // If we have a new service worker, we need to refresh
+        if (needsRefresh === false) {
+          setNeedsRefresh(true);
+        }
+      });
+
+      // Listen for the custom updatefound event from the PWA plugin
+      window.addEventListener('updatefound', () => {
+        setNeedsRefresh(true);
+      });
+    }
+  }, [needsRefresh]);
+
+  const handleUpdate = () => {
+    setNeedsRefresh(false);
+    // Reload the page to apply the update
+    window.location.reload();
+  };
+
+  if (!needsRefresh) {
+    return null;
+  }
+
+  return (
+    <div className="fixed bottom-0 left-0 right-0 p-4 bg-white border-t border-gray-200 shadow-lg z-50">
+      <div className="flex items-center justify-between">
+        <p className="font-medium">A new version of this app is available!</p>
+        <button
+          onClick={handleUpdate}
+          className="px-4 py-2 text-sm text-white bg-purple-600 rounded-md hover:bg-purple-700 transition-colors"
+        >
+          Update Now
+        </button>
+      </div>
+    </div>
+  );
+};
+
+export default PwaUpdater;
diff --git a/src/layouts/BaseLayout.astro b/src/layouts/BaseLayout.astro
index e3a406b..caa46b9 100644
--- a/src/layouts/BaseLayout.astro
+++ b/src/layouts/BaseLayout.astro
@@ -1,6 +1,8 @@
 ---
 // src/layouts/BaseLayout.astro 
 import '../styles/global.css';
+import PwaUpdater from '../components/PwaUpdater.jsx';
+import InstallPwa from '../components/InstallPwa.jsx';
 
 const { title } = Astro.props; 
 ---  
@@ -9,8 +11,20 @@ const { title } = Astro.props;
 		<meta charset="utf-8" />
 		<meta name="viewport" content="width=device-width, initial-scale=1" />
 		<title>{title}</title>
+		<!-- PWA Meta Tags -->
+		<meta name="description" content="A Todo application built with Astro and Redux" />
+		<meta name="theme-color" content="#ffffff" />
+		<link rel="icon" href="/favicon.svg" type="image/svg+xml" />
+		<link rel="apple-touch-icon" href="/pwa-192x192.png" />
+		<link rel="manifest" href="/manifest.webmanifest" />
+		<!-- PWA Script -->
+		<script src="../pwa.js"></script>
 	</head>   
 	<body class="bg-background text-foreground">     
-		<slot />     
+		<slot />
+		<!-- PWA update notification component -->
+		<PwaUpdater client:only="react" />
+		<!-- PWA install prompt component -->
+		<InstallPwa client:only="react" />
 	</body> 
 </html>
\ No newline at end of file
diff --git a/src/pages/offline.astro b/src/pages/offline.astro
new file mode 100644
index 0000000..3a8412a
--- /dev/null
+++ b/src/pages/offline.astro
@@ -0,0 +1,24 @@
+---
+import BaseLayout from '../layouts/BaseLayout.astro';
+---
+
+<BaseLayout title="You are offline">
+  <div class="flex flex-col items-center justify-center min-h-screen p-4 text-center">
+    <h1 class="text-4xl font-bold mb-4">You are offline</h1>
+    <p class="text-xl mb-8">Please check your internet connection and try again.</p>
+    <div class="p-4 bg-gray-100 rounded-lg">
+      <p>Some features of this app are available offline. You can still:</p>
+      <ul class="list-disc mt-2 ml-6 text-left">
+        <li>View previously loaded todos</li>
+        <li>Add new todos (they will sync when you're back online)</li>
+        <li>Mark todos as complete</li>
+      </ul>
+    </div>
+    <button 
+      class="mt-8 px-6 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700 transition-colors"
+      onclick="window.location.href='/'"
+    >
+      Try again
+    </button>
+  </div>
+</BaseLayout>
diff --git a/src/pwa.js b/src/pwa.js
new file mode 100644
index 0000000..c930742
--- /dev/null
+++ b/src/pwa.js
@@ -0,0 +1,159 @@
+// src/pwa.js
+// Enhanced PWA initialization and management
+
+console.log('PWA initialization');
+
+// NetworkStatus monitor to handle online/offline events
+class NetworkStatusMonitor {
+  constructor() {
+    this.isOnline = navigator.onLine;
+    
+    // Set up event listeners for online/offline events
+    window.addEventListener('online', this.handleOnline.bind(this));
+    window.addEventListener('offline', this.handleOffline.bind(this));
+    
+    // Initial status check
+    this.checkNetworkStatus();
+  }
+  
+  handleOnline() {
+    console.log('App is online');
+    this.isOnline = true;
+    
+    // Display notification
+    this.showNotification('You are back online!', 'success');
+    
+    // Attempt to sync any pending data
+    if (this.syncPendingData) {
+      this.syncPendingData();
+    }
+  }
+  
+  handleOffline() {
+    console.log('App is offline');
+    this.isOnline = false;
+    
+    // Display notification
+    this.showNotification('You are offline. Some features may be limited.', 'warning');
+  }
+  
+  checkNetworkStatus() {
+    this.isOnline = navigator.onLine;
+    console.log(`Initial network status: ${this.isOnline ? 'online' : 'offline'}`);
+    
+    // If offline on page load, show notification
+    if (!this.isOnline) {
+      this.showNotification('You are offline. Some features may be limited.', 'warning');
+    }
+  }
+  
+  showNotification(message, type) {
+    // Create notification element
+    const notification = document.createElement('div');
+    notification.className = `pwa-notification ${type}`;
+    notification.textContent = message;
+    
+    // Style the notification
+    Object.assign(notification.style, {
+      position: 'fixed',
+      top: '20px',
+      right: '20px',
+      padding: '12px 16px',
+      backgroundColor: type === 'success' ? '#4CAF50' : '#FF9800',
+      color: 'white',
+      borderRadius: '4px',
+      boxShadow: '0 2px 4px rgba(0,0,0,0.2)',
+      zIndex: '9999',
+      opacity: '0',
+      transition: 'opacity 0.3s ease'
+    });
+    
+    // Add to document
+    document.body.appendChild(notification);
+    
+    // Trigger animation
+    setTimeout(() => {
+      notification.style.opacity = '1';
+    }, 10);
+    
+    // Remove after 5 seconds
+    setTimeout(() => {
+      notification.style.opacity = '0';
+      setTimeout(() => {
+        document.body.removeChild(notification);
+      }, 300);
+    }, 5000);
+  }
+  
+  // Method to register sync function
+  registerSyncFunction(syncFunction) {
+    this.syncPendingData = syncFunction;
+  }
+}
+
+// Service Worker Management
+class PWAManager {
+  constructor() {
+    this.registerServiceWorker();
+  }
+  
+  async registerServiceWorker() {
+    if ('serviceWorker' in navigator) {
+      try {
+        const registration = await navigator.serviceWorker.register('/sw.js', {
+          scope: '/'
+        });
+        
+        if (registration.installing) {
+          console.log('Service worker installing');
+        } else if (registration.waiting) {
+          console.log('Service worker installed');
+        } else if (registration.active) {
+          console.log('Service worker active');
+        }
+        
+        // Set up update checking
+        this.setupPeriodicSync(registration);
+        
+      } catch (error) {
+        console.error('Service worker registration failed:', error);
+      }
+    }
+  }
+  
+  setupPeriodicSync(registration) {
+    // Check for updates every hour
+    setInterval(() => {
+      registration.update();
+      console.log('Checking for service worker updates...');
+    }, 60 * 60 * 1000);
+    
+    // Handle new updates
+    registration.addEventListener('updatefound', () => {
+      // New service worker is being installed
+      const newWorker = registration.installing;
+      
+      newWorker.addEventListener('statechange', () => {
+        if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
+          // New version is installed but not active yet
+          // Dispatch custom event that our React components can listen for
+          const updateEvent = new Event('updatefound');
+          window.dispatchEvent(updateEvent);
+        }
+      });
+    });
+  }
+}
+
+// Initialize the PWA components
+if (typeof window !== 'undefined') {
+  // Start network status monitoring
+  const networkMonitor = new NetworkStatusMonitor();
+  
+  // Register service worker
+  const pwaManager = new PWAManager();
+  
+  // Make them available globally
+  window.networkMonitor = networkMonitor;
+  window.pwaManager = pwaManager;
+}
```
