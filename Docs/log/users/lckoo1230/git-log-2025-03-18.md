# Git Activity Log - Henry Koo
Generated at: Tue Mar 18 09:42:22 UTC 2025
## Changes by Henry Koo
```diff
commit 228af97b409ea2494845e51f4f64b0e3e7c5f51b
Author: Henrykoo <lckoo1230@gmail.com>
Date:   Tue Mar 18 17:13:00 2025 +0800

    fixing issues

diff --git a/jest-resolver.cjs b/jest-resolver.cjs
new file mode 100644
index 0000000..992339a
--- /dev/null
+++ b/jest-resolver.cjs
@@ -0,0 +1,28 @@
+const path = require('path');
+const fs = require('fs');
+
+function resolveModule(request, options) {
+  // Handle src imports
+  if (request.startsWith('src/')) {
+    const rootDir = options.rootDir;
+    const fullPath = path.resolve(rootDir, request);
+    
+    // Check .js and .mjs extensions
+    const jsPath = fullPath.endsWith('.js') ? fullPath : `${fullPath}.js`;
+    const mjsPath = fullPath.endsWith('.mjs') ? fullPath : `${fullPath}.mjs`;
+    
+    if (fs.existsSync(jsPath)) return jsPath;
+    if (fs.existsSync(mjsPath)) return mjsPath;
+    
+    // Fallback to original path
+    return fullPath;
+  }
+  
+  // Default resolver
+  return options.defaultResolver(request, options);
+}
+
+module.exports = {
+  sync: resolveModule,
+  async: resolveModule
+};
diff --git a/jest-resolver.js b/jest-resolver.js
new file mode 100644
index 0000000..42d4dc1
--- /dev/null
+++ b/jest-resolver.js
@@ -0,0 +1,16 @@
+import path from 'path';
+import { fileURLToPath } from 'url';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+export default function resolver(request, options) {
+  // Handle src imports
+  if (request.startsWith('src/')) {
+    const fullPath = path.resolve(__dirname, request);
+    return fullPath;
+  }
+  
+  // Default resolver
+  return options.defaultResolver(request, options);
+}
diff --git a/jest.config.js b/jest.config.js
index fd72584..6e3a77f 100644
--- a/jest.config.js
+++ b/jest.config.js
@@ -6,8 +6,9 @@ export default {
   testMatch: ['**/__tests__/**/*.js?(x)', '**/?(*.)+(spec|test).js?(x)'],
   extensionsToTreatAsEsm: ['.jsx'],
   moduleNameMapper: {
-    '^(\\.{1,2}/.*)\\.js$': '$1'
+    '^src/(.*)$': '<rootDir>/src/$1'
   },
+  resolver: '<rootDir>/jest-resolver.cjs',
   transformIgnorePatterns: [
     'node_modules/(?!(@astrojs)/)'
   ]
diff --git a/package.json b/package.json
index 46ba98d..1f8225d 100644
--- a/package.json
+++ b/package.json
@@ -33,11 +33,13 @@
     "tailwindcss-animate": "^1.0.7"
   },
   "devDependencies": {
+    "@babel/preset-env": "^7.26.9",
     "@babel/preset-react": "^7.26.3",
     "@tailwindcss/typography": "^0.5.10",
     "@types/react": "^18.2.21",
     "@vite-pwa/astro": "^0.5.0",
     "autoprefixer": "^10.4.15",
+    "babel-jest": "^29.7.0",
     "jest": "^29.5.0",
     "jest-environment-jsdom": "^29.7.0",
     "postcss": "^8.4.29",

commit 4c5ca31c401a68d00dd93523d92df00fd199d58d
Author: Henrykoo <lckoo1230@gmail.com>
Date:   Tue Mar 18 17:12:53 2025 +0800

    fixing issues

diff --git a/Docs/to-do-plan b/Docs/to-do-plan
index 90fe50e..7735a8f 160000
--- a/Docs/to-do-plan
+++ b/Docs/to-do-plan
@@ -1 +1 @@
-Subproject commit 90fe50ef320b6e2833810f558182966f5ac0ec8f
+Subproject commit 7735a8f83115b5baa70eb9ff594231785e5d3041

commit 4a84497187a983dc7b2a217066f558bc1d0f2dc0
Author: Henrykoo <lckoo1230@gmail.com>
Date:   Tue Mar 18 17:00:06 2025 +0800

    passing test 5/6

diff --git a/package.json b/package.json
index e4f45dc..46ba98d 100644
--- a/package.json
+++ b/package.json
@@ -33,11 +33,13 @@
     "tailwindcss-animate": "^1.0.7"
   },
   "devDependencies": {
+    "@babel/preset-react": "^7.26.3",
     "@tailwindcss/typography": "^0.5.10",
     "@types/react": "^18.2.21",
     "@vite-pwa/astro": "^0.5.0",
     "autoprefixer": "^10.4.15",
     "jest": "^29.5.0",
+    "jest-environment-jsdom": "^29.7.0",
     "postcss": "^8.4.29",
     "tailwindcss": "^3.3.3"
   }

commit bea433a3f2a3c98678770c7d991b3831f4170f76
Author: Henrykoo <lckoo1230@gmail.com>
Date:   Tue Mar 18 16:39:16 2025 +0800

    mvoing sqlite_engine.test.js

diff --git a/tests/sqlite_engine.test.js b/src/test/sqlite_engine.test.js
similarity index 100%
rename from tests/sqlite_engine.test.js
rename to src/test/sqlite_engine.test.js

commit 9e1381932977eff7e91b75b856cadac1aad19be2
Author: Henrykoo <lckoo1230@gmail.com>
Date:   Tue Mar 18 15:51:40 2025 +0800

    sqlite_engine

diff --git a/src/config/config_constants.js b/src/config/config_constants.js
new file mode 100644
index 0000000..d59d6f5
--- /dev/null
+++ b/src/config/config_constants.js
@@ -0,0 +1,184 @@
+import dotenv from 'dotenv';
+dotenv.config();
+import path from 'path';
+
+// Determine the current directory path
+const projectRoot = process.cwd();
+
+// Database Configuration
+const DEFAULT_PAGE_SIZE = process.env.DEFAULT_PAGE_SIZE || 10;
+const CARDS_DB_PATH = process.env.MCARD_DB_PATH || path.join(projectRoot, 'public', 'data', 'cards.db');
+const TEST_DB_PATH = process.env.TEST_DB_PATH || path.join(projectRoot,'src','test', 'data', 'db' ,'test.db');
+// Default Configuration Values
+const DEFAULT_HASH_ALGORITHM = process.env.MCARD_HASH_ALGORITHM || 'md5';
+const DEFAULT_HASH_LENGTH = process.env.DEFAULT_HASH_LENGTH || 64;
+
+// Logging Configuration
+const DEFAULT_LOG_LEVEL = 'info';
+const LOG_LEVEL = process.env.LOG_LEVEL || DEFAULT_LOG_LEVEL;
+
+// Hash Algorithm Configuration
+const HashAlgorithm = (input) => {
+  // Return default value for null or undefined
+  if (input === null || input === undefined) {
+    return HashAlgorithm.DEFAULT;
+  }
+
+  // Normalize input to lowercase and trim
+  const normalizedInput = input.toString().toLowerCase().trim();
+
+  // Check if the input matches any of the predefined hash algorithms
+  return VALID_HASH_FUNCTIONS.includes(normalizedInput) ? normalizedInput : HashAlgorithm.DEFAULT;
+};
+
+// Add the existing constants as properties
+HashAlgorithm.MD5 = 'md5';
+HashAlgorithm.SHA1 = 'sha1';
+HashAlgorithm.SHA224 = 'sha224';
+HashAlgorithm.SHA256 = 'sha256';
+HashAlgorithm.SHA384 = 'sha384';
+HashAlgorithm.SHA512 = 'sha512';
+HashAlgorithm.CUSTOM = 'custom';
+HashAlgorithm.DEFAULT = 'md5';
+
+// Hash Algorithm Hierarchy
+const HASH_ALGORITHM_HIERARCHY = {
+  [HashAlgorithm.MD5]: HashAlgorithm.SHA1,
+  [HashAlgorithm.SHA1]: HashAlgorithm.SHA224,
+  [HashAlgorithm.SHA224]: HashAlgorithm.SHA256,
+  [HashAlgorithm.SHA256]: HashAlgorithm.SHA384,
+  [HashAlgorithm.SHA384]: HashAlgorithm.SHA512
+};
+
+// Hash Algorithm Metadata
+const HashAlgorithmMetadata = {
+  [HashAlgorithm.MD5]: {
+    name: HashAlgorithm.MD5,
+    description: 'MD5 hash function',
+    outputLength: 32,
+    isDefault: true
+  },
+  [HashAlgorithm.SHA1]: {
+    name: HashAlgorithm.SHA1,
+    description: 'SHA-1 hash function',
+    outputLength: 40,
+    isDefault: false
+  },
+  [HashAlgorithm.SHA224]: {
+    name: HashAlgorithm.SHA224,
+    description: 'SHA-224 hash function',
+    outputLength: 56,
+    isDefault: false
+  },
+  [HashAlgorithm.SHA256]: {
+    name: HashAlgorithm.SHA256,
+    description: 'SHA-256 hash function',
+    outputLength: 64,
+    isDefault: false
+  },
+  [HashAlgorithm.SHA384]: {
+    name: HashAlgorithm.SHA384,
+    description: 'SHA-384 hash function',
+    outputLength: 96,
+    isDefault: false
+  },
+  [HashAlgorithm.SHA512]: {
+    name: HashAlgorithm.SHA512,
+    description: 'SHA-512 hash function',
+    outputLength: 128,
+    isDefault: false
+  }
+};
+
+const VALID_HASH_FUNCTIONS = [
+  HashAlgorithm.MD5,
+  HashAlgorithm.SHA1,
+  HashAlgorithm.SHA224,
+  HashAlgorithm.SHA256,
+  HashAlgorithm.SHA384,
+  HashAlgorithm.SHA512,
+  HashAlgorithm.CUSTOM
+];
+
+// Export Strategy Notes:
+// 1. Default Export: Allows importing the entire configuration object
+//    Example: import configConstants from './config_constants.js'
+//    Usage: configConstants.LOG_LEVEL
+//
+// 2. Named Exports: Allows importing specific constants directly
+//    Example: import { LOG_LEVEL, HashAlgorithm } from './config_constants.js'
+//    Usage: Directly use LOG_LEVEL or HashAlgorithm
+//
+// This approach provides maximum flexibility for importing and using constants
+
+export default {
+  // Database Constants
+  DEFAULT_PAGE_SIZE,
+  CARDS_DB_PATH,
+
+  // Store Constants
+  DEFAULT_HASH_ALGORITHM,
+  DEFAULT_HASH_LENGTH,
+
+  // Logging Constants
+  DEFAULT_LOG_LEVEL,
+  LOG_LEVEL,
+
+  // Hash-related Exports
+  HashAlgorithm,
+  HASH_ALGORITHM_HIERARCHY,
+  HashAlgorithmMetadata,
+  VALID_HASH_FUNCTIONS,
+  
+  // Project Root
+  projectRoot
+};
+
+export const configConstants = {
+  // Database Constants
+  DEFAULT_PAGE_SIZE,
+  CARDS_DB_PATH,
+  TEST_DB_PATH,
+
+  // Store Constants
+  DEFAULT_HASH_ALGORITHM,
+  DEFAULT_HASH_LENGTH,
+
+  // Logging Constants
+  DEFAULT_LOG_LEVEL,
+  LOG_LEVEL,
+
+  // Hash-related Exports
+  HashAlgorithm,
+  HASH_ALGORITHM_HIERARCHY,
+  HashAlgorithmMetadata,
+  VALID_HASH_FUNCTIONS,
+  
+  // Project Root
+  projectRoot
+};
+
+export {
+  // Database Constants
+  DEFAULT_PAGE_SIZE,
+  CARDS_DB_PATH,
+  TEST_DB_PATH,
+
+  // Store Constants
+  DEFAULT_HASH_ALGORITHM,
+  DEFAULT_HASH_LENGTH,
+
+  // Logging Constants
+  DEFAULT_LOG_LEVEL,
+  LOG_LEVEL,
+
+  // Hash-related Exports
+  HashAlgorithm,
+  HASH_ALGORITHM_HIERARCHY,
+  HashAlgorithmMetadata,
+  VALID_HASH_FUNCTIONS,
+  
+  // Project Root
+  projectRoot
+};
+
diff --git a/src/config/env_parameters.js b/src/config/env_parameters.js
new file mode 100644
index 0000000..078604d
--- /dev/null
+++ b/src/config/env_parameters.js
@@ -0,0 +1,69 @@
+import dotenv from 'dotenv';
+import path from 'path';
+import {
+  DEFAULT_HASH_LENGTH,
+  DEFAULT_LOG_LEVEL
+} from './config_constants.js';
+
+class EnvParameters {
+  static #instance = null;
+
+  constructor() {
+    // Load environment variables
+    dotenv.config();
+
+    // Set values from environment or use defaults from config_constants
+    this.MCARD_DB_PATH = process.env.MCARD_DB_PATH;
+    this.MCARD_HASH_ALGORITHM = process.env.MCARD_HASH_ALGORITHM;
+    this.MCARD_HASH_CUSTOM_MODULE = process.env.MCARD_HASH_CUSTOM_MODULE;
+    this.MCARD_HASH_CUSTOM_FUNCTION = process.env.MCARD_HASH_CUSTOM_FUNCTION;
+    this.MCARD_HASH_LENGTH = parseInt(process.env.MCARD_HASH_LENGTH || DEFAULT_HASH_LENGTH, 10);
+    this.MCARD_LOG_LEVEL = process.env.MCARD_LOG_LEVEL || DEFAULT_LOG_LEVEL;
+  }
+
+  static getInstance() {
+    if (!EnvParameters.#instance) {
+      EnvParameters.#instance = new EnvParameters();
+    }
+    return EnvParameters.#instance;
+  }
+
+  static reset() {
+    EnvParameters.#instance = null;
+  }
+
+  getLogLevel() {
+    return this.MCARD_LOG_LEVEL;
+  }
+
+  get_log_level() {
+    return this.getLogLevel();
+  }
+
+  // Getter methods matching Python implementation
+  get_db_path() {
+    return this.MCARD_DB_PATH;
+  }
+
+  get_hash_algorithm() {
+    return this.MCARD_HASH_ALGORITHM;
+  }
+
+  get_hash_custom_module() {
+    return this.MCARD_HASH_CUSTOM_MODULE;
+  }
+
+  get_hash_custom_function() {
+    return this.MCARD_HASH_CUSTOM_FUNCTION;
+  }
+
+  get_hash_custom_length() {
+    return this.MCARD_HASH_LENGTH;
+  }
+
+  get_default_db_path() {
+    return path.resolve(process.cwd(), this.MCARD_DB_PATH);
+  }
+}
+
+export { EnvParameters as default, EnvParameters };
diff --git a/src/content/model/mcard.d.ts b/src/content/model/mcard.d.ts
deleted file mode 100644
index 87c1823..0000000
--- a/src/content/model/mcard.d.ts
+++ /dev/null
@@ -1,19 +0,0 @@
-import { HashAlgorithm } from './hash/enums';
-
-interface MCardOptions {
-  storeAsBlob?: boolean;
-}
-
-declare class MCard {
-  constructor(
-    content: string | Buffer, 
-    hashFunction?: string, 
-    options?: MCardOptions
-  );
-
-  hash: string;
-  content: Buffer;
-  g_time: string;
-}
-
-export { MCard, MCardOptions };
diff --git a/src/engine/sqlite_engine.js b/src/engine/sqlite_engine.js
new file mode 100644
index 0000000..9d42617
--- /dev/null
+++ b/src/engine/sqlite_engine.js
@@ -0,0 +1,522 @@
+import log from 'src/services/logger.js';
+import { MCardFromData } from 'src/content/model/mcard.js';
+import { Page } from 'src/models/card-collection.js';
+import { DEFAULT_PAGE_SIZE, CARDS_DB_PATH } from 'src/config/config_constants.js';
+import { MCARD_TABLE_SCHEMA, TRIGGERS } from 'src/models/database_schemas.js';
+import { promises as fs } from 'fs';
+import path from 'path';
+import Database from 'better-sqlite3';
+
+class SQLiteConnection {
+  /**
+   * Create a new SQLite database connection
+   * @param {string} dbPath - Path to the SQLite database file
+   */
+  constructor(dbPath = CARDS_DB_PATH) {
+    this.dbPath = dbPath;
+    this.conn = null;
+    this.setup_database();
+  }
+
+  /**
+   * Set up the database, creating the file and table if they don't exist
+   */
+  async setup_database() {
+    try {
+      // Ensure the directory exists
+      const dbDir = path.dirname(this.dbPath);
+      await fs.mkdir(dbDir, { recursive: true });
+
+      // Create the database connection
+      this.conn = new Database(this.dbPath);
+
+      // Drop existing tables if they exist
+      const dropTableStatements = [
+        'DROP TABLE IF EXISTS documents',
+        'DROP TABLE IF EXISTS card'
+      ];
+      dropTableStatements.forEach(stmt => {
+        this.conn.prepare(stmt).run();
+      });
+
+      // Create the documents table using FTS5
+      this.conn.prepare(MCARD_TABLE_SCHEMA.documents).run();
+
+      // Create the card table
+      this.conn.prepare(MCARD_TABLE_SCHEMA.card).run();
+
+      // Create triggers
+      TRIGGERS.forEach(trigger => {
+        this.conn.prepare(trigger).run();
+      });
+
+      log.debug(`Database setup complete at ${this.dbPath}`);
+    } catch (error) {
+      log.error(`Error setting up database: ${error.message}`);
+      throw error;
+    }
+  }
+
+  /**
+   * Establish a database connection
+   */
+  connect() {
+    if (!this.conn) {
+      log.debug(`Connecting to database at ${this.dbPath}`);
+      try {
+        this.conn = new Database(this.dbPath);
+        log.debug(`Connection established to ${this.dbPath}`);
+        log.debug(`Database connection details: ${this.conn}`);
+
+        // Check if the database is empty and initialize schema if necessary
+        const tablesStmt = this.conn.prepare("SELECT name FROM sqlite_master WHERE type='table'");
+        const tables = tablesStmt.all();
+
+        if (tables.length === 0) {
+          // Drop existing tables and triggers
+          this.conn.prepare("DROP TABLE IF EXISTS card").run();
+          this.conn.prepare("DROP TABLE IF EXISTS documents").run();
+
+          // Create tables from schema
+          Object.entries(MCARD_TABLE_SCHEMA).forEach(([tableName, schema]) => {
+            log.info(`Executing SQL for ${tableName}: ${schema}`);
+            this.conn.prepare(schema).run();
+          });
+
+          log.debug("Database schema created successfully");
+
+          // Create triggers
+          TRIGGERS.forEach((trigger) => {
+            log.info(`Executing SQL trigger: ${trigger}`);
+            this.conn.prepare(trigger).run();
+          });
+        }
+      } catch (error) {
+        log.error(`Database error connecting to ${this.dbPath}: ${error.message}`);
+        throw error;
+      }
+    }
+  }
+
+  /**
+   * Close the database connection
+   */
+  disconnect() {
+    if (this.conn) {
+      this.conn.close();
+      this.conn = null;
+      log.debug('Database connection closed');
+    }
+  }
+
+  /**
+   * Commit the current transaction
+   */
+  commit() {
+    if (this.conn) {
+      this.conn.prepare('COMMIT').run();
+    }
+  }
+
+  /**
+   * Rollback the current transaction
+   */
+  rollback() {
+    if (this.conn) {
+      this.conn.prepare('ROLLBACK').run();
+    }
+  }
+}
+
+class SQLiteEngine {
+  /**
+   * Create a new SQLite storage engine
+   * @param {SQLiteConnection} connection - Database connection
+   */
+  constructor(connection = null) {
+    this.connection = connection || new SQLiteConnection();
+    this.connection.connect();
+    this.clearStmt = this.connection.conn.prepare('DELETE FROM card');
+  }
+
+  /**
+   * Destructor to ensure database connection is closed
+   */
+  destructor() {
+    this.connection.disconnect();
+  }
+
+  /**
+   * Symbol.dispose method for resource cleanup
+   */
+  [Symbol.dispose]() {
+    this.destructor();
+  }
+
+  /**
+   * Add a card to the database
+   * @param {MCard} card - Card to add
+   * @returns {string} Hash of the added card
+   */
+  add(card) {
+    try {
+      const stmt = this.connection.conn.prepare(
+        'INSERT OR REPLACE INTO card (hash, content, g_time) VALUES (?, ?, ?)'
+      );
+      
+      const result = stmt.run(
+        String(card.hash), 
+        card.content, 
+        card.g_time
+      );
+
+      log.debug(`Added card with hash ${card.hash}`);
+      return String(card.hash);
+    } catch (error) {
+      if (error.code === 'SQLITE_CONSTRAINT') {
+        throw new Error(`Card with hash ${card.hash} already exists`);
+      }
+      log.error(`Error adding card: ${error.message}`);
+      throw error;
+    }
+  }
+
+  /**
+   * Retrieve a card by its hash
+   * @param {string} hashValue - Hash of the card to retrieve
+   * @returns {MCard|null} Retrieved card or null
+   */
+  get(hashValue) {
+    try {
+      const stmt = this.connection.conn.prepare(
+        'SELECT content, g_time, hash FROM card WHERE hash = ?'
+      );
+      
+      const row = stmt.get(String(hashValue));
+      
+      if (!row) return null;
+      
+      return new MCardFromData(row.content, row.hash, row.g_time);
+    } catch (error) {
+      log.error(`Error retrieving card: ${error.message}`);
+      throw error;
+    }
+  }
+
+  /**
+   * Delete a card by its hash
+   * @param {string} hashValue - Hash of the card to delete
+   * @returns {boolean} Whether deletion was successful
+   */
+  delete(hashValue) {
+    try {
+      const stmt = this.connection.conn.prepare(
+        'DELETE FROM card WHERE hash = ?'
+      );
+      
+      const result = stmt.run(String(hashValue));
+      return result.changes > 0;
+    } catch (error) {
+      log.error(`Error deleting card: ${error.message}`);
+      throw error;
+    }
+  }
+
+  /**
+   * Get a page of cards
+   * @param {number} page_number - Page number to retrieve
+   * @param {number} page_size - Number of items per page
+   * @returns {Page} Page of cards
+   */
+  get_page(page_number = 1, page_size = DEFAULT_PAGE_SIZE) {
+    if (page_number < 1 || page_size < 1) {
+      throw new Error('Page number and size must be >= 1');
+    }
+
+    const offset = (page_number - 1) * page_size;
+
+    // Get total count of items
+    const countStmt = this.connection.conn.prepare(
+      'SELECT COUNT(*) as total FROM card'
+    );
+    const { total } = countStmt.get();
+
+    // Get page of items
+    const stmt = this.connection.conn.prepare(`
+      SELECT content, g_time, hash 
+      FROM card 
+      ORDER BY g_time DESC 
+      LIMIT ? OFFSET ?
+    `);
+    
+    const rows = stmt.all(page_size, offset);
+
+    // Convert rows to cards
+    const items = [];
+    for (const row of rows) {
+        const [content, g_time, hash] = [row.content, row.g_time, row.hash];
+        const card = new MCardFromData(content, hash, g_time);
+        items.push(card);
+    }
+
+    // Calculate total pages
+    const total_pages = Math.ceil(total / page_size);
+
+    return new Page({
+      items,
+      total_items: total,
+      page_number,
+      page_size,
+      has_next: offset + page_size < total,
+      has_previous: page_number > 1,
+      total_pages
+    });
+  }
+
+  /**
+   * Search cards by string
+   * @param {string} search_string - String to search for
+   * @param {number} page_number - Page number to retrieve
+   * @param {number} page_size - Number of items per page
+   * @returns {Page} Page of matching cards
+   */
+  search_by_string(searchString, pageNumber = 1, pageSize = DEFAULT_PAGE_SIZE) {
+    try {
+      if (pageNumber < 1) {
+        throw new Error('Page number must be >= 1');
+      }
+      if (pageSize < 1) {
+        throw new Error('Page size must be >= 1');
+      }
+
+      const offset = (pageNumber - 1) * pageSize;
+      const cursor = this.connection.conn;
+
+      // Debug: Log the search parameters
+      log.info(`Searching with string: ${searchString}, Page: ${pageNumber}, PageSize: ${pageSize}`);
+
+      // First, get total count of matching items
+      const countStmt = cursor.prepare(`
+        SELECT COUNT(*) as total FROM card 
+        WHERE 
+          CAST(content AS TEXT) LIKE ? OR 
+          hash LIKE ? OR 
+          g_time LIKE ?
+      `);
+      const { total } = countStmt.get(
+        `%${searchString}%`, 
+        `%${searchString}%`, 
+        `%${searchString}%`
+      );
+
+      // Debug: Log the total count
+      log.info(`Total matching items: ${total}`);
+
+      // Then, get the actual items for the current page
+      const stmt = cursor.prepare(`
+        SELECT content, g_time, hash FROM card 
+        WHERE 
+          CAST(content AS TEXT) LIKE ? OR 
+          hash LIKE ? OR 
+          g_time LIKE ?
+        ORDER BY g_time DESC LIMIT ? OFFSET ?
+      `);
+      
+      const rows = stmt.all(
+        `%${searchString}%`, 
+        `%${searchString}%`, 
+        `%${searchString}%`,
+        pageSize, 
+        offset
+      );
+
+      // Debug: Log the rows
+      log.info(`Matching rows: ${JSON.stringify(rows)}`);
+
+      // Convert rows to cards
+      const items = [];
+      for (const row of rows) {
+        const [content, g_time, hash] = [row.content, row.g_time, row.hash];
+        const card = new MCardFromData(content, hash, g_time);
+        items.push(card);
+      }
+
+      // Calculate pagination flags
+      const has_next = total > (pageNumber * pageSize);
+      const has_previous = pageNumber > 1;
+
+      return new Page({
+        items,
+        total_items: total,
+        page_number: pageNumber,
+        page_size: pageSize,
+        has_next,
+        has_previous,
+        total_pages: Math.ceil(total / pageSize)
+      });
+    } catch (error) {
+      log.error(`Error searching cards: ${error.message}`);
+      throw error;
+    }
+  }
+
+  /**
+   * Search for cards by content, hash, or g_time
+   * @param {string} searchString - String to search for
+   * @param {number} pageNumber - Page number for pagination
+   * @param {number} pageSize - Number of items per page
+   * @returns {Page} Paginated search results
+   */
+  search_by_content(searchString, pageNumber = 1, pageSize = DEFAULT_PAGE_SIZE) {
+    try {
+      if (pageNumber < 1) {
+        throw new Error('Page number must be >= 1');
+      }
+      if (pageSize < 1) {
+        throw new Error('Page size must be >= 1');
+      }
+
+      const offset = (pageNumber - 1) * pageSize;
+      const cursor = this.connection.conn;
+
+      // First, get total count of matching items
+      const countStmt = cursor.prepare(
+        'SELECT COUNT(*) as total FROM card WHERE CAST(content AS TEXT) LIKE ?'
+      );
+      const { total } = countStmt.get(`%${searchString}%`);
+
+      // Then, get the actual items for the current page
+      const stmt = cursor.prepare(`
+        SELECT content, g_time, hash FROM card 
+        WHERE CAST(content AS TEXT) LIKE ?
+        ORDER BY g_time DESC LIMIT ? OFFSET ?
+      `);
+      
+      const rows = stmt.all(
+        `%${searchString}%`,
+        pageSize, 
+        offset
+      );
+
+      // Convert rows to cards
+      const items = [];
+      for (const row of rows) {
+        const [content, g_time, hash] = [row.content, row.g_time, row.hash];
+        const card = new MCardFromData(content, hash, g_time);
+        items.push(card);
+      }
+
+      // Calculate pagination flags
+      const has_next = total > (pageNumber * pageSize);
+      const has_previous = pageNumber > 1;
+
+      return new Page({
+        items,
+        total_items: total,
+        page_number: pageNumber,
+        page_size: pageSize,
+        has_next,
+        has_previous,
+        total_pages: Math.ceil(total / pageSize)
+      });
+    } catch (error) {
+      log.error(`Error searching cards: ${error.message}`);
+      throw error;
+    }
+  }
+
+  begin() {
+    if (this.connection.conn) {
+      this.connection.conn.prepare('BEGIN TRANSACTION').run();
+    }
+  }
+
+  commit() {
+    if (this.connection.conn) {
+      this.connection.conn.prepare('COMMIT').run();
+    }
+  }
+
+  rollback() {
+    if (this.connection.conn) {
+      this.connection.conn.prepare('ROLLBACK').run();
+    }
+  }
+
+  clear() {
+    try {
+      this.begin();
+      this.clearStmt.run();
+      this.commit();
+    } catch (error) {
+      this.rollback();
+      throw error;
+    }
+  }
+
+  /**
+   * Count the total number of cards
+   * @returns {number} Total number of cards
+   */
+  count() {
+    const stmt = this.connection.conn.prepare('SELECT COUNT(*) FROM card');
+    const { total } = stmt.get();
+    return total;
+  }
+
+  /**
+   * Get all cards
+   * @param {number} page_number - Page number to retrieve
+   * @param {number} page_size - Number of items per page
+   * @returns {Page} Page of all cards
+   */
+  get_all(page_number = 1, page_size = DEFAULT_PAGE_SIZE) {
+    if (page_number < 1) {
+      throw new Error("Page number must be >= 1");
+    }
+    if (page_size < 1) {
+      throw new Error("Page size must be >= 1");
+    }
+    
+    const offset = (page_number - 1) * page_size;
+    
+    // Get total count of items
+    const countStmt = this.connection.conn.prepare(
+      'SELECT COUNT(*) FROM card'
+    );
+    const { total } = countStmt.get();
+
+    // Get page of items
+    const stmt = this.connection.conn.prepare(`
+      SELECT content, g_time, hash 
+      FROM card 
+      ORDER BY g_time DESC 
+      LIMIT ? OFFSET ?
+    `);
+    
+    const rows = stmt.all(page_size, offset);
+
+    // Convert rows to cards
+    const items = [];
+    for (const row of rows) {
+        const [content, g_time, hash] = [row.content, row.g_time, row.hash];
+        const card = new MCardFromData(content, hash, g_time);
+        items.push(card);
+    }
+
+    // Calculate total pages
+    const total_pages = Math.ceil(total / page_size);
+
+    return new Page({
+      items,
+      total_items: total,
+      page_number,
+      page_size,
+      has_next: offset + page_size < total,
+      has_previous: page_number > 1,
+      total_pages
+    });
+  }
+}
+
+export { SQLiteEngine, SQLiteConnection };
\ No newline at end of file
diff --git a/tests/sqlite_engine.test.js b/tests/sqlite_engine.test.js
new file mode 100644
index 0000000..9ba8cc5
--- /dev/null
+++ b/tests/sqlite_engine.test.js
@@ -0,0 +1,167 @@
+import { SQLiteEngine, SQLiteConnection } from 'src/engine/sqlite_engine.js';
+import { MCardFromData } from 'src/content/model/mcard.js';
+import fs from 'fs';
+import path from 'path';
+
+// Temporary test database path
+const TEST_DB_PATH = path.join(__dirname, 'test_cards.sqlite');
+
+describe('SQLiteEngine', () => {
+  let sqliteEngine;
+  let testCard;
+
+  beforeEach(() => {
+    // Create a new SQLite connection with a test database path
+    const connection = new SQLiteConnection(TEST_DB_PATH);
+    sqliteEngine = new SQLiteEngine(connection);
+
+    // Create a test card
+    testCard = new MCardFromData(
+      JSON.stringify({ 
+        title: 'Test Card', 
+        content: 'This is a test card content' 
+      }), 
+      'test_hash_123', 
+      Date.now()
+    );
+  });
+
+  afterEach(() => {
+    // Clear the database after each test
+    sqliteEngine.clear();
+    sqliteEngine.connection.disconnect();
+
+    // Remove the test database file
+    if (fs.existsSync(TEST_DB_PATH)) {
+      fs.unlinkSync(TEST_DB_PATH);
+    }
+  });
+
+  test('should add a card to the database', () => {
+    const hash = sqliteEngine.add(testCard);
+    expect(hash).toBe(testCard.hash);
+  });
+
+  test('should retrieve a card by hash', () => {
+    sqliteEngine.add(testCard);
+    const retrievedCard = sqliteEngine.get(testCard.hash);
+    
+    expect(retrievedCard).toBeTruthy();
+    expect(retrievedCard.hash).toBe(testCard.hash);
+    expect(retrievedCard.content).toBe(testCard.content);
+  });
+
+  test('should return null when retrieving non-existent card', () => {
+    const nonExistentCard = sqliteEngine.get('non_existent_hash');
+    expect(nonExistentCard).toBeNull();
+  });
+
+  test('should delete a card', () => {
+    sqliteEngine.add(testCard);
+    const deleteResult = sqliteEngine.delete(testCard.hash);
+    
+    expect(deleteResult).toBe(true);
+    
+    const retrievedCard = sqliteEngine.get(testCard.hash);
+    expect(retrievedCard).toBeNull();
+  });
+
+  test('should get paginated results', () => {
+    // Add multiple cards
+    const cards = [
+      new MCardFromData(JSON.stringify({ title: 'Card 1' }), 'hash1', Date.now()),
+      new MCardFromData(JSON.stringify({ title: 'Card 2' }), 'hash2', Date.now()),
+      new MCardFromData(JSON.stringify({ title: 'Card 3' }), 'hash3', Date.now())
+    ];
+
+    cards.forEach(card => sqliteEngine.add(card));
+
+    const page = sqliteEngine.get_page(1, 2);
+    
+    expect(page.items.length).toBe(2);
+    expect(page.total_items).toBe(3);
+    expect(page.page_number).toBe(1);
+    expect(page.page_size).toBe(2);
+    expect(page.has_next).toBe(true);
+  });
+
+  test('should search cards by string', () => {
+    // Add multiple cards with different content
+    const cards = [
+      new MCardFromData(JSON.stringify({ title: 'Search Test Card 1', content: 'First test card' }), 'hash1', Date.now()),
+      new MCardFromData(JSON.stringify({ title: 'Search Test Card 2', content: 'Second test card' }), 'hash2', Date.now())
+    ];
+
+    cards.forEach(card => sqliteEngine.add(card));
+
+    const searchResults = sqliteEngine.search_by_string('test card');
+    
+    expect(searchResults.items.length).toBe(2);
+    expect(searchResults.total_items).toBe(2);
+  });
+
+  test('should count total cards', () => {
+    // Add multiple cards
+    const cards = [
+      new MCardFromData(JSON.stringify({ title: 'Card 1' }), 'hash1', Date.now()),
+      new MCardFromData(JSON.stringify({ title: 'Card 2' }), 'hash2', Date.now())
+    ];
+
+    cards.forEach(card => sqliteEngine.add(card));
+
+    const cardCount = sqliteEngine.count();
+    expect(cardCount).toBe(2);
+  });
+
+  test('should handle transaction rollback', () => {
+    try {
+      sqliteEngine.begin();
+      sqliteEngine.add(testCard);
+      sqliteEngine.rollback();
+
+      const retrievedCard = sqliteEngine.get(testCard.hash);
+      expect(retrievedCard).toBeNull();
+    } catch (error) {
+      fail('Transaction rollback failed');
+    }
+  });
+
+  test('should handle transaction commit', () => {
+    try {
+      sqliteEngine.begin();
+      sqliteEngine.add(testCard);
+      sqliteEngine.commit();
+
+      const retrievedCard = sqliteEngine.get(testCard.hash);
+      expect(retrievedCard).toBeTruthy();
+    } catch (error) {
+      fail('Transaction commit failed');
+    }
+  });
+
+  test('should get all cards', () => {
+    // Add multiple cards
+    const cards = [
+      new MCardFromData(JSON.stringify({ title: 'Card 1' }), 'hash1', Date.now()),
+      new MCardFromData(JSON.stringify({ title: 'Card 2' }), 'hash2', Date.now()),
+      new MCardFromData(JSON.stringify({ title: 'Card 3' }), 'hash3', Date.now())
+    ];
+
+    cards.forEach(card => sqliteEngine.add(card));
+
+    const allCards = sqliteEngine.get_all();
+    
+    expect(allCards.items.length).toBe(3);
+    expect(allCards.total_items).toBe(3);
+  });
+
+  test('should throw error for invalid page number', () => {
+    expect(() => sqliteEngine.get_page(0, 10)).toThrow('Page number must be >= 1');
+    expect(() => sqliteEngine.get_page(-1, 10)).toThrow('Page number must be >= 1');
+  });
+
+  test('should throw error for invalid page size', () => {
+    expect(() => sqliteEngine.get_page(1, 0)).toThrow('Page size must be >= 1');
+    expect(() => sqliteEngine.get_page(1, -1)).toThrow('Page size must be >= 1');
+  });
+});

commit 2eb5dd85e38b3b45ecc505f4c200b5d6116de96a
Author: Henrykoo <lckoo1230@gmail.com>
Date:   Mon Mar 17 17:48:18 2025 +0800

    Fix service worker registration issues and enhance PWA capabilities

diff --git a/astro.config.mjs b/astro.config.mjs
index dd7e18f..80773e3 100644
--- a/astro.config.mjs
+++ b/astro.config.mjs
@@ -1,15 +1,19 @@
 // @ts-check
 import { defineConfig } from 'astro/config';
 import react from '@astrojs/react';
-import path from 'path';
 import AstroPWA from '@vite-pwa/astro';
+import path from 'path';
 
 // https://astro.build/config
 export default defineConfig({
   integrations: [
     react(),
     AstroPWA({
-      registerType: 'autoUpdate',
+      mode: 'production',
+      base: '/',
+      scope: '/',
+      includeAssets: ['favicon.svg', 'pwa-192x192.png', 'pwa-512x512.png'],
+      registerType: 'prompt',
       manifest: {
         name: 'Redux Todo in Astro',
         short_name: 'Redux Todo',
@@ -27,20 +31,15 @@ export default defineConfig({
             src: 'pwa-512x512.png',
             sizes: '512x512',
             type: 'image/png',
-          },
-          {
-            src: 'pwa-512x512.png',
-            sizes: '512x512',
-            type: 'image/png',
-            purpose: 'maskable',
           }
         ]
       },
       workbox: {
-        // Use navigation fallback to the offline page
-        navigateFallback: '/offline',
-        globPatterns: ['**/*.{js,css,html,svg,png,ico,jpg,jpeg}'],
-        // Customize caching strategies for different resources
+        navigateFallback: '/',
+        globPatterns: ['**/*.{css,js,html,svg,png,ico,txt}'],
+        cleanupOutdatedCaches: true,
+        clientsClaim: true,
+        skipWaiting: true,
         runtimeCaching: [
           {
             urlPattern: /^https:\/\/fonts\.googleapis\.com\/.*/i,
@@ -50,6 +49,9 @@ export default defineConfig({
               expiration: {
                 maxEntries: 10,
                 maxAgeSeconds: 60 * 60 * 24 * 365 // 1 year
+              },
+              cacheableResponse: {
+                statuses: [0, 200]
               }
             }
           },
@@ -57,10 +59,68 @@ export default defineConfig({
             urlPattern: /^https:\/\/fonts\.gstatic\.com\/.*/i,
             handler: 'CacheFirst',
             options: {
-              cacheName: 'gstatic-fonts-cache',
+              cacheName: 'google-fonts-cache',
               expiration: {
                 maxEntries: 10,
                 maxAgeSeconds: 60 * 60 * 24 * 365 // 1 year
+              },
+              cacheableResponse: {
+                statuses: [0, 200]
+              }
+            }
+          },
+          {
+            urlPattern: ({ url }) => {
+              return url.origin === self.location.origin && 
+                    (url.pathname.endsWith('.png') || 
+                     url.pathname.endsWith('.jpg') || 
+                     url.pathname.endsWith('.svg') || 
+                     url.pathname.endsWith('.webp'));
+            },
+            handler: 'CacheFirst',
+            options: {
+              cacheName: 'images-cache',
+              expiration: {
+                maxEntries: 50,
+                maxAgeSeconds: 60 * 60 * 24 * 30 // 30 days
+              }
+            }
+          },
+          {
+            urlPattern: new RegExp('/_astro/'),
+            handler: 'CacheFirst',
+            options: {
+              cacheName: 'astro-assets-cache',
+              expiration: {
+                maxEntries: 50,
+                maxAgeSeconds: 60 * 60 * 24 * 90 // 90 days
+              }
+            }
+          },
+          {
+            urlPattern: ({ url }) => {
+              return url.origin === self.location.origin && url.pathname.startsWith('/api');
+            },
+            handler: 'NetworkFirst',
+            options: {
+              cacheName: 'api-cache',
+              expiration: {
+                maxEntries: 50,
+                maxAgeSeconds: 60 * 60 // 1 hour
+              },
+              networkTimeoutSeconds: 10
+            }
+          },
+          {
+            urlPattern: ({ url }) => {
+              return url.origin === self.location.origin;
+            },
+            handler: 'NetworkFirst',
+            options: {
+              cacheName: 'pages-cache',
+              expiration: {
+                maxEntries: 20,
+                maxAgeSeconds: 60 * 60 * 24 // 24 hours
               }
             }
           }
@@ -69,8 +129,9 @@ export default defineConfig({
       devOptions: {
         enabled: true,
         type: 'module',
-      },
-    }),
+        navigateFallback: '/',
+      }
+    })
   ],
   vite: {
     resolve: {
diff --git a/package.json b/package.json
index 754aee9..e4f45dc 100644
--- a/package.json
+++ b/package.json
@@ -14,38 +14,31 @@
   "dependencies": {
     "@astrojs/react": "latest",
     "@radix-ui/react-dialog": "^1.1.4",
-    "@radix-ui/react-label": "^2.1.1",
-    "@radix-ui/react-slot": "^1.1.1",
-    "@reduxjs/toolkit": "^2.5.0",
+    "@react-spring/web": "^9.7.3",
+    "@reduxjs/toolkit": "^2.6.1",
     "astro": "^5.3.0",
-    "class-variance-authority": "^0.7.1",
-    "clsx": "^2.1.1",
-    "lucide-react": "^0.473.0",
-    "react": "^19.0.0",
-    "react-dom": "^19.0.0",
+    "class-variance-authority": "^0.7.0",
+    "classnames": "^2.3.1",
+    "jimp": "^0.22.8",
+    "lucide-react": "^0.284.0",
+    "react": "^18.2.0",
+    "react-dom": "^18.2.0",
     "react-draggable": "^4.4.6",
-    "react-icons": "^5.4.0",
-    "react-redux": "^9.2.0",
+    "react-icons": "^5.5.0",
+    "react-redux": "^8.1.2",
     "react-resizable-panels": "^2.1.7",
     "react-split": "^2.0.14",
     "redux-persist": "^6.0.0",
-    "tailwind-merge": "^2.6.0",
-    "tailwindcss": "^3.4.17"
+    "tailwind-merge": "^1.14.0",
+    "tailwindcss-animate": "^1.0.7"
   },
   "devDependencies": {
-    "@babel/preset-env": "^7.26.9",
-    "@babel/preset-react": "^7.26.3",
-    "@typescript-eslint/eslint-plugin": "^8.26.0",
-    "@typescript-eslint/parser": "^8.26.0",
-    "@vite-pwa/astro": "^0.2.0",
-    "autoprefixer": "^10.4.20",
-    "babel-jest": "^29.7.0",
-    "eslint": "^9.21.0",
-    "eslint-plugin-astro": "^1.3.1",
-    "eslint-plugin-react": "^7.37.4",
-    "jest": "^29.7.0",
-    "jest-environment-jsdom": "^29.7.0",
-    "jsdom": "^26.0.0",
-    "tailwindcss-animate": "^1.0.7"
+    "@tailwindcss/typography": "^0.5.10",
+    "@types/react": "^18.2.21",
+    "@vite-pwa/astro": "^0.5.0",
+    "autoprefixer": "^10.4.15",
+    "jest": "^29.5.0",
+    "postcss": "^8.4.29",
+    "tailwindcss": "^3.3.3"
   }
 }
diff --git a/public/custom-sw.js b/public/custom-sw.js
new file mode 100644
index 0000000..a15dc7e
--- /dev/null
+++ b/public/custom-sw.js
@@ -0,0 +1,128 @@
+// This is a custom service worker implementation
+
+const CACHE_NAME = 'redux-todo-app-v1';
+const urlsToCache = [
+  '/',
+  '/index.html',
+  '/favicon.svg',
+  '/manifest.webmanifest',
+  '/pwa-192x192.png',
+  '/pwa-512x512.png'
+];
+
+// Install event - cache assets
+self.addEventListener('install', event => {
+  console.log('[Custom ServiceWorker] Install');
+  event.waitUntil(
+    caches.open(CACHE_NAME)
+      .then(cache => {
+        console.log('[Custom ServiceWorker] Caching app shell');
+        return cache.addAll(urlsToCache);
+      })
+      .then(() => {
+        console.log('[Custom ServiceWorker] Cached app shell');
+        return self.skipWaiting();
+      })
+  );
+});
+
+// Activate event - clean up old caches
+self.addEventListener('activate', event => {
+  console.log('[Custom ServiceWorker] Activate');
+  event.waitUntil(
+    caches.keys().then(cacheNames => {
+      return Promise.all(
+        cacheNames.filter(cacheName => {
+          return cacheName !== CACHE_NAME;
+        }).map(cacheName => {
+          console.log('[Custom ServiceWorker] Removing old cache', cacheName);
+          return caches.delete(cacheName);
+        })
+      );
+    }).then(() => {
+      console.log('[Custom ServiceWorker] Claiming clients');
+      // Take control of all clients ASAP
+      return self.clients.claim();
+    })
+  );
+});
+
+// Fetch event - serve from cache, fall back to network
+self.addEventListener('fetch', event => {
+  console.log('[Custom ServiceWorker] Fetch', event.request.url);
+  
+  // Skip cross-origin requests
+  if (!event.request.url.startsWith(self.location.origin)) {
+    return;
+  }
+  
+  event.respondWith(
+    caches.match(event.request)
+      .then(response => {
+        // Cache hit - return response
+        if (response) {
+          console.log('[Custom ServiceWorker] Cache hit for', event.request.url);
+          return response;
+        }
+        
+        // Clone the request because it's a one-time use stream
+        const fetchRequest = event.request.clone();
+        
+        return fetch(fetchRequest).then(response => {
+          // Check if we received a valid response
+          if (!response || response.status !== 200 || response.type !== 'basic') {
+            return response;
+          }
+          
+          // Clone the response because it's a one-time use stream
+          const responseToCache = response.clone();
+          
+          caches.open(CACHE_NAME)
+            .then(cache => {
+              console.log('[Custom ServiceWorker] Caching new resource:', event.request.url);
+              cache.put(event.request, responseToCache);
+            });
+            
+          return response;
+        });
+      })
+  );
+});
+
+// Message event handler
+self.addEventListener('message', event => {
+  console.log('[Custom ServiceWorker] Message received:', event.data);
+  
+  if (event.data && event.data.type === 'SKIP_WAITING') {
+    console.log('[Custom ServiceWorker] Skip waiting message received');
+    self.skipWaiting();
+  }
+});
+
+// Push notification event handler
+self.addEventListener('push', event => {
+  console.log('[Custom ServiceWorker] Push received:', event);
+  
+  const title = 'Redux Todo App';
+  const options = {
+    body: event.data ? event.data.text() : 'New content available!',
+    icon: '/pwa-192x192.png',
+    badge: '/pwa-192x192.png'
+  };
+  
+  event.waitUntil(
+    self.registration.showNotification(title, options)
+  );
+});
+
+// Notification click event handler
+self.addEventListener('notificationclick', event => {
+  console.log('[Custom ServiceWorker] Notification click:', event);
+  event.notification.close();
+  
+  event.waitUntil(
+    clients.openWindow('/')
+  );
+});
+
+console.log('[Custom ServiceWorker] Loaded successfully');
diff --git a/public/sw-register.js b/public/sw-register.js
index f2988d1..1527685 100644
--- a/public/sw-register.js
+++ b/public/sw-register.js
@@ -1,11 +1,50 @@
-// Manual Service Worker Registration for PWA
+// Improved Service Worker Registration for PWA
 if ('serviceWorker' in navigator) {
-  window.addEventListener('load', function() {
-    navigator.serviceWorker.register('/sw.js')
-      .then(function(registration) {
-        console.log('ServiceWorker registration successful with scope: ', registration.scope);
+  window.addEventListener('load', async function() {
+    console.log('Attempting to register service worker...');
+    
+    // First unregister any existing service workers to ensure clean state
+    try {
+      const registrations = await navigator.serviceWorker.getRegistrations();
+      for (const registration of registrations) {
+        console.log('Unregistering previous service worker');
+        await registration.unregister();
+      }
+      console.log('All previous service workers unregistered');
+    } catch (err) {
+      console.warn('Error unregistering existing service workers:', err);
+    }
+    
+    // Now register the service worker
+    const registerServiceWorker = async () => {
+      try {
+        // First try the Workbox-generated service worker
+        const registration = await navigator.serviceWorker.register('/sw.js', {
+          scope: '/',
+          updateViaCache: 'none' // Prevent caching issues
+        });
+        
+        console.log('ServiceWorker registration successful with scope:', registration.scope);
+        
+        // Force update check
+        registration.update();
+        
+        // Listen for updates
+        registration.addEventListener('updatefound', () => {
+          const newWorker = registration.installing;
+          console.log('New service worker is being installed');
+          
+          newWorker.addEventListener('statechange', () => {
+            console.log('Service worker state changed:', newWorker.state);
+          });
+        });
+        
+        // Handle messages from service worker
+        navigator.serviceWorker.addEventListener('message', function(event) {
+          console.log('Message from service worker:', event.data);
+        });
         
-        // Listen for new worker activation
+        // Set up refresh on controller change
         let refreshing = false;
         navigator.serviceWorker.addEventListener('controllerchange', function() {
           if (!refreshing) {
@@ -15,16 +54,32 @@ if ('serviceWorker' in navigator) {
           }
         });
         
-        // Handle messages from service worker
-        navigator.serviceWorker.addEventListener('message', function(event) {
-          if (event.data && event.data.type === 'CACHE_UPDATED') {
-            console.log('New content is available; please refresh.');
-            // Here you could show a notification to the user
-          }
-        });
-      })
-      .catch(function(error) {
-        console.error('ServiceWorker registration failed: ', error);
-      });
+        return registration;
+      } catch (err) {
+        console.error('Service worker registration failed:', err);
+        
+        // Try to fallback to custom service worker
+        try {
+          console.log('Attempting to register custom service worker...');
+          const registration = await navigator.serviceWorker.register('/custom-sw.js', {
+            scope: '/'
+          });
+          console.log('Custom service worker registration successful with scope:', registration.scope);
+          return registration;
+        } catch (fallbackErr) {
+          console.error('All service worker registration attempts failed:', fallbackErr);
+          throw fallbackErr;
+        }
+      }
+    };
+    
+    try {
+      await registerServiceWorker();
+      console.log('Service worker registration complete');
+    } catch (err) {
+      console.error('Service worker registration process failed:', err);
+    }
   });
+} else {
+  console.warn('Service workers are not supported by this browser');
 }
diff --git a/src/components/PwaUpdater.jsx b/src/components/PwaUpdater.jsx
index 1890817..6ededec 100644
--- a/src/components/PwaUpdater.jsx
+++ b/src/components/PwaUpdater.jsx
@@ -8,115 +8,114 @@ const PwaUpdater = () => {
   const [needsRefresh, setNeedsRefresh] = useState(false);
   const [swRegistration, setSwRegistration] = useState(null);
 
-  // Register service worker
+  // Monitor service worker updates rather than registering a new one
   useEffect(() => {
-    const registerSW = async () => {
+    const monitorSW = async () => {
       if ('serviceWorker' in navigator) {
         try {
-          // Try to register the service worker
-          const registration = await navigator.serviceWorker.register('/sw.js', {
-            scope: '/'
-          });
+          // Check for existing registrations
+          const registrations = await navigator.serviceWorker.getRegistrations();
           
-          console.log('Service Worker registered with scope:', registration.scope);
-          setSwRegistration(registration);
-          
-          // Handle updates
-          registration.addEventListener('updatefound', () => {
-            const newWorker = registration.installing;
-            console.log('Service Worker update found!');
+          if (registrations.length > 0) {
+            console.log('Found existing service worker registration');
+            const registration = registrations[0];
+            setSwRegistration(registration);
             
-            newWorker.addEventListener('statechange', () => {
-              if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
-                console.log('New content is available, please refresh.');
-                setNeedsRefresh(true);
-              }
-            });
-          });
-          
-          // Set up automatic checks for updates
-          const checkForUpdates = () => {
-            if (registration.update) {
-              registration.update().catch(err => {
-                console.error('Error checking for service worker updates:', err);
+            // Handle updates
+            registration.addEventListener('updatefound', () => {
+              const newWorker = registration.installing;
+              console.log('Service Worker update found!');
+              
+              newWorker.addEventListener('statechange', () => {
+                console.log('Service worker state:', newWorker.state);
+                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
+                  console.log('New content is available, please refresh.');
+                  setNeedsRefresh(true);
+                }
               });
-            }
-          };
-          
-          // Check for updates every hour
-          const updateInterval = setInterval(checkForUpdates, 60 * 60 * 1000);
-          
-          return () => {
-            clearInterval(updateInterval);
-          };
-          
+            });
+            
+            // Set up automatic checks for updates
+            const checkForUpdates = () => {
+              if (registration.update) {
+                console.log('Checking for service worker updates...');
+                registration.update().catch(err => {
+                  console.error('Error checking for service worker updates:', err);
+                });
+              }
+            };
+            
+            // Check for updates immediately and then every hour
+            checkForUpdates();
+            const updateInterval = setInterval(checkForUpdates, 60 * 60 * 1000);
+            
+            return () => {
+              clearInterval(updateInterval);
+            };
+          } else {
+            console.log('No existing service worker registration found');
+          }
         } catch (error) {
-          console.error('Service Worker registration failed:', error);
+          console.error('Error monitoring service worker:', error);
         }
       } else {
-        console.log('Service workers are not supported by this browser');
+        console.warn('Service workers not supported in this browser');
       }
     };
     
-    registerSW();
+    monitorSW();
   }, []);
 
-  // Handle update click
-  const handleUpdate = () => {
+  // Handler for the refresh button
+  const handleRefresh = () => {
     if (swRegistration && swRegistration.waiting) {
-      // Send message to service worker to skip waiting
+      // Send message to waiting service worker to skip waiting and become active
       swRegistration.waiting.postMessage({ type: 'SKIP_WAITING' });
+    } else {
+      // Fallback to regular page refresh
+      window.location.reload();
     }
-    
-    // Reload the page to apply the update
-    window.location.reload();
+    setNeedsRefresh(false);
   };
 
-  if (!needsRefresh) {
-    return null;
-  }
-
   return (
-    <div className="pwa-update-toast">
-      <div className="pwa-update-toast-content">
-        <p>A new version is available!</p>
-        <button onClick={handleUpdate}>Update & Refresh</button>
-        <button onClick={() => setNeedsRefresh(false)}>Dismiss</button>
-      </div>
-      <style jsx>{`
-        .pwa-update-toast {
-          position: fixed;
-          bottom: 20px;
-          right: 20px;
-          z-index: 9999;
-          background-color: #fff;
-          color: #333;
-          padding: 16px;
-          border-radius: 8px;
-          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
-          max-width: 300px;
-        }
-        .pwa-update-toast-content {
-          display: flex;
-          flex-direction: column;
-          gap: 8px;
-        }
-        button {
-          padding: 8px 16px;
-          border: none;
-          border-radius: 4px;
-          cursor: pointer;
-        }
-        button:first-of-type {
-          background-color: #4f46e5;
-          color: white;
-        }
-        button:last-of-type {
-          background-color: transparent;
-          color: #666;
-        }
-      `}</style>
-    </div>
+    <>
+      {needsRefresh && (
+        <div 
+          style={{
+            position: 'fixed',
+            bottom: '24px',
+            left: '24px',
+            right: '24px',
+            padding: '16px',
+            borderRadius: '4px',
+            backgroundColor: '#2563eb',
+            color: 'white',
+            boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1)',
+            display: 'flex',
+            justifyContent: 'space-between',
+            alignItems: 'center',
+            zIndex: 9999
+          }}
+        >
+          <p style={{ margin: 0 }}>New version available! Update to get the latest features.</p>
+          <button
+            onClick={handleRefresh}
+            style={{
+              backgroundColor: 'white',
+              color: '#2563eb',
+              border: 'none',
+              padding: '8px 16px',
+              borderRadius: '4px',
+              fontWeight: 'bold',
+              cursor: 'pointer'
+            }}
+          >
+            Refresh
+          </button>
+        </div>
+      )}
+    </>
   );
 };
 
diff --git a/src/pwa.js b/src/pwa.js
index ad2982a..ffde047 100644
--- a/src/pwa.js
+++ b/src/pwa.js
@@ -51,62 +51,58 @@ export class NetworkStatusMonitor {
     // Create notification element
     const notificationEl = document.createElement('div');
     notificationEl.className = `pwa-notification ${type}`;
-    notificationEl.innerHTML = `
-      <div class="pwa-notification-content">
-        <span>${message}</span>
-        <button class="pwa-notification-close"></button>
-      </div>
-    `;
+    notificationEl.textContent = message;
+    
+    // Style notification
+    Object.assign(notificationEl.style, {
+      position: 'fixed',
+      top: '20px',
+      right: '20px',
+      padding: '12px 20px',
+      borderRadius: '4px',
+      zIndex: 9999,
+      color: 'white',
+      backgroundColor: type === 'success' ? '#4caf50' : '#ff9800',
+      boxShadow: '0 2px 10px rgba(0,0,0,0.2)',
+      transition: 'all 0.5s ease-in-out'
+    });
     
     // Add to DOM
     document.body.appendChild(notificationEl);
     
-    // Set up close button
-    const closeButton = notificationEl.querySelector('.pwa-notification-close');
-    closeButton.addEventListener('click', () => {
-      notificationEl.remove();
-    });
-    
-    // Auto-remove after 5 seconds
+    // Remove after 3 seconds
     setTimeout(() => {
-      if (document.body.contains(notificationEl)) {
-        notificationEl.remove();
-      }
-    }, 5000);
-  }
-  
-  // Method to register sync function
-  registerSyncFunction(syncFunction) {
-    this.syncPendingData = syncFunction;
+      notificationEl.style.opacity = '0';
+      setTimeout(() => {
+        document.body.removeChild(notificationEl);
+      }, 500);
+    }, 3000);
   }
 }
 
 // Service Worker Management
 export class PWAManager {
   constructor() {
-    this.registerServiceWorker();
+    this.monitorServiceWorker();
   }
   
-  async registerServiceWorker() {
+  async monitorServiceWorker() {
     if ('serviceWorker' in navigator) {
       try {
-        const registration = await navigator.serviceWorker.register('/sw.js', {
-          scope: '/'
-        });
+        // Check for existing registrations first
+        const registrations = await navigator.serviceWorker.getRegistrations();
         
-        if (registration.installing) {
-          console.log('Service worker installing');
-        } else if (registration.waiting) {
-          console.log('Service worker installed');
-        } else if (registration.active) {
-          console.log('Service worker active');
+        if (registrations.length > 0) {
+          console.log('PWAManager: Found existing service worker registration');
+          // Use the existing registration
+          const registration = registrations[0];
+          this.setupPeriodicSync(registration);
+        } else {
+          console.log('PWAManager: No existing service worker found, not registering a new one');
+          // We'll rely on the sw-register.js script to handle registration
         }
-        
-        // Set up update checking
-        this.setupPeriodicSync(registration);
-        
       } catch (error) {
-        console.error('Service worker registration failed:', error);
+        console.error('PWAManager: Error while checking service worker registrations:', error);
       }
     }
   }
@@ -115,7 +111,7 @@ export class PWAManager {
     // Check for updates every hour
     setInterval(() => {
       registration.update();
-      console.log('Checking for service worker updates...');
+      console.log('PWAManager: Checking for service worker updates...');
     }, 60 * 60 * 1000);
     
     // Handle new updates
@@ -141,7 +137,7 @@ export function initializePWA() {
     // Start network status monitoring
     const networkMonitor = new NetworkStatusMonitor();
     
-    // Initialize service worker
+    // Initialize service worker monitoring (but not registration)
     const pwaManager = new PWAManager();
     
     return {
@@ -149,7 +145,6 @@ export function initializePWA() {
       pwaManager
     };
   }
-  return null;
 }
 
 // Default export for easy importing
```
