# Git Activity Log - Henry Koo
Generated at: Thu Mar 27 00:42:27 UTC 2025
## Changes by Henry Koo
```diff
commit 90bb3c73d5f0fbe915ce07a33643bc8c84810dc0
Author: Henrykoo <lckoo1230@gmail.com>
Date:   Wed Mar 26 17:28:27 2025 +0800

    new resizablePanel.tsx

diff --git a/public/data/cards.db b/public/data/cards.db
index 2ac22d5..1521b12 100644
Binary files a/public/data/cards.db and b/public/data/cards.db differ
diff --git a/public/data/cards.db-wal b/public/data/cards.db-wal
index 8f565fe..279134b 100644
Binary files a/public/data/cards.db-wal and b/public/data/cards.db-wal differ
diff --git a/src/components/ResizablePanel.tsx b/src/components/ResizablePanel.tsx
index f6cfb4e..c216be8 100644
--- a/src/components/ResizablePanel.tsx
+++ b/src/components/ResizablePanel.tsx
@@ -189,10 +189,34 @@ function ResizablePanelComponent({
 }
 
 export default function ResizablePanel(props: ResizablePanelProps) {
+  // Force an initial state access to ensure Redux state is available in DevTools
+  React.useEffect(() => {
+    // Use startTransition to avoid hydration errors
+    if (typeof window !== 'undefined') {
+      // Only run in browser environment
+      React.startTransition(() => {
+        const state = store.getState();
+        console.log('Redux state initialized in ResizablePanel:', {
+          theme: state.theme?.mode,
+          content: state.content ? 'Available' : 'Not available',
+          todo: state.todo ? 'Available' : 'Not available',
+          panels: state.panellayout ? 'Available' : 'Not available',
+          resizeable: state.resizeable?.currentLayout || 'default'
+        });
+        
+        // Dispatch a dummy action to make the state visible in DevTools
+        store.dispatch({ type: 'panels/initialized', payload: { timestamp: Date.now() } });
+      });
+    }
+  }, []);
+
+  // Wrap provider in React.StrictMode to help catch potential issues
   return (
-    <Provider store={store}>
-      <ResizablePanelComponent {...props} />
-    </Provider>
+    <React.StrictMode>
+      <Provider store={store}>
+        <ResizablePanelComponent {...props} />
+      </Provider>
+    </React.StrictMode>
   );
 }
 
diff --git a/src/components/panels/ContentDetailPanel.jsx b/src/components/panels/ContentDetailPanel.jsx
index ba6d481..8c59191 100644
--- a/src/components/panels/ContentDetailPanel.jsx
+++ b/src/components/panels/ContentDetailPanel.jsx
@@ -14,23 +14,19 @@ export default function ContentDetailPanel() {
   
   const dispatch = useDispatch();
   
-  // Extract useSelector calls outside of useMemo to follow Rules of Hooks
-  const state = useSelector(state => state || {});
-  const selectedHash = state?.content?.selectedHash;
+  // Use specific selectors that only return needed parts of state
+  const selectedHash = useSelector(state => state?.content?.selectedHash);
+  const cardsMap = useSelector(state => state?.content?.cards || {});
   
   // Memoize the calculated values, not the selector itself
   const selectedContentItem = useMemo(() => {
-    // Safely handle undefined state
-    const contentState = state.content || {};
-    const cards = contentState.cards || {};
-    
     // Find the card by hash - safely handle when cards is undefined or empty
-    if (selectedHash && cards) {
-      return Object.values(cards).find(c => c && c.hash === selectedHash) || null;
+    if (selectedHash && cardsMap) {
+      return Object.values(cardsMap).find(c => c && c.hash === selectedHash) || null;
     }
     
     return null;
-  }, [state, selectedHash]);
+  }, [cardsMap, selectedHash]);
 
   // Helper function to handle different content types
   const formatContent = (content) => {
diff --git a/src/components/panels/ItemDetailPanel.jsx b/src/components/panels/ItemDetailPanel.jsx
index d4c6616..85f2844 100644
--- a/src/components/panels/ItemDetailPanel.jsx
+++ b/src/components/panels/ItemDetailPanel.jsx
@@ -11,19 +11,15 @@ export default function ItemDetailPanel() {
   
   const dispatch = useDispatch();
   
-  // Extract useSelector calls outside of useMemo to follow Rules of Hooks
-  const state = useSelector(state => state || {});
-  const selectedHash = state?.content?.selectedHash;
+  // Use specific selectors that only return needed parts of state
+  const selectedHash = useSelector(state => state?.content?.selectedHash);
+  const cards = useSelector(state => state?.content?.cards || {});
   
   // Memoize the calculated values, not the selector itself
   const selectedContentItem = useMemo(() => {
-    // Safely handle undefined state
-    const contentState = state.content || {};
-    const cards = contentState.cards || {};
-    
     // Find the card by hash
     return selectedHash ? cards[selectedHash] : null;
-  }, [state, selectedHash]);
+  }, [cards, selectedHash]);
 
   // Helper function to handle different content types
   const formatContent = (content) => {
diff --git a/src/layouts/flexablePanelLayout.astro b/src/layouts/flexablePanelLayout.astro
index 287fac9..524f2c7 100644
--- a/src/layouts/flexablePanelLayout.astro
+++ b/src/layouts/flexablePanelLayout.astro
@@ -4,10 +4,16 @@ import JsonSidebar from '../components/JsonSidebar';
 import ResizablePanel from '../components/ResizablePanel';
 import { store } from '../store';
 
-const initialLayout = store.getState().resizeable.currentLayout || 'default';
+// Initialize all key state values
+const initialState = store.getState();
+const initialTheme = initialState.theme?.mode || 'light';
+const initialLayout = initialState.resizeable?.currentLayout || 'default';
+const contentState = initialState.content || {};
+const todoState = initialState.todo || {};
+const panelLayoutState = initialState.panellayout || {};
 ---
 
-<html lang="en">
+<html lang="en" class:list={[initialTheme, 'min-h-screen']}>
   <head>
     <meta charset="utf-8" />
     <meta name="viewport" content="width=device-width" />
@@ -38,8 +44,13 @@ const initialLayout = store.getState().resizeable.currentLayout || 'default';
         color: #666;
       }
     </style>
+    <script define:vars={{initialTheme}}>
+      // Ensure consistent theme on initial load
+      document.documentElement.classList.remove('light', 'dark');
+      document.documentElement.classList.add(initialTheme);
+    </script>
   </head>
-  <body>
+  <body class="min-h-screen bg-background text-foreground antialiased">
     <div class="app-container">
       <div class="sidebar-container">
         <JsonSidebar client:load />
@@ -49,14 +60,50 @@ const initialLayout = store.getState().resizeable.currentLayout || 'default';
           client:load
           useDefaultContent={true}
         />
+        <slot />
       </div>
     </div>
 
-    <script define:vars={{ initialLayout }}>
-      import { store } from '../store';
-
-      // Apply initial layout
-      console.log('Initial Layout:', initialLayout);
+    <!-- Use the is:inline type="module" syntax to properly define this as a module -->
+    <script is:inline type="module">
+      // Ensure Redux state is properly initialized
+      import { store } from '/src/store.js';
+      
+      // Apply initial theme and set up theme subscription
+      const initialTheme = store.getState().theme?.mode || 'light';
+      document.documentElement.classList.remove('light', 'dark');
+      document.documentElement.classList.add(initialTheme);
+      
+      // Subscribe to state changes using startTransition to prevent hydration errors
+      let isHydrated = false;
+      
+      // Wait for hydration to complete
+      setTimeout(() => {
+        isHydrated = true;
+        console.log('Hydration complete, safe to update state now');
+      }, 100);
+      
+      store.subscribe(() => {
+        // Only process state updates after hydration
+        if (!isHydrated) return;
+        
+        const state = store.getState();
+        
+        // Handle theme changes
+        const theme = state.theme?.mode;
+        if (theme) {
+          document.documentElement.classList.remove('light', 'dark');
+          document.documentElement.classList.add(theme);
+        }
+        
+        // Log state changes to help with debugging
+        console.log('Redux state updated', {
+          theme: state.theme?.mode,
+          content: state.content?.selectedHash ? 'Has selected content' : 'No selected content',
+          todo: Object.keys(state.todo || {}).length > 0 ? 'Has todos' : 'No todos',
+          layout: state.resizeable?.currentLayout
+        });
+      });
     </script>
   </body>
 </html>
diff --git a/src/pages/resizablePage.astro b/src/pages/resizablePage.astro
index 75ae7a4..ff4aed4 100644
--- a/src/pages/resizablePage.astro
+++ b/src/pages/resizablePage.astro
@@ -1,8 +1,7 @@
 ---
-import ResizablePanel from '../components/ResizablePanel';
 import ResizablePanelLayout from '../layouts/flexablePanelLayout.astro';
 
 ---
 
-<ResizablePanelLayout>  
+<ResizablePanelLayout>
 </ResizablePanelLayout>
\ No newline at end of file

commit 0189500c8b43df0e0ce2a01cea7956efeb3c6a2e
Author: Henrykoo <lckoo1230@gmail.com>
Date:   Wed Mar 26 16:43:58 2025 +0800

    working content detail

diff --git a/public/data/cards.db-wal b/public/data/cards.db-wal
index ec10155..8f565fe 100644
Binary files a/public/data/cards.db-wal and b/public/data/cards.db-wal differ
diff --git a/src/components/panels/ContentDetailPanel.jsx b/src/components/panels/ContentDetailPanel.jsx
index e99d705..ba6d481 100644
--- a/src/components/panels/ContentDetailPanel.jsx
+++ b/src/components/panels/ContentDetailPanel.jsx
@@ -13,23 +13,24 @@ export default function ContentDetailPanel() {
   const [editContent, setEditContent] = useState('');
   
   const dispatch = useDispatch();
-  // Using memoized selector to prevent unnecessary rerenders
-  const { selectedHash, selectedContentItem } = useSelector(state => {
-    const hash = state.content.selectedHash;
-    const cards = state.content.cards;
+  
+  // Extract useSelector calls outside of useMemo to follow Rules of Hooks
+  const state = useSelector(state => state || {});
+  const selectedHash = state?.content?.selectedHash;
+  
+  // Memoize the calculated values, not the selector itself
+  const selectedContentItem = useMemo(() => {
+    // Safely handle undefined state
+    const contentState = state.content || {};
+    const cards = contentState.cards || {};
     
-    // Find the card by iterating through cards
-    const card = Object.values(cards).find(c => c.hash === hash);
+    // Find the card by hash - safely handle when cards is undefined or empty
+    if (selectedHash && cards) {
+      return Object.values(cards).find(c => c && c.hash === selectedHash) || null;
+    }
     
-    return {
-      selectedHash: hash,
-      selectedContentItem: card
-    };
-  }, (prev, next) => {
-    // Custom equality function for shallow comparison of returned objects
-    return prev.selectedHash === next.selectedHash && 
-           prev.selectedContentItem === next.selectedContentItem;
-  });
+    return null;
+  }, [state, selectedHash]);
 
   // Helper function to handle different content types
   const formatContent = (content) => {
@@ -152,12 +153,11 @@ export default function ContentDetailPanel() {
       {/* Scrollable Content Area */}
       <div className="flex-1 overflow-auto">
         <ContentEditor
-          content={displayContent}
+          content={displayContent || ''}
           onChange={handleContentChange}
           onSave={isEditing ? handleSubmit : undefined}
           title={isEditing ? 'Edit Content' : 'Content Viewer'}
           isReadOnly={!isEditing}
-          theme={isEditing ? 'light' : 'dark'}
           showLineNumbers={true}
           language="Plain Text"
           className="h-full"
diff --git a/src/components/panels/ItemDetailPanel.jsx b/src/components/panels/ItemDetailPanel.jsx
index 7288d07..d4c6616 100644
--- a/src/components/panels/ItemDetailPanel.jsx
+++ b/src/components/panels/ItemDetailPanel.jsx
@@ -1,19 +1,59 @@
 'use client';
 
-import React, { useState } from 'react';
+import React, { useState, useEffect, useMemo } from 'react';
 import { useDispatch, useSelector } from 'react-redux';
-import { addTodo } from '../../features/todoSlice.js';
 import { addContent } from '../../features/contentSlice.js';
 import ContentEditor from '../ui/ContentEditor';
 
 export default function ItemDetailPanel() {
   const [isEditing, setIsEditing] = useState(false);
   const [editContent, setEditContent] = useState('');
-  const selectedTodoContent = useSelector(state => state.todo.selectedContent);
-  const selectedContentItem = useSelector(state => 
-    state.content.selectedId ? state.content.items[state.content.selectedId] : null
-  );
+  
   const dispatch = useDispatch();
+  
+  // Extract useSelector calls outside of useMemo to follow Rules of Hooks
+  const state = useSelector(state => state || {});
+  const selectedHash = state?.content?.selectedHash;
+  
+  // Memoize the calculated values, not the selector itself
+  const selectedContentItem = useMemo(() => {
+    // Safely handle undefined state
+    const contentState = state.content || {};
+    const cards = contentState.cards || {};
+    
+    // Find the card by hash
+    return selectedHash ? cards[selectedHash] : null;
+  }, [state, selectedHash]);
+
+  // Helper function to handle different content types
+  const formatContent = (content) => {
+    if (!content) return '';
+    
+    // If content is already a string, return it
+    if (typeof content === 'string') return content;
+    
+    // If it's an object (parsed JSON), stringify it for display
+    if (typeof content === 'object') {
+      try {
+        return JSON.stringify(content, null, 2);
+      } catch (e) {
+        console.error('Error stringifying content:', e);
+      }
+    }
+    
+    // Fallback: convert to string
+    return String(content);
+  };
+
+  // Effect to update content when a new card is selected
+  useEffect(() => {
+    if (selectedContentItem) {
+      setEditContent(formatContent(selectedContentItem.content));
+      setIsEditing(false);
+    } else {
+      setEditContent('');
+    }
+  }, [selectedContentItem]);
 
   const handleContentChange = (newContent) => {
     setEditContent(newContent);
@@ -21,8 +61,6 @@ export default function ItemDetailPanel() {
 
   const handleSubmit = () => {
     if (editContent.trim()) {
-      // Dispatch actions to both todo and content slices
-      dispatch(addTodo(editContent));
       dispatch(addContent(editContent));
       
       setEditContent('');
@@ -36,21 +74,24 @@ export default function ItemDetailPanel() {
   };
 
   const handleCancel = () => {
+    // Revert to original content if editing
+    if (selectedContentItem) {
+      setEditContent(formatContent(selectedContentItem.content));
+    }
     setIsEditing(false);
-    setEditContent('');
   };
 
   // Determine the content to display
   const displayContent = isEditing 
     ? editContent 
-    : (selectedTodoContent || (selectedContentItem?.content) || '');
+    : formatContent(selectedContentItem?.content);
 
   return (
     <div className="flex flex-col h-full">
       {/* Fixed Header */}
       <div className="flex-shrink-0 flex justify-between items-center px-4 py-2 bg-gray-100 border-b">
         <h2 className="text-lg font-semibold text-gray-700">
-          {isEditing ? 'Push New Content' : 'Item Details'}
+          {isEditing ? 'Edit Content' : 'Item Details'}
         </h2>
         <div className="flex gap-2">
           {!isEditing && (
@@ -58,7 +99,15 @@ export default function ItemDetailPanel() {
               onClick={handleNewClick}
               className="px-4 py-1 text-sm bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors"
             >
-              Push New Item
+              New Item
+            </button>
+          )}
+          {selectedContentItem && !isEditing && (
+            <button
+              onClick={() => setIsEditing(true)}
+              className="px-4 py-1 text-sm bg-yellow-500 text-white rounded hover:bg-yellow-600 transition-colors"
+            >
+              Edit
             </button>
           )}
           {isEditing && (
@@ -83,12 +132,11 @@ export default function ItemDetailPanel() {
       {/* Scrollable Content Area */}
       <div className="flex-1 overflow-auto">
         <ContentEditor
-          content={displayContent}
+          content={displayContent || ''}
           onChange={handleContentChange}
           onSave={isEditing ? handleSubmit : undefined}
           title={isEditing ? 'Edit Content' : 'Content Viewer'}
           isReadOnly={!isEditing}
-          theme={isEditing ? 'light' : 'dark'}
           showLineNumbers={true}
           language="Plain Text"
           className="h-full"
diff --git a/src/components/ui/ContentEditor.tsx b/src/components/ui/ContentEditor.tsx
index ece6377..9a71f7d 100644
--- a/src/components/ui/ContentEditor.tsx
+++ b/src/components/ui/ContentEditor.tsx
@@ -27,7 +27,15 @@ const ContentEditor: React.FC<ContentEditorProps> = ({
   const [localContent, setLocalContent] = useState(content);
   const contentLines = localContent.split('\n');
   const lineNumberWidth = contentLines.length.toString().length;
-  const themeMode = useSelector(selectThemeMode);
+  
+  // Safely access theme mode with fallback
+  const themeMode = useSelector((state: any) => {
+    try {
+      return state?.theme?.mode || 'light';
+    } catch (e) {
+      return 'light';
+    }
+  });
   const isDark = themeMode === 'dark';
 
   // Update local content when prop changes
diff --git a/src/features/resizeable.json b/src/features/resizeable.json
index 9fc3fe6..e5a6878 100644
--- a/src/features/resizeable.json
+++ b/src/features/resizeable.json
@@ -25,7 +25,7 @@
     },
     "minimal": {
       "components": [
-        "DatabaseRetrievePanel","ItemDetailPanel"
+        "DatabaseRetrievePanel","ContentDetailPanel"
       ]
     },
     "expandedtest": {

commit 18ca4424df9173f68042339cd4267abdb97dc1cd
Author: Henrykoo <lckoo1230@gmail.com>
Date:   Wed Mar 26 16:03:09 2025 +0800

    workin

diff --git a/public/data/cards.db-wal b/public/data/cards.db-wal
index 10196a1..ec10155 100644
Binary files a/public/data/cards.db-wal and b/public/data/cards.db-wal differ
diff --git a/src/components/panels/ContentDetail.jsx b/src/components/panels/ContentDetail.jsx
deleted file mode 100644
index 277b343..0000000
--- a/src/components/panels/ContentDetail.jsx
+++ /dev/null
@@ -1,65 +0,0 @@
-import React from 'react';
-
-export function ContentDetail() {
-  console.log('[ContentDetail] Rendering');
-  
-  return (
-    <div style={{
-      padding: '1rem',
-      backgroundColor: '#ffffff',
-      height: '100%',
-      border: '1px solid #ddd'
-    }}>
-      <h2 style={{ margin: '0 0 1rem 0', color: '#333' }}>Content Detail</h2>
-      <p style={{ margin: '0.5rem 0', color: '#666' }}>
-        View and edit content details here
-      </p>
-      <div style={{
-        marginTop: '1rem',
-        padding: '1rem',
-        backgroundColor: '#f5f5f5',
-        borderRadius: '4px',
-        display: 'flex',
-        flexDirection: 'column',
-        gap: '1rem'
-      }}>
-        {Array(2).fill(0).map((_, i) => (
-          <div key={i} style={{
-            background: 'white',
-            padding: '1rem',
-            borderRadius: '4px',
-            boxShadow: '0 1px 3px rgba(0, 0, 0, 0.1)'
-          }}>
-            <h3 style={{ margin: '0 0 0.5rem 0', color: '#333' }}>
-              Content Item {i + 1}
-            </h3>
-            <p style={{ margin: '0 0 1rem 0', color: '#666' }}>
-              Details for content item {i + 1}
-            </p>
-            <div style={{
-              display: 'flex',
-              gap: '1rem',
-              fontSize: '0.875rem',
-              color: '#888'
-            }}>
-              <span style={{
-                background: '#f0f0f0',
-                padding: '0.25rem 0.5rem',
-                borderRadius: '4px'
-              }}>
-                Created: 2025-02-{String(i + 1).padStart(2, '0')}
-              </span>
-              <span style={{
-                background: '#f0f0f0',
-                padding: '0.25rem 0.5rem',
-                borderRadius: '4px'
-              }}>
-                Status: {i % 2 === 0 ? 'Active' : 'Draft'}
-              </span>
-            </div>
-          </div>
-        ))}
-      </div>
-    </div>
-  );
-}
\ No newline at end of file
diff --git a/src/components/panels/ContentDetailPanel.jsx b/src/components/panels/ContentDetailPanel.jsx
index 4a8345f..e99d705 100644
--- a/src/components/panels/ContentDetailPanel.jsx
+++ b/src/components/panels/ContentDetailPanel.jsx
@@ -31,10 +31,30 @@ export default function ContentDetailPanel() {
            prev.selectedContentItem === next.selectedContentItem;
   });
 
+  // Helper function to handle different content types
+  const formatContent = (content) => {
+    if (!content) return '';
+    
+    // If content is already a string, return it
+    if (typeof content === 'string') return content;
+    
+    // If it's an object (parsed JSON), stringify it for display
+    if (typeof content === 'object') {
+      try {
+        return JSON.stringify(content, null, 2);
+      } catch (e) {
+        console.error('Error stringifying content:', e);
+      }
+    }
+    
+    // Fallback: convert to string
+    return String(content);
+  };
+
   // Effect to update content when a new card is selected
   useEffect(() => {
     if (selectedContentItem) {
-      setEditContent(selectedContentItem.content);
+      setEditContent(formatContent(selectedContentItem.content));
       setIsEditing(false);
     } else {
       setEditContent('');
@@ -62,7 +82,7 @@ export default function ContentDetailPanel() {
   const handleCancel = () => {
     // Revert to original content if editing
     if (selectedContentItem) {
-      setEditContent(selectedContentItem.content);
+      setEditContent(formatContent(selectedContentItem.content));
     }
     setIsEditing(false);
   };
@@ -76,7 +96,7 @@ export default function ContentDetailPanel() {
   // Determine the content to display
   const displayContent = isEditing 
     ? editContent 
-    : (selectedContentItem?.content || '');
+    : formatContent(selectedContentItem?.content);
 
   return (
     <div className="flex flex-col h-full">
diff --git a/src/components/panels/DatabaseRetrievePanel.tsx b/src/components/panels/DatabaseRetrievePanel.tsx
index e9bf5a0..bc9baa7 100644
--- a/src/components/panels/DatabaseRetrievePanel.tsx
+++ b/src/components/panels/DatabaseRetrievePanel.tsx
@@ -1,9 +1,8 @@
 import React, { useState, useEffect } from 'react';
-import { Panel, PanelGroup, PanelResizeHandle } from 'react-resizable-panels';
 import { ContentTypeInterpreter } from '../../content/model/interpreter';
 import { MCardFromData } from '../../content/model/mcard';
 import { useDispatch } from 'react-redux';
-import { importCardFromDatabase, updateContent } from '../../features/contentSlice';
+import { importCardFromDatabase, selectContent } from '../../features/contentSlice';
 
 interface PageData {
   items: MCardFromData[];
@@ -35,14 +34,7 @@ export const DatabaseRetrievePanel: React.FC = () => {
   const [pageSize, setPageSize] = useState(10);
   const [searchTerm, setSearchTerm] = useState('');
   const [hashValue, setHashValue] = useState('');
-  const [selectedCard, setSelectedCard] = useState<MCardFromData | null>(null);
-  const [viewMode, setViewMode] = useState<'raw' | 'formatted' | 'edit'>('formatted');
-  const [panelSizes, setPanelSizes] = useState([50, 50]); // Initial split for card list and details
-  const [editableContent, setEditableContent] = useState<string>('');
-  const [updateStatus, setUpdateStatus] = useState<{
-    status: 'idle' | 'loading' | 'success' | 'error';
-    message: string;
-  }>({ status: 'idle', message: '' });
+  const [selectedCardHash, setSelectedCardHash] = useState<string | null>(null);
 
   // Function to fetch cards
   const fetchCards = async (params: {
@@ -74,7 +66,7 @@ export const DatabaseRetrievePanel: React.FC = () => {
       setCards(data);
       
       // Clear selected card when fetching new cards
-      setSelectedCard(null);
+      setSelectedCardHash(null);
     } catch (err) {
       setError(err instanceof Error ? err.message : 'An unknown error occurred');
       console.error('Error fetching cards:', err);
@@ -115,152 +107,24 @@ export const DatabaseRetrievePanel: React.FC = () => {
     }
   };
 
-  // Handle viewing card details
-  const handleViewCard = (card: MCardFromData) => {
-    setSelectedCard(card);
-    setViewMode('formatted');
+  // Handle selecting a card
+  const handleSelectCard = (card: MCardFromData) => {
+    setSelectedCardHash(card.hash);
     
-    // Convert card content to string for editing
-    if (typeof card.content === 'object') {
-      setEditableContent(JSON.stringify(card.content, null, 2));
-    } else {
-      setEditableContent(String(card.content));
-    }
-  };
-
-  // Handle entering edit mode
-  const handleEditCard = () => {
-    setViewMode('edit');
-  };
-
-  // Handle content changes in edit mode
-  const handleContentChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
-    setEditableContent(e.target.value);
-  };
-
-  // Handle saving the edited content
-  const handleSaveContent = async () => {
-    if (!selectedCard) return;
-    
-    setUpdateStatus({ status: 'loading', message: 'Updating card...' });
-    
-    try {
-      // Parse content if it's JSON
-      let parsedContent: any = editableContent;
-      const contentType = detectContentType(selectedCard);
-      
-      // Check if we're dealing with JSON content
-      const isJsonContent = 
-        (contentType && 'mimeType' in contentType && contentType.mimeType === 'application/json') ||
-        (typeof selectedCard.content === 'object');
-      
-      if (isJsonContent) {
-        try {
-          parsedContent = JSON.parse(editableContent);
-        } catch (e) {
-          throw new Error('Invalid JSON format');
-        }
-      }
-      
-      // First, update card in local Redux store
-      dispatch(updateContent({
-        hash: selectedCard.hash,
-        content: parsedContent
-      }));
-      
-      // Also import the card into the local Redux state
-      dispatch(importCardFromDatabase({
-        card: {
-          hash: selectedCard.hash,
-          content: parsedContent
-        }
-      }));
-      
-      // Then update in the database
-      const response = await fetch('/api/update-card', {
-        method: 'POST',
-        headers: {
-          'Content-Type': 'application/json',
-        },
-        body: JSON.stringify({
-          hash: selectedCard.hash,
-          content: parsedContent
-        }),
-      });
-      
-      if (!response.ok) {
-        const errorData = await response.json();
-        throw new Error(errorData.error || 'Failed to update card');
-      }
-      
-      // Update the selected card in state by fetching it again
-      fetchCards({ hash: selectedCard.hash });
-      
-      setUpdateStatus({ status: 'success', message: 'Card updated successfully!' });
-      setViewMode('formatted');
-    } catch (err) {
-      setUpdateStatus({ 
-        status: 'error', 
-        message: err instanceof Error ? err.message : 'Failed to update card' 
-      });
-      console.error('Error updating card:', err);
-    }
-  };
-
-  // Cancel editing
-  const handleCancelEdit = () => {
-    // Reset editable content to the original
-    if (selectedCard) {
-      if (typeof selectedCard.content === 'object') {
-        setEditableContent(JSON.stringify(selectedCard.content, null, 2));
-      } else {
-        setEditableContent(String(selectedCard.content));
+    // Import the card to Redux store
+    dispatch(importCardFromDatabase({ 
+      hash: card.hash,
+      content: card.content,
+      metadata: {},
+      relationships: {
+        parentHash: null,
+        childHashes: [],
+        relatedHashes: []
       }
-    }
-    setViewMode('formatted');
-    setUpdateStatus({ status: 'idle', message: '' });
-  };
-
-  // Helper function to format content based on type
-  const formatContent = (content: any): string => {
-    if (typeof content === 'object') {
-      return JSON.stringify(content, null, 2);
-    }
-    return String(content);
-  };
-
-  // Helper function to detect content type
-  const detectContentType = (card: MCardFromData): ContentType => {
-    // First try to use the card's native content type if available
-    if (card._content_type) {
-      return card._content_type as ContentType;
-    }
-    
-    // Fallback to static detection
-    const result = ContentTypeInterpreter.detectContentType(card.content);
-    
-    // Convert to standardized ContentType
-    if (typeof result === 'object' && result !== null) {
-      return result as ContentType;
-    }
+    }));
     
-    // Default fallback
-    return { mimeType: 'text/plain' };
-  };
-
-  // Helper function to get a display label for content type
-  const getContentTypeLabel = (contentType: ContentType | null) => {
-    if (!contentType) return 'Unknown';
-    
-    // Handle different content type structures
-    if (contentType.mimeType) {
-      const mime = contentType.mimeType;
-      const ext = contentType.extension || '';
-      return `${mime}${ext ? ` (.${ext})` : ''}`;
-    }
-    
-    // Fallback to string representation
-    return 'Unknown Content Type';
+    // Select the card in Redux
+    dispatch(selectContent(card.hash));
   };
 
   // Helper function to format date
@@ -341,109 +205,105 @@ export const DatabaseRetrievePanel: React.FC = () => {
   };
 
   return (
-    <PanelGroup direction="horizontal" className="h-full w-full">
-      <Panel 
-        defaultSize={panelSizes[0]} 
-        minSize={20} 
-        className="bg-white shadow-md rounded-lg p-6 overflow-auto"
-      >
-        {/* Search and Hash Lookup Forms */}
-        <div className="flex flex-col md:flex-row gap-4 mb-6">
-          <form onSubmit={handleSearch} className="flex-1">
-            <div className="flex flex-col md:flex-row gap-2">
-              <input
-                type="text"
-                value={searchTerm}
-                onChange={(e) => setSearchTerm(e.target.value)}
-                placeholder="Search by content..."
-                className="flex-1 px-4 py-2 border rounded"
-              />
-              <button
-                type="submit"
-                className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
-                disabled={loading}
-              >
-                Search
-              </button>
-            </div>
-          </form>
-
-          <form onSubmit={handleHashLookup} className="flex-1">
-            <div className="flex flex-col md:flex-row gap-2">
-              <input
-                type="text"
-                value={hashValue}
-                onChange={(e) => setHashValue(e.target.value)}
-                placeholder="Lookup by hash..."
-                className="flex-1 px-4 py-2 border rounded"
-              />
-              <button
-                type="submit"
-                className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600"
-                disabled={loading}
-              >
-                Lookup
-              </button>
-            </div>
-          </form>
-        </div>
-
-        {/* Reset and Page Size Controls */}
-        <div className="flex flex-col md:flex-row justify-between items-center mb-6">
-          <button
-            onClick={() => {
-              setSearchTerm('');
-              setHashValue('');
-              setPage(1);
-              fetchCards({ page: 1, pageSize });
-            }}
-            className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 mb-2 md:mb-0"
-            disabled={loading}
-          >
-            Reset
-          </button>
-          
-          <div className="flex items-center">
-            <span className="mr-2">Items per page:</span>
-            <select
-              value={pageSize}
-              onChange={(e) => {
-                const newSize = Number(e.target.value);
-                setPageSize(newSize);
-                setPage(1); // Reset to first page when changing page size
-                
-                // Refetch with new page size
-                if (searchTerm) {
-                  fetchCards({ search: searchTerm, page: 1, pageSize: newSize });
-                } else {
-                  fetchCards({ page: 1, pageSize: newSize });
-                }
-              }}
-              className="px-2 py-1 border rounded"
+    <div className="flex flex-col h-full overflow-auto bg-white shadow-md rounded-lg">
+      {/* Search and Hash Lookup Forms */}
+      <div className="flex flex-col md:flex-row gap-4 p-6 border-b">
+        <form onSubmit={handleSearch} className="flex-1">
+          <div className="flex flex-col md:flex-row gap-2">
+            <input
+              type="text"
+              value={searchTerm}
+              onChange={(e) => setSearchTerm(e.target.value)}
+              placeholder="Search by content..."
+              className="flex-1 px-4 py-2 border rounded"
+            />
+            <button
+              type="submit"
+              className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
+              disabled={loading}
+            >
+              Search
+            </button>
+          </div>
+        </form>
+
+        <form onSubmit={handleHashLookup} className="flex-1">
+          <div className="flex flex-col md:flex-row gap-2">
+            <input
+              type="text"
+              value={hashValue}
+              onChange={(e) => setHashValue(e.target.value)}
+              placeholder="Lookup by hash..."
+              className="flex-1 px-4 py-2 border rounded"
+            />
+            <button
+              type="submit"
+              className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600"
+              disabled={loading}
             >
-              <option value="5">5</option>
-              <option value="10">10</option>
-              <option value="20">20</option>
-              <option value="50">50</option>
-            </select>
+              Lookup
+            </button>
           </div>
+        </form>
+      </div>
+
+      {/* Reset and Page Size Controls */}
+      <div className="flex flex-col md:flex-row justify-between items-center p-4 border-b">
+        <button
+          onClick={() => {
+            setSearchTerm('');
+            setHashValue('');
+            setPage(1);
+            fetchCards({ page: 1, pageSize });
+          }}
+          className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 mb-2 md:mb-0"
+          disabled={loading}
+        >
+          Reset
+        </button>
+        
+        <div className="flex items-center">
+          <span className="mr-2">Items per page:</span>
+          <select
+            value={pageSize}
+            onChange={(e) => {
+              const newSize = Number(e.target.value);
+              setPageSize(newSize);
+              setPage(1); // Reset to first page when changing page size
+              
+              // Refetch with new page size
+              if (searchTerm) {
+                fetchCards({ search: searchTerm, page: 1, pageSize: newSize });
+              } else {
+                fetchCards({ page: 1, pageSize: newSize });
+              }
+            }}
+            className="px-2 py-1 border rounded"
+          >
+            <option value="5">5</option>
+            <option value="10">10</option>
+            <option value="20">20</option>
+            <option value="50">50</option>
+          </select>
         </div>
+      </div>
 
-        {/* Error Display */}
-        {error && (
-          <div className="bg-red-100 border-l-4 border-red-500 text-red-700 p-4 mb-6">
-            <p>{error}</p>
-          </div>
-        )}
+      {/* Error Display */}
+      {error && (
+        <div className="bg-red-100 border-l-4 border-red-500 text-red-700 p-4 mx-6 my-4">
+          <p>{error}</p>
+        </div>
+      )}
 
-        {/* Loading Indicator */}
-        {loading && (
-          <div className="flex justify-center mb-6">
-            <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-blue-500"></div>
-          </div>
-        )}
+      {/* Loading Indicator */}
+      {loading && (
+        <div className="flex justify-center p-6">
+          <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-blue-500"></div>
+        </div>
+      )}
 
-        {/* Card List */}
+      {/* Card List */}
+      <div className="flex-1 overflow-auto p-6">
         {cards && cards.items.length > 0 ? (
           <div>
             {/* Results Summary */}
@@ -460,8 +320,8 @@ export const DatabaseRetrievePanel: React.FC = () => {
               {cards.items.map((card) => (
                 <div
                   key={card.hash}
-                  className={`border rounded p-4 cursor-pointer hover:bg-gray-50 ${selectedCard?.hash === card.hash ? 'bg-blue-50 border-blue-300' : ''}`}
-                  onClick={() => handleViewCard(card)}
+                  className={`border rounded p-4 cursor-pointer hover:bg-gray-50 ${selectedCardHash === card.hash ? 'bg-blue-50 border-blue-300' : ''}`}
+                  onClick={() => handleSelectCard(card)}
                 >
                   <div className="flex justify-between mb-2">
                     <span className="font-medium text-blue-600">
@@ -561,160 +421,7 @@ export const DatabaseRetrievePanel: React.FC = () => {
             </div>
           )
         )}
-      </Panel>
-
-      <PanelResizeHandle 
-        className="w-2 bg-gray-200 hover:bg-gray-300 transition-colors cursor-col-resize" 
-      />
-
-      <Panel 
-        defaultSize={panelSizes[1]} 
-        minSize={20} 
-        className="bg-white shadow-md rounded-lg p-6 overflow-auto"
-      >
-        {/* Selected Card Detail View */}
-        {selectedCard ? (
-          <div>
-            <h3 className="text-xl font-semibold mb-4">Card Details</h3>
-            
-            <div className="mb-4">
-              <div className="flex justify-between">
-                <div>
-                  <span className="font-medium">Hash: </span>
-                  <span className="font-mono">{selectedCard.hash}</span>
-                </div>
-                <div className="flex gap-2">
-                  {viewMode !== 'edit' && (
-                    <button
-                      onClick={handleEditCard}
-                      className="px-3 py-1 text-sm bg-yellow-100 text-yellow-800 rounded hover:bg-yellow-200"
-                    >
-                      Edit
-                    </button>
-                  )}
-                  {viewMode !== 'edit' && (
-                    <button
-                      onClick={() => setViewMode(viewMode === 'raw' ? 'formatted' : 'raw')}
-                      className="px-3 py-1 text-sm bg-gray-200 rounded hover:bg-gray-300"
-                    >
-                      {viewMode === 'raw' ? 'Formatted View' : 'Raw View'}
-                    </button>
-                  )}
-                </div>
-              </div>
-            </div>
-            
-            <div className="mb-4">
-              <span className="font-medium">Created: </span>
-              <span>{formatDate(getCardTimestamp(selectedCard))}</span>
-            </div>
-            
-            <div className="mb-4">
-              <span className="font-medium">Content Type: </span>
-              <span>{getContentTypeLabel(detectContentType(selectedCard))}</span>
-            </div>
-            
-            {/* Update Status Message */}
-            {updateStatus.status !== 'idle' && (
-              <div className={`mb-4 p-3 rounded ${
-                updateStatus.status === 'loading' ? 'bg-blue-100 text-blue-800' :
-                updateStatus.status === 'success' ? 'bg-green-100 text-green-800' :
-                'bg-red-100 text-red-800'
-              }`}>
-                {updateStatus.message}
-              </div>
-            )}
-            
-            <div className="mb-4">
-              <div className="font-medium mb-2">Content:</div>
-              {viewMode === 'edit' ? (
-                <div>
-                  <textarea
-                    value={editableContent}
-                    onChange={handleContentChange}
-                    className="w-full h-64 font-mono text-sm p-4 border rounded"
-                  />
-                  <div className="flex justify-end gap-2 mt-2">
-                    <button
-                      onClick={handleCancelEdit}
-                      className="px-4 py-2 bg-gray-200 text-gray-800 rounded hover:bg-gray-300"
-                    >
-                      Cancel
-                    </button>
-                    <button
-                      onClick={handleSaveContent}
-                      className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600"
-                      disabled={updateStatus.status === 'loading'}
-                    >
-                      Save Changes
-                    </button>
-                  </div>
-                </div>
-              ) : (
-                <pre className="bg-gray-100 p-4 rounded overflow-auto max-h-96 font-mono text-sm">
-                  {viewMode === 'raw' 
-                    ? typeof selectedCard.content === 'object' 
-                      ? JSON.stringify(selectedCard.content)
-                      : String(selectedCard.content)
-                    : formatContent(selectedCard.content)
-                  }
-                </pre>
-              )}
-            </div>
-            
-            {viewMode !== 'edit' && (
-              <div className="mt-2 flex gap-2">
-                <button
-                  onClick={() => {
-                    const content = typeof selectedCard.content === 'object' 
-                      ? JSON.stringify(selectedCard.content, null, 2)
-                      : String(selectedCard.content);
-                    navigator.clipboard.writeText(content);
-                    alert('Content copied to clipboard!');
-                  }}
-                  className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
-                >
-                  Copy Content
-                </button>
-                <button
-                  onClick={() => {
-                    navigator.clipboard.writeText(selectedCard.hash);
-                    alert('Hash copied to clipboard!');
-                  }}
-                  className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600"
-                >
-                  Copy Hash
-                </button>
-                <button
-                  onClick={() => {
-                    // Import the card into Redux
-                    dispatch(importCardFromDatabase({ 
-                      card: {
-                        hash: selectedCard.hash,
-                        content: selectedCard.content,
-                        metadata: {},
-                        relationships: {
-                          parentHash: null,
-                          childHashes: [],
-                          relatedHashes: []
-                        }
-                      }
-                    }));
-                    alert('Card imported to local state!');
-                  }}
-                  className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600"
-                >
-                  Import to Redux
-                </button>
-              </div>
-            )}
-          </div>
-        ) : (
-          <div className="flex items-center justify-center h-full text-gray-500">
-            Select a card to view details
-          </div>
-        )}
-      </Panel>
-    </PanelGroup>
+      </div>
+    </div>
   );
 };
diff --git a/src/features/panellayoutSlice.json b/src/features/panellayoutSlice.json
index 3683318..b5343b8 100644
--- a/src/features/panellayoutSlice.json
+++ b/src/features/panellayoutSlice.json
@@ -33,7 +33,7 @@
             "visible": true
         },
         "right": {
-            "type": "ActionLogPanelReact",
+            "type": "DatabaseRetrievePanel",
             "size": 30,
             "minSize": 20,
             "visible": true
diff --git a/src/features/resizeable.json b/src/features/resizeable.json
index 17e0a12..9fc3fe6 100644
--- a/src/features/resizeable.json
+++ b/src/features/resizeable.json
@@ -25,7 +25,7 @@
     },
     "minimal": {
       "components": [
-        "DatabaseRetrievePanel"
+        "DatabaseRetrievePanel","ItemDetailPanel"
       ]
     },
     "expandedtest": {

commit 5f8766972192de191a86b65f869665324428ceb0
Author: Henrykoo <lckoo1230@gmail.com>
Date:   Wed Mar 26 15:03:15 2025 +0800

    content

diff --git a/src/components/Content.jsx b/src/components/Content.jsx
index 9c2f69b..c38dd99 100644
--- a/src/components/Content.jsx
+++ b/src/components/Content.jsx
@@ -41,6 +41,20 @@ const Content = () => {
           filteredContent.map(card => {
             if (!card) return null;
             
+            // Convert content to a string safely
+            const contentPreview = (() => {
+              if (!card.content) return 'No content';
+              
+              let contentString;
+              if (typeof card.content === 'object') {
+                contentString = JSON.stringify(card.content);
+              } else {
+                contentString = String(card.content);
+              }
+              
+              return contentString.substring(0, 200);
+            })();
+
             return (
               <div 
                 key={card.hash} 
@@ -54,7 +68,7 @@ const Content = () => {
                   onClick={() => handleContentSelect(card.hash)}
                   className="cursor-pointer mb-2 dark:text-neutral-100"
                 >
-                  {card.content.substring(0, 200)}...
+                  {contentPreview}...
                 </div>
 
                 {/* Metadata and Actions */}
diff --git a/src/components/panels/DatabaseRetrievePanel.tsx b/src/components/panels/DatabaseRetrievePanel.tsx
index c129edc..e9bf5a0 100644
--- a/src/components/panels/DatabaseRetrievePanel.tsx
+++ b/src/components/panels/DatabaseRetrievePanel.tsx
@@ -2,6 +2,8 @@ import React, { useState, useEffect } from 'react';
 import { Panel, PanelGroup, PanelResizeHandle } from 'react-resizable-panels';
 import { ContentTypeInterpreter } from '../../content/model/interpreter';
 import { MCardFromData } from '../../content/model/mcard';
+import { useDispatch } from 'react-redux';
+import { importCardFromDatabase, updateContent } from '../../features/contentSlice';
 
 interface PageData {
   items: MCardFromData[];
@@ -17,7 +19,15 @@ interface PageData {
   retrievalMethod?: string;
 }
 
+// Interface to better represent the content type
+interface ContentType {
+  mimeType?: string;
+  extension?: string;
+  isValid?: boolean;
+}
+
 export const DatabaseRetrievePanel: React.FC = () => {
+  const dispatch = useDispatch();
   const [cards, setCards] = useState<PageData | null>(null);
   const [loading, setLoading] = useState(false);
   const [error, setError] = useState<string | null>(null);
@@ -26,8 +36,13 @@ export const DatabaseRetrievePanel: React.FC = () => {
   const [searchTerm, setSearchTerm] = useState('');
   const [hashValue, setHashValue] = useState('');
   const [selectedCard, setSelectedCard] = useState<MCardFromData | null>(null);
-  const [viewMode, setViewMode] = useState<'raw' | 'formatted'>('formatted');
+  const [viewMode, setViewMode] = useState<'raw' | 'formatted' | 'edit'>('formatted');
   const [panelSizes, setPanelSizes] = useState([50, 50]); // Initial split for card list and details
+  const [editableContent, setEditableContent] = useState<string>('');
+  const [updateStatus, setUpdateStatus] = useState<{
+    status: 'idle' | 'loading' | 'success' | 'error';
+    message: string;
+  }>({ status: 'idle', message: '' });
 
   // Function to fetch cards
   const fetchCards = async (params: {
@@ -103,6 +118,107 @@ export const DatabaseRetrievePanel: React.FC = () => {
   // Handle viewing card details
   const handleViewCard = (card: MCardFromData) => {
     setSelectedCard(card);
+    setViewMode('formatted');
+    
+    // Convert card content to string for editing
+    if (typeof card.content === 'object') {
+      setEditableContent(JSON.stringify(card.content, null, 2));
+    } else {
+      setEditableContent(String(card.content));
+    }
+  };
+
+  // Handle entering edit mode
+  const handleEditCard = () => {
+    setViewMode('edit');
+  };
+
+  // Handle content changes in edit mode
+  const handleContentChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
+    setEditableContent(e.target.value);
+  };
+
+  // Handle saving the edited content
+  const handleSaveContent = async () => {
+    if (!selectedCard) return;
+    
+    setUpdateStatus({ status: 'loading', message: 'Updating card...' });
+    
+    try {
+      // Parse content if it's JSON
+      let parsedContent: any = editableContent;
+      const contentType = detectContentType(selectedCard);
+      
+      // Check if we're dealing with JSON content
+      const isJsonContent = 
+        (contentType && 'mimeType' in contentType && contentType.mimeType === 'application/json') ||
+        (typeof selectedCard.content === 'object');
+      
+      if (isJsonContent) {
+        try {
+          parsedContent = JSON.parse(editableContent);
+        } catch (e) {
+          throw new Error('Invalid JSON format');
+        }
+      }
+      
+      // First, update card in local Redux store
+      dispatch(updateContent({
+        hash: selectedCard.hash,
+        content: parsedContent
+      }));
+      
+      // Also import the card into the local Redux state
+      dispatch(importCardFromDatabase({
+        card: {
+          hash: selectedCard.hash,
+          content: parsedContent
+        }
+      }));
+      
+      // Then update in the database
+      const response = await fetch('/api/update-card', {
+        method: 'POST',
+        headers: {
+          'Content-Type': 'application/json',
+        },
+        body: JSON.stringify({
+          hash: selectedCard.hash,
+          content: parsedContent
+        }),
+      });
+      
+      if (!response.ok) {
+        const errorData = await response.json();
+        throw new Error(errorData.error || 'Failed to update card');
+      }
+      
+      // Update the selected card in state by fetching it again
+      fetchCards({ hash: selectedCard.hash });
+      
+      setUpdateStatus({ status: 'success', message: 'Card updated successfully!' });
+      setViewMode('formatted');
+    } catch (err) {
+      setUpdateStatus({ 
+        status: 'error', 
+        message: err instanceof Error ? err.message : 'Failed to update card' 
+      });
+      console.error('Error updating card:', err);
+    }
+  };
+
+  // Cancel editing
+  const handleCancelEdit = () => {
+    // Reset editable content to the original
+    if (selectedCard) {
+      if (typeof selectedCard.content === 'object') {
+        setEditableContent(JSON.stringify(selectedCard.content, null, 2));
+      } else {
+        setEditableContent(String(selectedCard.content));
+      }
+    }
+    setViewMode('formatted');
+    setUpdateStatus({ status: 'idle', message: '' });
   };
 
   // Helper function to format content based on type
@@ -114,18 +230,26 @@ export const DatabaseRetrievePanel: React.FC = () => {
   };
 
   // Helper function to detect content type
-  const detectContentType = (card: MCardFromData) => {
+  const detectContentType = (card: MCardFromData): ContentType => {
     // First try to use the card's native content type if available
     if (card._content_type) {
-      return card._content_type;
+      return card._content_type as ContentType;
     }
     
     // Fallback to static detection
-    return ContentTypeInterpreter.detectContentType(card.content);
+    const result = ContentTypeInterpreter.detectContentType(card.content);
+    
+    // Convert to standardized ContentType
+    if (typeof result === 'object' && result !== null) {
+      return result as ContentType;
+    }
+    
+    // Default fallback
+    return { mimeType: 'text/plain' };
   };
 
   // Helper function to get a display label for content type
-  const getContentTypeLabel = (contentType: any) => {
+  const getContentTypeLabel = (contentType: ContentType | null) => {
     if (!contentType) return 'Unknown';
     
     // Handle different content type structures
@@ -136,7 +260,7 @@ export const DatabaseRetrievePanel: React.FC = () => {
     }
     
     // Fallback to string representation
-    return String(contentType);
+    return 'Unknown Content Type';
   };
 
   // Helper function to format date
@@ -336,7 +460,7 @@ export const DatabaseRetrievePanel: React.FC = () => {
               {cards.items.map((card) => (
                 <div
                   key={card.hash}
-                  className="border rounded p-4 cursor-pointer hover:bg-gray-50"
+                  className={`border rounded p-4 cursor-pointer hover:bg-gray-50 ${selectedCard?.hash === card.hash ? 'bg-blue-50 border-blue-300' : ''}`}
                   onClick={() => handleViewCard(card)}
                 >
                   <div className="flex justify-between mb-2">
@@ -459,13 +583,23 @@ export const DatabaseRetrievePanel: React.FC = () => {
                   <span className="font-medium">Hash: </span>
                   <span className="font-mono">{selectedCard.hash}</span>
                 </div>
-                <div>
-                  <button
-                    onClick={() => setViewMode(viewMode === 'raw' ? 'formatted' : 'raw')}
-                    className="px-3 py-1 text-sm bg-gray-200 rounded hover:bg-gray-300"
-                  >
-                    {viewMode === 'raw' ? 'Formatted View' : 'Raw View'}
-                  </button>
+                <div className="flex gap-2">
+                  {viewMode !== 'edit' && (
+                    <button
+                      onClick={handleEditCard}
+                      className="px-3 py-1 text-sm bg-yellow-100 text-yellow-800 rounded hover:bg-yellow-200"
+                    >
+                      Edit
+                    </button>
+                  )}
+                  {viewMode !== 'edit' && (
+                    <button
+                      onClick={() => setViewMode(viewMode === 'raw' ? 'formatted' : 'raw')}
+                      className="px-3 py-1 text-sm bg-gray-200 rounded hover:bg-gray-300"
+                    >
+                      {viewMode === 'raw' ? 'Formatted View' : 'Raw View'}
+                    </button>
+                  )}
                 </div>
               </div>
             </div>
@@ -480,34 +614,103 @@ export const DatabaseRetrievePanel: React.FC = () => {
               <span>{getContentTypeLabel(detectContentType(selectedCard))}</span>
             </div>
             
+            {/* Update Status Message */}
+            {updateStatus.status !== 'idle' && (
+              <div className={`mb-4 p-3 rounded ${
+                updateStatus.status === 'loading' ? 'bg-blue-100 text-blue-800' :
+                updateStatus.status === 'success' ? 'bg-green-100 text-green-800' :
+                'bg-red-100 text-red-800'
+              }`}>
+                {updateStatus.message}
+              </div>
+            )}
+            
             <div className="mb-4">
               <div className="font-medium mb-2">Content:</div>
-              <pre className="bg-gray-100 p-4 rounded overflow-auto max-h-96 font-mono text-sm">
-                {viewMode === 'raw' 
-                  ? typeof selectedCard.content === 'object' 
-                    ? JSON.stringify(selectedCard.content)
-                    : String(selectedCard.content)
-                  : formatContent(selectedCard.content)
-                }
-              </pre>
+              {viewMode === 'edit' ? (
+                <div>
+                  <textarea
+                    value={editableContent}
+                    onChange={handleContentChange}
+                    className="w-full h-64 font-mono text-sm p-4 border rounded"
+                  />
+                  <div className="flex justify-end gap-2 mt-2">
+                    <button
+                      onClick={handleCancelEdit}
+                      className="px-4 py-2 bg-gray-200 text-gray-800 rounded hover:bg-gray-300"
+                    >
+                      Cancel
+                    </button>
+                    <button
+                      onClick={handleSaveContent}
+                      className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600"
+                      disabled={updateStatus.status === 'loading'}
+                    >
+                      Save Changes
+                    </button>
+                  </div>
+                </div>
+              ) : (
+                <pre className="bg-gray-100 p-4 rounded overflow-auto max-h-96 font-mono text-sm">
+                  {viewMode === 'raw' 
+                    ? typeof selectedCard.content === 'object' 
+                      ? JSON.stringify(selectedCard.content)
+                      : String(selectedCard.content)
+                    : formatContent(selectedCard.content)
+                  }
+                </pre>
+              )}
             </div>
             
-            <div className="mt-2">
-              <button
-                onClick={() => {
-                  const content = typeof selectedCard.content === 'object' 
-                    ? JSON.stringify(selectedCard.content, null, 2)
-                    : String(selectedCard.content);
-                  navigator.clipboard.writeText(content);
-                }}
-                className="px-3 py-1 text-sm bg-blue-500 text-white rounded hover:bg-blue-600"
-              >
-                Copy Content
-              </button>
-            </div>
+            {viewMode !== 'edit' && (
+              <div className="mt-2 flex gap-2">
+                <button
+                  onClick={() => {
+                    const content = typeof selectedCard.content === 'object' 
+                      ? JSON.stringify(selectedCard.content, null, 2)
+                      : String(selectedCard.content);
+                    navigator.clipboard.writeText(content);
+                    alert('Content copied to clipboard!');
+                  }}
+                  className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
+                >
+                  Copy Content
+                </button>
+                <button
+                  onClick={() => {
+                    navigator.clipboard.writeText(selectedCard.hash);
+                    alert('Hash copied to clipboard!');
+                  }}
+                  className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600"
+                >
+                  Copy Hash
+                </button>
+                <button
+                  onClick={() => {
+                    // Import the card into Redux
+                    dispatch(importCardFromDatabase({ 
+                      card: {
+                        hash: selectedCard.hash,
+                        content: selectedCard.content,
+                        metadata: {},
+                        relationships: {
+                          parentHash: null,
+                          childHashes: [],
+                          relatedHashes: []
+                        }
+                      }
+                    }));
+                    alert('Card imported to local state!');
+                  }}
+                  className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600"
+                >
+                  Import to Redux
+                </button>
+              </div>
+            )}
           </div>
         ) : (
-          <div className="text-center text-gray-500 py-8">
+          <div className="flex items-center justify-center h-full text-gray-500">
             Select a card to view details
           </div>
         )}
diff --git a/src/content/model/card-collection.js b/src/content/model/card-collection.js
index eb89e3f..22e32f5 100644
--- a/src/content/model/card-collection.js
+++ b/src/content/model/card-collection.js
@@ -226,6 +226,32 @@ class CardCollection {
     return this.engine.search_by_content(search_string, page_number, page_size);
   }
   
+  /**
+   * Update the content of an existing card
+   * @param {string} hash - Hash of the card to update
+   * @param {any} newContent - New content for the card
+   * @returns {boolean} Whether the update was successful
+   */
+  update(hash, newContent) {
+    if (!hash) {
+      throw new Error("Hash cannot be empty");
+    }
+    
+    // Check if the card exists
+    const existingCard = this.get(hash);
+    if (!existingCard) {
+      return false;
+    }
+    
+    try {
+      // Update the card in the engine
+      return this.engine.update(hash, newContent);
+    } catch (error) {
+      console.error(`Error updating card ${hash}:`, error);
+      return false;
+    }
+  }
+  
   clear() {
     this.engine.clear();
   }
diff --git a/src/engine/sqlite_engine.js b/src/engine/sqlite_engine.js
index f432182..9af2e1a 100644
--- a/src/engine/sqlite_engine.js
+++ b/src/engine/sqlite_engine.js
@@ -580,6 +580,64 @@ class SQLiteEngine {
     return total;
   }
 
+  /**
+   * Update a card's content by hash
+   * @param {string} hash - Hash of the card to update
+   * @param {any} newContent - New content for the card
+   * @returns {boolean} Whether the update was successful
+   */
+  update(hash, newContent) {
+    try {
+      console.log('SQLiteEngine.update called with hash:', hash);
+      
+      // First verify the card exists
+      const existingCard = this.get(hash);
+      if (!existingCard) {
+        console.log('No card found with hash:', hash);
+        return false;
+      }
+      
+      // Prepare content for storage
+      let finalContent;
+      
+      if (typeof newContent === 'object' && newContent !== null && !(newContent instanceof Buffer)) {
+        // For objects, stringify to ensure proper SQLite storage
+        finalContent = JSON.stringify(newContent);
+        console.log('Serialized object content to JSON string for update');
+      } else if (typeof newContent === 'string') {
+        // Strings can be stored directly
+        finalContent = newContent;
+        console.log('Using string content directly for update');
+      } else if (Buffer.isBuffer(newContent)) {
+        // Buffers can be stored directly
+        finalContent = newContent;
+        console.log('Using Buffer content directly for update');
+      } else {
+        // Convert other types to string
+        finalContent = String(newContent);
+        console.log('Converted content to string for update');
+      }
+      
+      // Update the card in the database
+      const stmt = this.connection.conn.prepare(
+        'UPDATE card SET content = ? WHERE hash = ?'
+      );
+      
+      const result = stmt.run(finalContent, String(hash));
+      
+      if (result.changes > 0) {
+        console.log('Card updated successfully with hash:', hash);
+        return true;
+      } else {
+        console.log('Card update had no effect for hash:', hash);
+        return false;
+      }
+    } catch (error) {
+      console.error('Error updating card:', error);
+      return false;
+    }
+  }
+
   /**
    * Get all cards
    * @param {number} page_number - Page number to retrieve
diff --git a/src/features/contentSlice.js b/src/features/contentSlice.js
index e57912e..04a3163 100644
--- a/src/features/contentSlice.js
+++ b/src/features/contentSlice.js
@@ -123,6 +123,29 @@ export const contentSlice = createSlice({
           ...relationships
         };
       }
+    },
+
+    // Update card content
+    updateContent: (state, action) => {
+      const { hash, content } = action.payload;
+      if (state.cards[hash]) {
+        state.cards[hash].content = content;
+        state.cards[hash].updatedAt = new Date().toISOString();
+      }
+    },
+    importCardFromDatabase: (state, action) => {
+      const { hash, content, relationships = {}, metadata = {} } = action.payload;
+      state.cards[hash] = {
+        hash,
+        content,
+        createdAt: new Date().toISOString(),
+        metadata,
+        relationships: {
+          parentHash: relationships?.parentHash || null,
+          childHashes: relationships?.childHashes || [],
+          relatedHashes: relationships?.relatedHashes || []
+        }
+      };
     }
   }
 });
@@ -143,7 +166,9 @@ export const {
   selectContent, 
   setSearchQuery,
   updateContentMetadata,
-  updateContentRelationships
+  updateContentRelationships,
+  updateContent,
+  importCardFromDatabase
 } = contentSlice.actions;
 
 export default contentSlice.reducer;
diff --git a/src/pages/api/update-card.ts b/src/pages/api/update-card.ts
new file mode 100644
index 0000000..c876b3f
--- /dev/null
+++ b/src/pages/api/update-card.ts
@@ -0,0 +1,101 @@
+import type { APIRoute } from 'astro';
+import { SQLiteEngine } from '../../engine/sqlite_engine.js';
+import { CardCollection } from '../../content/model/card-collection.js';
+import { getCardByHash } from '../../utils/storeAdapter';
+
+/**
+ * API endpoint to update a card's content by hash
+ */
+export const POST: APIRoute = async ({ request }) => {
+  console.log('POST /api/update-card called');
+  
+  try {
+    // Get the request body
+    const data = await request.json();
+    console.log('Received update request:', { hash: data.hash, contentType: typeof data.content });
+    
+    // Validate request data
+    if (!data.hash || data.content === undefined) {
+      return new Response(
+        JSON.stringify({ 
+          error: 'Invalid request. Hash and content are required.', 
+          timestamp: new Date().toISOString() 
+        }),
+        { 
+          status: 400, 
+          headers: { 'Content-Type': 'application/json' } 
+        }
+      );
+    }
+    
+    // Add updated timestamp to the content (if it's an object)
+    let updatedContent = data.content;
+    if (typeof updatedContent === 'object' && updatedContent !== null) {
+      updatedContent = {
+        ...updatedContent,
+        __stateTimestamp: new Date().toISOString()
+      };
+    }
+    
+    // Initialize database connection and card collection
+    const engine = new SQLiteEngine();
+    const cardCollection = new CardCollection(engine);
+    
+    // Check if the card exists
+    const existingCard = cardCollection.get(data.hash);
+    if (!existingCard) {
+      return new Response(
+        JSON.stringify({ 
+          error: 'Card not found', 
+          timestamp: new Date().toISOString() 
+        }),
+        { 
+          status: 404, 
+          headers: { 'Content-Type': 'application/json' } 
+        }
+      );
+    }
+    
+    // Update the card
+    const success = cardCollection.update(data.hash, updatedContent);
+    
+    if (!success) {
+      throw new Error('Failed to update card in database');
+    }
+    
+    // Get the updated card
+    const updatedCard = getCardByHash(data.hash);
+    
+    // Return success response
+    return new Response(
+      JSON.stringify({ 
+        success: true, 
+        hash: data.hash,
+        updatedAt: new Date().toISOString(),
+        cardData: {
+          hash: updatedCard?.hash,
+          contentType: typeof updatedCard?.content,
+          updatedAt: new Date().toISOString(),
+          content: updatedCard?.content
+        }
+      }),
+      { 
+        status: 200, 
+        headers: { 'Content-Type': 'application/json' } 
+      }
+    );
+  } catch (error) {
+    console.error('Error updating card:', error);
+    return new Response(
+      JSON.stringify({ 
+        error: 'Failed to update card', 
+        details: error instanceof Error ? error.message : String(error),
+        timestamp: new Date().toISOString()
+      }),
+      { 
+        status: 500, 
+        headers: { 'Content-Type': 'application/json' } 
+      }
+    );
+  }
+};

commit 752d3cc499b47bff0c7dfd5b5bf16a4775b85b16
Author: Henrykoo <lckoo1230@gmail.com>
Date:   Wed Mar 26 14:03:59 2025 +0800

    working panle

diff --git a/public/data/cards.db-wal b/public/data/cards.db-wal
index 1ffc251..10196a1 100644
Binary files a/public/data/cards.db-wal and b/public/data/cards.db-wal differ
diff --git a/src/layouts/PanelGroupLayout.jsx b/src/layouts/PanelGroupLayout.jsx
index e5a5821..40b4324 100644
--- a/src/layouts/PanelGroupLayout.jsx
+++ b/src/layouts/PanelGroupLayout.jsx
@@ -9,9 +9,22 @@ const PanelContent = () => {
 
   const renderPanel = (config) => {
     const Component = React.lazy(() => 
-      import(`../components/panels/${config.type}.jsx`)
-        .catch(() => import(`../components/panels/${config.type}.tsx`))
+      // Try both .tsx and .jsx extensions using Promise.any
+      Promise.any([
+        import(`../components/panels/${config.type}.tsx`).then(module => {
+          console.log(`Successfully loaded .tsx component for: ${config.type}`);
+          return { default: module.default || module[config.type] };
+        }),
+        import(`../components/panels/${config.type}.jsx`).then(module => {
+          console.log(`Successfully loaded .jsx component for: ${config.type}`);
+          return { default: module.default || module[config.type] };
+        })
+      ]).catch((error) => {
+        console.error(`Failed to load component for panel type: ${config.type}`, error);
+        throw new Error(`No component found for panel type: ${config.type}`);
+      })
     );
+    
     return (
       <Suspense fallback={<div>Loading panel...</div>}>
         <Component />

commit 7a43591ed19d86923b0005b247102f7278a07974
Author: Henrykoo <lckoo1230@gmail.com>
Date:   Wed Mar 26 13:55:05 2025 +0800

    better retrivel

diff --git a/public/data/cards.db-shm b/public/data/cards.db-shm
index fe9ac28..2df7d89 100644
Binary files a/public/data/cards.db-shm and b/public/data/cards.db-shm differ
diff --git a/public/data/cards.db-wal b/public/data/cards.db-wal
index 7fd3e27..1ffc251 100644
Binary files a/public/data/cards.db-wal and b/public/data/cards.db-wal differ
diff --git a/src/components/panels/DatabaseRetrievePanel.tsx b/src/components/panels/DatabaseRetrievePanel.tsx
index 2df6de5..c129edc 100644
--- a/src/components/panels/DatabaseRetrievePanel.tsx
+++ b/src/components/panels/DatabaseRetrievePanel.tsx
@@ -1,4 +1,5 @@
 import React, { useState, useEffect } from 'react';
+import { Panel, PanelGroup, PanelResizeHandle } from 'react-resizable-panels';
 import { ContentTypeInterpreter } from '../../content/model/interpreter';
 import { MCardFromData } from '../../content/model/mcard';
 
@@ -26,6 +27,7 @@ export const DatabaseRetrievePanel: React.FC = () => {
   const [hashValue, setHashValue] = useState('');
   const [selectedCard, setSelectedCard] = useState<MCardFromData | null>(null);
   const [viewMode, setViewMode] = useState<'raw' | 'formatted'>('formatted');
+  const [panelSizes, setPanelSizes] = useState([50, 50]); // Initial split for card list and details
 
   // Function to fetch cards
   const fetchCards = async (params: {
@@ -187,241 +189,329 @@ export const DatabaseRetrievePanel: React.FC = () => {
     return null;
   };
 
-  return (
-    <div className="bg-white shadow-md rounded-lg p-6">
-      {/* Search and Hash Lookup Forms */}
-      <div className="flex flex-col md:flex-row gap-4 mb-6">
-        <form onSubmit={handleSearch} className="flex-1">
-          <div className="flex flex-col md:flex-row gap-2">
-            <input
-              type="text"
-              value={searchTerm}
-              onChange={(e) => setSearchTerm(e.target.value)}
-              placeholder="Search by content..."
-              className="flex-1 px-4 py-2 border rounded"
-            />
-            <button
-              type="submit"
-              className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
-              disabled={loading}
-            >
-              Search
-            </button>
-          </div>
-        </form>
-
-        <form onSubmit={handleHashLookup} className="flex-1">
-          <div className="flex flex-col md:flex-row gap-2">
-            <input
-              type="text"
-              value={hashValue}
-              onChange={(e) => setHashValue(e.target.value)}
-              placeholder="Lookup by hash..."
-              className="flex-1 px-4 py-2 border rounded"
-            />
-            <button
-              type="submit"
-              className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600"
-              disabled={loading}
-            >
-              Lookup
-            </button>
-          </div>
-        </form>
-      </div>
-
-      {/* Reset and Page Size Controls */}
-      <div className="flex flex-col md:flex-row justify-between items-center mb-6">
-        <button
-          onClick={() => {
-            setSearchTerm('');
-            setHashValue('');
-            setPage(1);
-            fetchCards({ page: 1, pageSize });
-          }}
-          className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 mb-2 md:mb-0"
-          disabled={loading}
-        >
-          Reset
-        </button>
-        
-        <div className="flex items-center">
-          <span className="mr-2">Items per page:</span>
-          <select
-            value={pageSize}
-            onChange={(e) => {
-              const newSize = Number(e.target.value);
-              setPageSize(newSize);
-              setPage(1); // Reset to first page when changing page size
-              
-              // Refetch with new page size
-              if (searchTerm) {
-                fetchCards({ search: searchTerm, page: 1, pageSize: newSize });
-              } else {
-                fetchCards({ page: 1, pageSize: newSize });
-              }
-            }}
-            className="px-2 py-1 border rounded"
-          >
-            <option value="5">5</option>
-            <option value="10">10</option>
-            <option value="20">20</option>
-            <option value="50">50</option>
-          </select>
-        </div>
-      </div>
+  // Sliding pagination function
+  const getSlidingPageNumbers = (currentPage: number, totalPages: number, windowSize: number = 5) => {
+    // Ensure window size is odd for symmetry
+    const adjustedWindowSize = windowSize % 2 === 0 ? windowSize + 1 : windowSize;
+    const halfWindow = Math.floor(adjustedWindowSize / 2);
 
-      {/* Error Display */}
-      {error && (
-        <div className="bg-red-100 border-l-4 border-red-500 text-red-700 p-4 mb-6">
-          <p>{error}</p>
-        </div>
-      )}
+    let startPage = Math.max(1, currentPage - halfWindow);
+    let endPage = Math.min(totalPages, startPage + adjustedWindowSize - 1);
 
-      {/* Loading Indicator */}
-      {loading && (
-        <div className="flex justify-center mb-6">
-          <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-blue-500"></div>
-        </div>
-      )}
-
-      {/* Results Display */}
-      {cards && cards.items.length > 0 ? (
-        <div>
-          {/* Results Summary */}
-          <div className="mb-4">
-            <p className="text-gray-700">
-              {cards.retrievalMethod === 'hash'
-                ? 'Card found by hash'
-                : `Showing ${cards.items.length} of ${cards.total_items} cards`}
-              {cards.serverTimestamp && ` (as of ${formatDate(cards.serverTimestamp)})`}
-            </p>
-          </div>
+    // Adjust start page if we're near the end
+    if (endPage === totalPages) {
+      startPage = Math.max(1, totalPages - adjustedWindowSize + 1);
+    }
 
-          {/* Card List */}
-          <div className="grid grid-cols-1 gap-4 mb-6">
-            {cards.items.map((card) => (
-              <div
-                key={card.hash}
-                className="border rounded p-4 cursor-pointer hover:bg-gray-50"
-                onClick={() => handleViewCard(card)}
-              >
-                <div className="flex justify-between mb-2">
-                  <span className="font-medium text-blue-600">
-                    {card.hash.substring(0, 10)}...
-                  </span>
-                  <span className="text-gray-500 text-sm">
-                    {formatDate(getCardTimestamp(card))}
-                  </span>
-                </div>
-                <div className="text-gray-700 truncate">
-                  {typeof card.content === 'object'
-                    ? '{...}'
-                    : String(card.content).substring(0, 80)}
-                </div>
-              </div>
-            ))}
-          </div>
+    // Create an array of page numbers to display
+    const pages = [];
+    for (let i = startPage; i <= endPage; i++) {
+      pages.push(i);
+    }
+
+    return {
+      pages,
+      showStartEllipsis: startPage > 1,
+      showEndEllipsis: endPage < totalPages
+    };
+  };
 
-          {/* Pagination */}
-          {cards.total_pages > 1 && (
-            <div className="flex justify-center gap-2 mb-6">
+  return (
+    <PanelGroup direction="horizontal" className="h-full w-full">
+      <Panel 
+        defaultSize={panelSizes[0]} 
+        minSize={20} 
+        className="bg-white shadow-md rounded-lg p-6 overflow-auto"
+      >
+        {/* Search and Hash Lookup Forms */}
+        <div className="flex flex-col md:flex-row gap-4 mb-6">
+          <form onSubmit={handleSearch} className="flex-1">
+            <div className="flex flex-col md:flex-row gap-2">
+              <input
+                type="text"
+                value={searchTerm}
+                onChange={(e) => setSearchTerm(e.target.value)}
+                placeholder="Search by content..."
+                className="flex-1 px-4 py-2 border rounded"
+              />
               <button
-                onClick={() => handlePageChange(page - 1)}
-                disabled={!cards.has_previous}
-                className={`px-3 py-1 rounded ${
-                  cards.has_previous
-                    ? 'bg-blue-100 text-blue-800 hover:bg-blue-200'
-                    : 'bg-gray-100 text-gray-400 cursor-not-allowed'
-                }`}
+                type="submit"
+                className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
+                disabled={loading}
               >
-                Previous
+                Search
               </button>
-              <span className="px-3 py-1">
-                Page {cards.page_number} of {cards.total_pages}
-              </span>
+            </div>
+          </form>
+
+          <form onSubmit={handleHashLookup} className="flex-1">
+            <div className="flex flex-col md:flex-row gap-2">
+              <input
+                type="text"
+                value={hashValue}
+                onChange={(e) => setHashValue(e.target.value)}
+                placeholder="Lookup by hash..."
+                className="flex-1 px-4 py-2 border rounded"
+              />
               <button
-                onClick={() => handlePageChange(page + 1)}
-                disabled={!cards.has_next}
-                className={`px-3 py-1 rounded ${
-                  cards.has_next
-                    ? 'bg-blue-100 text-blue-800 hover:bg-blue-200'
-                    : 'bg-gray-100 text-gray-400 cursor-not-allowed'
-                }`}
+                type="submit"
+                className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600"
+                disabled={loading}
               >
-                Next
+                Lookup
               </button>
             </div>
-          )}
+          </form>
         </div>
-      ) : (
-        !loading && (
-          <div className="text-center text-gray-500 py-8">
-            {cards ? 'No cards found' : 'Enter search terms or fetch cards'}
-          </div>
-        )
-      )}
 
-      {/* Selected Card Detail View */}
-      {selectedCard && (
-        <div className="mt-8 border-t pt-6">
-          <h3 className="text-xl font-semibold mb-4">Card Details</h3>
+        {/* Reset and Page Size Controls */}
+        <div className="flex flex-col md:flex-row justify-between items-center mb-6">
+          <button
+            onClick={() => {
+              setSearchTerm('');
+              setHashValue('');
+              setPage(1);
+              fetchCards({ page: 1, pageSize });
+            }}
+            className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 mb-2 md:mb-0"
+            disabled={loading}
+          >
+            Reset
+          </button>
           
-          <div className="mb-4">
-            <div className="flex justify-between">
-              <div>
-                <span className="font-medium">Hash: </span>
-                <span className="font-mono">{selectedCard.hash}</span>
-              </div>
-              <div>
+          <div className="flex items-center">
+            <span className="mr-2">Items per page:</span>
+            <select
+              value={pageSize}
+              onChange={(e) => {
+                const newSize = Number(e.target.value);
+                setPageSize(newSize);
+                setPage(1); // Reset to first page when changing page size
+                
+                // Refetch with new page size
+                if (searchTerm) {
+                  fetchCards({ search: searchTerm, page: 1, pageSize: newSize });
+                } else {
+                  fetchCards({ page: 1, pageSize: newSize });
+                }
+              }}
+              className="px-2 py-1 border rounded"
+            >
+              <option value="5">5</option>
+              <option value="10">10</option>
+              <option value="20">20</option>
+              <option value="50">50</option>
+            </select>
+          </div>
+        </div>
+
+        {/* Error Display */}
+        {error && (
+          <div className="bg-red-100 border-l-4 border-red-500 text-red-700 p-4 mb-6">
+            <p>{error}</p>
+          </div>
+        )}
+
+        {/* Loading Indicator */}
+        {loading && (
+          <div className="flex justify-center mb-6">
+            <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-blue-500"></div>
+          </div>
+        )}
+
+        {/* Card List */}
+        {cards && cards.items.length > 0 ? (
+          <div>
+            {/* Results Summary */}
+            <div className="mb-4">
+              <p className="text-gray-700">
+                {cards.retrievalMethod === 'hash'
+                  ? 'Card found by hash'
+                  : `Showing ${cards.items.length} of ${cards.total_items} cards`}
+                {cards.serverTimestamp && ` (as of ${formatDate(cards.serverTimestamp)})`}
+              </p>
+            </div>
+
+            <div className="grid grid-cols-1 gap-4 mb-6">
+              {cards.items.map((card) => (
+                <div
+                  key={card.hash}
+                  className="border rounded p-4 cursor-pointer hover:bg-gray-50"
+                  onClick={() => handleViewCard(card)}
+                >
+                  <div className="flex justify-between mb-2">
+                    <span className="font-medium text-blue-600">
+                      {card.hash.substring(0, 10)}...
+                    </span>
+                    <span className="text-gray-500 text-sm">
+                      {formatDate(getCardTimestamp(card))}
+                    </span>
+                  </div>
+                  <div className="text-gray-700 truncate">
+                    {typeof card.content === 'object'
+                      ? '{...}'
+                      : String(card.content).substring(0, 80)}
+                  </div>
+                </div>
+              ))}
+            </div>
+
+            {/* Pagination */}
+            {cards.total_pages > 1 && (
+              <div className="flex justify-center items-center gap-2 mb-6">
                 <button
-                  onClick={() => setViewMode(viewMode === 'raw' ? 'formatted' : 'raw')}
-                  className="px-3 py-1 text-sm bg-gray-200 rounded hover:bg-gray-300"
+                  onClick={() => handlePageChange(page - 1)}
+                  disabled={!cards.has_previous}
+                  className={`px-3 py-1 rounded ${
+                    cards.has_previous
+                      ? 'bg-blue-100 text-blue-800 hover:bg-blue-200'
+                      : 'bg-gray-100 text-gray-400 cursor-not-allowed'
+                  }`}
                 >
-                  {viewMode === 'raw' ? 'Formatted View' : 'Raw View'}
+                  Previous
+                </button>
+
+                {/* First page button */}
+                {getSlidingPageNumbers(page, cards.total_pages).showStartEllipsis && (
+                  <button
+                    onClick={() => handlePageChange(1)}
+                    className="px-3 py-1 rounded bg-blue-100 text-blue-800 hover:bg-blue-200"
+                  >
+                    1
+                  </button>
+                )}
+                
+                {/* Start ellipsis */}
+                {getSlidingPageNumbers(page, cards.total_pages).showStartEllipsis && (
+                  <span className="px-2 text-gray-500">...</span>
+                )}
+
+                {/* Sliding page numbers */}
+                {getSlidingPageNumbers(page, cards.total_pages).pages.map((pageNumber) => (
+                  <button
+                    key={pageNumber}
+                    onClick={() => handlePageChange(pageNumber)}
+                    className={`px-3 py-1 rounded ${
+                      pageNumber === page
+                        ? 'bg-blue-500 text-white'
+                        : 'bg-blue-100 text-blue-800 hover:bg-blue-200'
+                    }`}
+                  >
+                    {pageNumber}
+                  </button>
+                ))}
+
+                {/* End ellipsis */}
+                {getSlidingPageNumbers(page, cards.total_pages).showEndEllipsis && (
+                  <span className="px-2 text-gray-500">...</span>
+                )}
+
+                {/* Last page button */}
+                {getSlidingPageNumbers(page, cards.total_pages).showEndEllipsis && (
+                  <button
+                    onClick={() => handlePageChange(cards.total_pages)}
+                    className="px-3 py-1 rounded bg-blue-100 text-blue-800 hover:bg-blue-200"
+                  >
+                    {cards.total_pages}
+                  </button>
+                )}
+
+                <button
+                  onClick={() => handlePageChange(page + 1)}
+                  disabled={!cards.has_next}
+                  className={`px-3 py-1 rounded ${
+                    cards.has_next
+                      ? 'bg-blue-100 text-blue-800 hover:bg-blue-200'
+                      : 'bg-gray-100 text-gray-400 cursor-not-allowed'
+                  }`}
+                >
+                  Next
                 </button>
               </div>
-            </div>
+            )}
           </div>
-          
-          <div className="mb-4">
-            <span className="font-medium">Created: </span>
-            <span>{formatDate(getCardTimestamp(selectedCard))}</span>
-          </div>
-          
-          <div className="mb-4">
-            <span className="font-medium">Content Type: </span>
-            <span>{getContentTypeLabel(detectContentType(selectedCard))}</span>
-          </div>
-          
-          <div className="mb-4">
-            <div className="font-medium mb-2">Content:</div>
-            <pre className="bg-gray-100 p-4 rounded overflow-auto max-h-96 font-mono text-sm">
-              {viewMode === 'raw' 
-                ? typeof selectedCard.content === 'object' 
-                  ? JSON.stringify(selectedCard.content)
-                  : String(selectedCard.content)
-                : formatContent(selectedCard.content)
-              }
-            </pre>
+        ) : (
+          !loading && (
+            <div className="text-center text-gray-500 py-8">
+              {cards ? 'No cards found' : 'Enter search terms or fetch cards'}
+            </div>
+          )
+        )}
+      </Panel>
+
+      <PanelResizeHandle 
+        className="w-2 bg-gray-200 hover:bg-gray-300 transition-colors cursor-col-resize" 
+      />
+
+      <Panel 
+        defaultSize={panelSizes[1]} 
+        minSize={20} 
+        className="bg-white shadow-md rounded-lg p-6 overflow-auto"
+      >
+        {/* Selected Card Detail View */}
+        {selectedCard ? (
+          <div>
+            <h3 className="text-xl font-semibold mb-4">Card Details</h3>
+            
+            <div className="mb-4">
+              <div className="flex justify-between">
+                <div>
+                  <span className="font-medium">Hash: </span>
+                  <span className="font-mono">{selectedCard.hash}</span>
+                </div>
+                <div>
+                  <button
+                    onClick={() => setViewMode(viewMode === 'raw' ? 'formatted' : 'raw')}
+                    className="px-3 py-1 text-sm bg-gray-200 rounded hover:bg-gray-300"
+                  >
+                    {viewMode === 'raw' ? 'Formatted View' : 'Raw View'}
+                  </button>
+                </div>
+              </div>
+            </div>
+            
+            <div className="mb-4">
+              <span className="font-medium">Created: </span>
+              <span>{formatDate(getCardTimestamp(selectedCard))}</span>
+            </div>
+            
+            <div className="mb-4">
+              <span className="font-medium">Content Type: </span>
+              <span>{getContentTypeLabel(detectContentType(selectedCard))}</span>
+            </div>
+            
+            <div className="mb-4">
+              <div className="font-medium mb-2">Content:</div>
+              <pre className="bg-gray-100 p-4 rounded overflow-auto max-h-96 font-mono text-sm">
+                {viewMode === 'raw' 
+                  ? typeof selectedCard.content === 'object' 
+                    ? JSON.stringify(selectedCard.content)
+                    : String(selectedCard.content)
+                  : formatContent(selectedCard.content)
+                }
+              </pre>
+            </div>
+            
+            <div className="mt-2">
+              <button
+                onClick={() => {
+                  const content = typeof selectedCard.content === 'object' 
+                    ? JSON.stringify(selectedCard.content, null, 2)
+                    : String(selectedCard.content);
+                  navigator.clipboard.writeText(content);
+                }}
+                className="px-3 py-1 text-sm bg-blue-500 text-white rounded hover:bg-blue-600"
+              >
+                Copy Content
+              </button>
+            </div>
           </div>
-          
-          <div className="mt-2">
-            <button
-              onClick={() => {
-                const content = typeof selectedCard.content === 'object' 
-                  ? JSON.stringify(selectedCard.content, null, 2)
-                  : String(selectedCard.content);
-                navigator.clipboard.writeText(content);
-                // You could add a toast notification here
-              }}
-              className="px-3 py-1 text-sm bg-blue-500 text-white rounded hover:bg-blue-600"
-            >
-              Copy Content
-            </button>
+        ) : (
+          <div className="text-center text-gray-500 py-8">
+            Select a card to view details
           </div>
-        </div>
-      )}
-    </div>
+        )}
+      </Panel>
+    </PanelGroup>
   );
 };
diff --git a/src/features/panellayoutSlice.json b/src/features/panellayoutSlice.json
index 845b635..3683318 100644
--- a/src/features/panellayoutSlice.json
+++ b/src/features/panellayoutSlice.json
@@ -13,7 +13,7 @@
             "visible": true
         },
         "right": {
-            "type": "DemoMainPanel",
+            "type": "DatabaseRetrievePanel",
             "size": 30,
             "minSize": 20,
             "visible": true
diff --git a/src/features/resizeable.json b/src/features/resizeable.json
index a6d7d6e..17e0a12 100644
--- a/src/features/resizeable.json
+++ b/src/features/resizeable.json
@@ -25,7 +25,7 @@
     },
     "minimal": {
       "components": [
-        "SearchANDPrompts"
+        "DatabaseRetrievePanel"
       ]
     },
     "expandedtest": {

commit d1bc7a68f06d94193b286b1833c0cccb17536760
Author: Henrykoo <lckoo1230@gmail.com>
Date:   Wed Mar 26 13:14:47 2025 +0800

    new panellayout

diff --git a/public/data/cards.db-wal b/public/data/cards.db-wal
index ace86bf..7fd3e27 100644
Binary files a/public/data/cards.db-wal and b/public/data/cards.db-wal differ
diff --git a/src/components/InstallPwa.jsx b/src/components/InstallPwa.jsx
index 5bac604..226d29f 100644
--- a/src/components/InstallPwa.jsx
+++ b/src/components/InstallPwa.jsx
@@ -1,13 +1,21 @@
 import React, { useState, useEffect } from 'react';
 
 const InstallPwa = () => {
+  // Only initialize hooks if we're in the browser
   const [installPrompt, setInstallPrompt] = useState(null);
   const [showInstallButton, setShowInstallButton] = useState(false);
   const [isIos, setIsIos] = useState(false);
+  const [isMounted, setIsMounted] = useState(false);
 
+  // Safe check to ensure we're running in the browser before using hooks
   useEffect(() => {
+    // Set mounted flag to ensure client-side rendering
+    setIsMounted(true);
+    
     // Check if on iOS
     const checkIos = () => {
+      if (typeof window === 'undefined') return false;
+      
       const ua = window.navigator.userAgent;
       const iOS = !!ua.match(/iPad/i) || !!ua.match(/iPhone/i);
       const webkit = !!ua.match(/WebKit/i);
@@ -28,27 +36,29 @@ const InstallPwa = () => {
       console.log('BeforeInstallPrompt event fired and captured');
     };
 
-    // Check if already installed
-    const checkIfInstalled = () => {
+    // Only run if we're in the browser
+    if (typeof window !== 'undefined') {
+      checkIos();
+      window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
+      
+      // Check if already installed
       if (window.matchMedia('(display-mode: standalone)').matches || 
           window.navigator.standalone === true) {
         console.log('App is already installed');
         setShowInstallButton(false);
       }
-    };
-
-    checkIos();
-    checkIfInstalled();
-
-    // Add event listener for beforeinstallprompt
-    window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
-
-    // Clean up
-    return () => {
-      window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
-    };
+      
+      return () => {
+        window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
+      };
+    }
   }, []);
 
+  // Don't render anything during SSR
+  if (!isMounted) {
+    return null;
+  }
+
   // Handle install button click
   const handleInstallClick = async () => {
     if (!installPrompt) {
diff --git a/src/components/PwaUpdater.jsx b/src/components/PwaUpdater.jsx
index 6ededec..d34d655 100644
--- a/src/components/PwaUpdater.jsx
+++ b/src/components/PwaUpdater.jsx
@@ -7,9 +7,18 @@ import React, { useState, useEffect } from 'react';
 const PwaUpdater = () => {
   const [needsRefresh, setNeedsRefresh] = useState(false);
   const [swRegistration, setSwRegistration] = useState(null);
+  const [isMounted, setIsMounted] = useState(false);
 
   // Monitor service worker updates rather than registering a new one
   useEffect(() => {
+    // Set mounted flag to ensure client-side rendering
+    setIsMounted(true);
+
+    // Only run in browser context
+    if (typeof window === 'undefined' || !('serviceWorker' in navigator)) {
+      return;
+    }
+
     const monitorSW = async () => {
       if ('serviceWorker' in navigator) {
         try {
@@ -29,7 +38,7 @@ const PwaUpdater = () => {
               newWorker.addEventListener('statechange', () => {
                 console.log('Service worker state:', newWorker.state);
                 if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
-                  console.log('New content is available, please refresh.');
+                  console.log('New content is available!');
                   setNeedsRefresh(true);
                 }
               });
@@ -64,8 +73,17 @@ const PwaUpdater = () => {
     };
     
     monitorSW();
+
+    return () => {
+      // Cleanup if needed
+    };
   }, []);
 
+  // Don't render anything during SSR
+  if (!isMounted) {
+    return null;
+  }
+
   // Handler for the refresh button
   const handleRefresh = () => {
     if (swRegistration && swRegistration.waiting) {
diff --git a/src/components/panels/TopBar.tsx b/src/components/panels/TopBar.tsx
index 48b2066..79827e6 100644
--- a/src/components/panels/TopBar.tsx
+++ b/src/components/panels/TopBar.tsx
@@ -10,9 +10,9 @@ interface TopBarProps {
 }
 
 interface UserInfo {
-  email?: string;
-  email_verified?: boolean;
-  sub?: string;
+  email?: string | null;
+  email_verified?: boolean | null;
+  sub?: string | null;
 }
 
 // Add save function to window for external components to call
@@ -134,6 +134,20 @@ export const TopBar: React.FC<TopBarProps> = ({ initialTheme: initialPropTheme }
     setLastSavedState(JSON.stringify(initialState));
     console.log('Initial state set for auto-save comparison');
 
+    // Check authentication state from Redux store
+    const userState = initialState.user;
+    console.log('Initial user state from Redux:', userState);
+    if (userState && userState.isAuthenticated) {
+      startTransition(() => {
+        setIsAuthenticated(true);
+        setUserProfile({
+          email: userState.profile?.email,
+          email_verified: userState.profile?.email_verified,
+          sub: userState.profile?.sub
+        });
+      });
+    }
+
     // Initial theme setup
     const storeTheme = initialState.theme?.mode || 'light';
     startTransition(() => {
@@ -150,6 +164,29 @@ export const TopBar: React.FC<TopBarProps> = ({ initialTheme: initialPropTheme }
       }
     });
 
+    // Set up user state subscription
+    const unsubscribeUser = store.subscribe(() => {
+      const currentUserState = store.getState().user;
+      console.log('User state updated in Redux:', currentUserState);
+      if (currentUserState) {
+        const shouldBeAuthenticated = !!currentUserState.isAuthenticated;
+        if (shouldBeAuthenticated !== isAuthenticated) {
+          startTransition(() => {
+            setIsAuthenticated(shouldBeAuthenticated);
+            if (shouldBeAuthenticated) {
+              setUserProfile({
+                email: currentUserState.profile?.email,
+                email_verified: currentUserState.profile?.email_verified,
+                sub: currentUserState.profile?.sub
+              });
+            } else {
+              setUserProfile({});
+            }
+          });
+        }
+      }
+    });
+
     // Handle force save events
     const handleForceSave = (event: CustomEvent) => {
       console.log('Force save event received', event.detail);
@@ -200,9 +237,9 @@ export const TopBar: React.FC<TopBarProps> = ({ initialTheme: initialPropTheme }
     );
 
     // Check for stored user info
-    const storedUserInfo = localStorage.getItem('authentik_panel_top_banner_authuser_info');
-    const accessToken = localStorage.getItem('authentik_panel_top_banner_auth_access_token');
-    const idToken = localStorage.getItem('authentik_panel_top_banner_auth_id_token');
+    const storedUserInfo = localStorage.getItem('authentik_top_banner_authuser_info');
+    const accessToken = localStorage.getItem('authentik_top_banner_authaccess_token');
+    const idToken = localStorage.getItem('authentik_top_banner_authid_token');
 
     console.log('Stored User Info:', {
       userInfo: storedUserInfo,
@@ -212,32 +249,95 @@ export const TopBar: React.FC<TopBarProps> = ({ initialTheme: initialPropTheme }
 
     if (storedUserInfo) {
       try {
-        const parsedUserInfo: UserInfo = JSON.parse(storedUserInfo);
+        // Try to parse the full stored user info
+        let parsedUserInfo = {};
         
-        // Dispatch login action with comprehensive payload
-        const loginPayload = {
-          profile: parsedUserInfo,
-          tokens: {
-            access_token: accessToken,
-            id_token: idToken,
-            // Add other token details if available
+        try {
+          // First, try parsing the full stored info
+          parsedUserInfo = JSON.parse(storedUserInfo);
+        } catch (partialParseError) {
+          console.warn('Partial or truncated user info, attempting recovery', partialParseError);
+          
+          // Attempt to recover by parsing the valid part of the JSON
+          const validJsonMatch = storedUserInfo.match(/^{[^}]*}/);
+          if (validJsonMatch) {
+            try {
+              parsedUserInfo = JSON.parse(validJsonMatch[0]);
+            } catch (recoveryError) {
+              console.error('Could not recover user info', recoveryError);
+              localStorage.removeItem('authentik_top_banner_authuser_info');
+              return;
+            }
           }
+        }
+
+        // Decode JWT tokens to get additional information
+        const decodeJWT = (token: string) => {
+          try {
+            const base64Url = token.split('.')[1];
+            const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
+            return JSON.parse(window.atob(base64));
+          } catch (error) {
+            console.error('Error decoding JWT', error);
+            return {};
+          }
+        };
+
+        // Try to get additional info from access token
+        const decodedAccessToken = accessToken ? decodeJWT(accessToken) : {};
+        const decodedIdToken = idToken ? decodeJWT(idToken) : {};
+
+        // Merge information from different sources
+        const mergedUserInfo = {
+          ...decodedAccessToken,
+          ...decodedIdToken,
+          ...parsedUserInfo,
+          access_token: accessToken,
+          id_token: idToken
+        };
+        
+        // Comprehensive login payload
+        const loginPayload = {
+          isAuthenticated: true,
+          sub: mergedUserInfo.sub || null,
+          email: mergedUserInfo.email || null,
+          email_verified: mergedUserInfo.email_verified || false,
+          name: mergedUserInfo.name || null,
+          given_name: mergedUserInfo.given_name || null,
+          family_name: mergedUserInfo.family_name || null,
+          nickname: mergedUserInfo.nickname || null,
+          preferred_username: mergedUserInfo.preferred_username || null,
+          groups: mergedUserInfo.groups || [],
+          picture: mergedUserInfo.picture || null,
+          access_token: accessToken,
+          id_token: idToken,
+          token_type: 'Bearer',
+          expires_at: mergedUserInfo.exp ? new Date(mergedUserInfo.exp * 1000).toISOString() : null,
+          lastLogin: new Date().toISOString(),
+          theme: 'system',
+          language: 'en'
         };
 
-        console.log('Dispatching Login Payload:', loginPayload);
+        console.log('Dispatching Comprehensive Login Payload:', loginPayload);
 
-        // Dispatch login action
-        const loginAction = store.dispatch(login(loginPayload));
+        // Dispatch login action with comprehensive payload
+        store.dispatch(login(loginPayload));
 
-        // Update local state
+        // Update local state directly
         startTransition(() => {
           setIsAuthenticated(true);
-          setUserProfile(parsedUserInfo);
+          setUserProfile({
+            email: mergedUserInfo.email,
+            email_verified: mergedUserInfo.email_verified,
+            sub: mergedUserInfo.sub
+          });
         });
 
-        console.log('Login dispatched with action:', loginAction);
+        console.log('Login processed successfully');
       } catch (error) {
-        console.error('Error parsing user info:', error);
+        console.error('Error processing user info:', error);
+        // Clear invalid stored info
+        localStorage.removeItem('authentik_top_banner_authuser_info');
       }
     }
 
@@ -249,6 +349,7 @@ export const TopBar: React.FC<TopBarProps> = ({ initialTheme: initialPropTheme }
     return () => {
       unsubscribeTheme();
       unsubscribeStateChange();
+      unsubscribeUser();
       window.removeEventListener('redux-state-change', handleCustomStateChange as EventListener);
       window.removeEventListener('force-save-state', handleForceSave as EventListener);
       
@@ -259,7 +360,7 @@ export const TopBar: React.FC<TopBarProps> = ({ initialTheme: initialPropTheme }
         saveTimeoutRef.current = null;
       }
     };
-  }, [autoSaveEnabled]);
+  }, [autoSaveEnabled, isAuthenticated, theme]);
 
   const handleLogin = async () => {
     try {
@@ -271,16 +372,42 @@ export const TopBar: React.FC<TopBarProps> = ({ initialTheme: initialPropTheme }
       if (isDev && !import.meta.env.PUBLIC_AUTHENTIK_CLIENT_SECRET) {
         console.log('Development mode: Skipping authentication');
         // Mock authentication for development
-        localStorage.setItem('authentik_panel_top_banner_authuser_info', JSON.stringify({
+        const mockUserInfo = {
           email: 'dev@example.com',
           email_verified: true,
           sub: 'dev-user'
-        }));
+        };
+        
+        localStorage.setItem('authentik_top_banner_authuser_info', JSON.stringify(mockUserInfo));
+        
+        // Structure the Redux action payload correctly
+        const loginPayload = {
+          profile: {
+            ...mockUserInfo,
+            name: 'Dev User',
+            given_name: 'Dev',
+            family_name: 'User',
+            nickname: 'dev',
+            preferred_username: 'devuser',
+            groups: ['Developers'],
+            picture: null
+          },
+          tokens: {
+            access_token: 'mock-access-token',
+            id_token: 'mock-id-token',
+            token_type: 'Bearer',
+            expires_at: new Date(Date.now() + 3600000).toISOString() // 1 hour from now
+          }
+        };
+        
+        // Dispatch login action
+        store.dispatch(login(loginPayload));
+        
         setIsAuthenticated(true);
         setUserProfile({
-          email: 'dev@example.com',
-          email_verified: true,
-          sub: 'dev-user'
+          email: mockUserInfo.email,
+          email_verified: mockUserInfo.email_verified,
+          sub: mockUserInfo.sub
         });
         setLoading(false);
         return;
@@ -294,7 +421,7 @@ export const TopBar: React.FC<TopBarProps> = ({ initialTheme: initialPropTheme }
         redirectUri: redirectUri || '',
         scopes: import.meta.env.PUBLIC_AUTHENTIK_SCOPES || 'openid profile email',
         baseUrl: import.meta.env.PUBLIC_AUTHENTIK_URL || '',
-        storageKey: `${import.meta.env.PUBLIC_AUTHENTIK_STORAGE_KEY_PREFIX || 'authentik_'}panel_top_banner_auth`,
+        storageKey: `${import.meta.env.PUBLIC_AUTHENTIK_STORAGE_KEY_PREFIX || 'authentik_'}top_banner_auth`,
       });
 
       await client.login(currentPath);
@@ -305,16 +432,43 @@ export const TopBar: React.FC<TopBarProps> = ({ initialTheme: initialPropTheme }
       // Fall back to mock login in development mode if there's an error
       if (import.meta.env.DEV || import.meta.env.MODE === 'development') {
         console.log('Development mode: Using mock authentication after error');
-        localStorage.setItem('authentik_panel_top_banner_authuser_info', JSON.stringify({
+        
+        const mockUserInfo = {
           email: 'dev@example.com',
           email_verified: true,
           sub: 'dev-user'
-        }));
+        };
+        
+        localStorage.setItem('authentik_top_banner_authuser_info', JSON.stringify(mockUserInfo));
+        
+        // Structure the Redux action payload correctly
+        const loginPayload = {
+          profile: {
+            ...mockUserInfo,
+            name: 'Dev User',
+            given_name: 'Dev',
+            family_name: 'User',
+            nickname: 'dev',
+            preferred_username: 'devuser',
+            groups: ['Developers'],
+            picture: null
+          },
+          tokens: {
+            access_token: 'mock-access-token',
+            id_token: 'mock-id-token',
+            token_type: 'Bearer',
+            expires_at: new Date(Date.now() + 3600000).toISOString() // 1 hour from now
+          }
+        };
+        
+        // Dispatch login action
+        store.dispatch(login(loginPayload));
+        
         setIsAuthenticated(true);
         setUserProfile({
-          email: 'dev@example.com',
-          email_verified: true,
-          sub: 'dev-user'
+          email: mockUserInfo.email,
+          email_verified: mockUserInfo.email_verified,
+          sub: mockUserInfo.sub
         });
       }
     }
@@ -322,9 +476,9 @@ export const TopBar: React.FC<TopBarProps> = ({ initialTheme: initialPropTheme }
 
   const handleLogout = () => {
     // Remove stored user info
-    localStorage.removeItem('authentik_panel_top_banner_authuser_info');
-    localStorage.removeItem('authentik_panel_top_banner_auth_access_token');
-    localStorage.removeItem('authentik_panel_top_banner_auth_id_token');
+    localStorage.removeItem('authentik_top_banner_authuser_info');
+    localStorage.removeItem('authentik_top_banner_authaccess_token');
+    localStorage.removeItem('authentik_top_banner_authid_token');
     
     // Dispatch logout action
     store.dispatch(logout());
diff --git a/src/components/panels/panels.json b/src/components/panels/panels.json
index 7fe1b05..9657f4c 100644
--- a/src/components/panels/panels.json
+++ b/src/components/panels/panels.json
@@ -22,5 +22,8 @@
   },
   "ContentDetailPanel": {
     "component": "../components/panels/ContentDetailPanel.jsx"
+  },
+  "DatabaseRetrievePanel": {
+    "component": "../components/panels/DatabaseRetrievePanel.tsx"
   }
 }
\ No newline at end of file

commit 79453aa83da89114e1a2d57a30857161ada57f8d
Author: Henrykoo <lckoo1230@gmail.com>
Date:   Wed Mar 26 12:32:39 2025 +0800

    new topbar

diff --git a/public/data/cards.db-wal b/public/data/cards.db-wal
index 6d7333d..ace86bf 100644
Binary files a/public/data/cards.db-wal and b/public/data/cards.db-wal differ
diff --git a/src/components/panels/TopBar.tsx b/src/components/panels/TopBar.tsx
index cbd3d86..48b2066 100644
--- a/src/components/panels/TopBar.tsx
+++ b/src/components/panels/TopBar.tsx
@@ -193,12 +193,11 @@ export const TopBar: React.FC<TopBarProps> = ({ initialTheme: initialPropTheme }
       }
     });
 
-    // Set up redirect URI
-    const origin = window.location.origin;
-    const path = '/callback';
-    startTransition(() => {
-      setRedirectUri(`${origin}${path}`);
-    });
+    // Set redirect URI based on environment configuration
+    setRedirectUri(
+      import.meta.env.PUBLIC_AUTHENTIK_REDIRECT_URI || 
+      `${import.meta.env.PUBLIC_APP_URL}/callback`
+    );
 
     // Check for stored user info
     const storedUserInfo = localStorage.getItem('authentik_panel_top_banner_authuser_info');
@@ -266,6 +265,27 @@ export const TopBar: React.FC<TopBarProps> = ({ initialTheme: initialPropTheme }
     try {
       setLoading(true);
       
+      // For development purposes, you can bypass authentication
+      const isDev = import.meta.env.DEV || import.meta.env.MODE === 'development';
+      
+      if (isDev && !import.meta.env.PUBLIC_AUTHENTIK_CLIENT_SECRET) {
+        console.log('Development mode: Skipping authentication');
+        // Mock authentication for development
+        localStorage.setItem('authentik_panel_top_banner_authuser_info', JSON.stringify({
+          email: 'dev@example.com',
+          email_verified: true,
+          sub: 'dev-user'
+        }));
+        setIsAuthenticated(true);
+        setUserProfile({
+          email: 'dev@example.com',
+          email_verified: true,
+          sub: 'dev-user'
+        });
+        setLoading(false);
+        return;
+      }
+      
       const currentPath = window.location.pathname + window.location.search;
 
       const client = createClient({
@@ -281,6 +301,22 @@ export const TopBar: React.FC<TopBarProps> = ({ initialTheme: initialPropTheme }
     } catch (error) {
       console.error('Login failed:', error);
       setLoading(false);
+      
+      // Fall back to mock login in development mode if there's an error
+      if (import.meta.env.DEV || import.meta.env.MODE === 'development') {
+        console.log('Development mode: Using mock authentication after error');
+        localStorage.setItem('authentik_panel_top_banner_authuser_info', JSON.stringify({
+          email: 'dev@example.com',
+          email_verified: true,
+          sub: 'dev-user'
+        }));
+        setIsAuthenticated(true);
+        setUserProfile({
+          email: 'dev@example.com',
+          email_verified: true,
+          sub: 'dev-user'
+        });
+      }
     }
   };
 

commit b5e90e2a5098fa72ddd14fdbd2320c13c3b8d433
Author: Henrykoo <lckoo1230@gmail.com>
Date:   Wed Mar 26 12:25:31 2025 +0800

    new back up

diff --git a/public/data/cards.db-wal b/public/data/cards.db-wal
index e69de29..6d7333d 100644
Binary files a/public/data/cards.db-wal and b/public/data/cards.db-wal differ
diff --git a/src/components/panels/DatabaseRetrievePanel.tsx b/src/components/panels/DatabaseRetrievePanel.tsx
index 22e5bc5..2df6de5 100644
--- a/src/components/panels/DatabaseRetrievePanel.tsx
+++ b/src/components/panels/DatabaseRetrievePanel.tsx
@@ -138,12 +138,53 @@ export const DatabaseRetrievePanel: React.FC = () => {
   };
 
   // Helper function to format date
-  const formatDate = (dateString: string) => {
+  const formatDate = (dateString: string | null | undefined) => {
+    if (!dateString) {
+      return 'N/A';
+    }
+    
     try {
-      return new Date(dateString).toLocaleString();
+      const date = new Date(dateString);
+      
+      // Check if date is valid
+      if (isNaN(date.getTime())) {
+        return 'N/A';
+      }
+      
+      return date.toLocaleString();
     } catch (e) {
-      return dateString;
+      return 'N/A';
+    }
+  };
+
+  // Helper function to get timestamp from card
+  const getCardTimestamp = (card: MCardFromData) => {
+    // Try g_time first (if it exists and is valid)
+    if (card.g_time) {
+      return card.g_time;
     }
+    
+    // Try to extract timestamp from content if it's a JSON object
+    if (typeof card.content === 'object' && card.content !== null) {
+      // Look for __stateTimestamp in the content object
+      if (card.content.__stateTimestamp) {
+        return card.content.__stateTimestamp;
+      }
+    }
+    
+    // If content is a string, try to parse it as JSON to find timestamp
+    if (typeof card.content === 'string') {
+      try {
+        const parsedContent = JSON.parse(card.content);
+        if (parsedContent.__stateTimestamp) {
+          return parsedContent.__stateTimestamp;
+        }
+      } catch (e) {
+        // Not valid JSON, ignore
+      }
+    }
+    
+    return null;
   };
 
   return (
@@ -270,7 +311,7 @@ export const DatabaseRetrievePanel: React.FC = () => {
                     {card.hash.substring(0, 10)}...
                   </span>
                   <span className="text-gray-500 text-sm">
-                    {formatDate(card.g_time)}
+                    {formatDate(getCardTimestamp(card))}
                   </span>
                 </div>
                 <div className="text-gray-700 truncate">
@@ -345,7 +386,7 @@ export const DatabaseRetrievePanel: React.FC = () => {
           
           <div className="mb-4">
             <span className="font-medium">Created: </span>
-            <span>{formatDate(selectedCard.g_time)}</span>
+            <span>{formatDate(getCardTimestamp(selectedCard))}</span>
           </div>
           
           <div className="mb-4">
diff --git a/src/content/model/hash/validator.js b/src/content/model/hash/validator.js
index f3b4f72..963f11a 100644
--- a/src/content/model/hash/validator.js
+++ b/src/content/model/hash/validator.js
@@ -1,6 +1,7 @@
 // Replace direct crypto import with environment-aware implementation
 import { encodeText } from '../../../utils/textEncoderPolyfill.js';
 import { SafeBuffer } from '../../../utils/bufferPolyfill.js';
+import { createHash } from '../../../utils/cryptoPolyfill.js';
 import { 
   HashAlgorithm, 
   HASH_ALGORITHM_HIERARCHY, 
@@ -10,75 +11,6 @@ import {
 // Check if we're in a browser environment
 const isBrowser = typeof window !== 'undefined';
 
-// Create a cross-environment crypto hash function that works in both browser and Node.js
-const createHash = (algorithm) => {
-  // Convert to lowercase and remove hyphens for consistency
-  const normalizedAlg = String(algorithm).toLowerCase().replace('-', '');
-  
-  if (isBrowser) {
-    // In browser environments, use Web Crypto API
-    return {
-      data: null,
-      update: function(data) {
-        this.data = data;
-        return this;
-      },
-      digest: async function(encoding) {
-        if (!this.data) return encoding === 'hex' ? '' : new Uint8Array();
-        
-        // Convert algorithm name to one supported by Web Crypto API
-        const webCryptoAlg = 
-          normalizedAlg === 'md5' ? 'SHA-1' : // Web Crypto doesn't support MD5, fallback to SHA-1
-          normalizedAlg === 'sha1' ? 'SHA-1' :
-          normalizedAlg === 'sha224' ? 'SHA-256' : // Web Crypto doesn't support SHA-224
-          normalizedAlg === 'sha256' ? 'SHA-256' :
-          normalizedAlg === 'sha384' ? 'SHA-384' :
-          normalizedAlg === 'sha512' ? 'SHA-512' : 'SHA-256';
-        
-        try {
-          // Ensure data is a proper Uint8Array
-          const dataBuffer = this.data instanceof Uint8Array 
-            ? this.data.buffer 
-            : encodeText(this.data).buffer;
-          
-          // Use Web Crypto API to compute hash
-          const hashBuffer = await window.crypto.subtle.digest(webCryptoAlg, dataBuffer);
-          
-          // Convert to hex string if requested
-          if (encoding === 'hex') {
-            return Array.from(new Uint8Array(hashBuffer))
-              .map(b => b.toString(16).padStart(2, '0'))
-              .join('');
-          }
-          
-          // Return raw buffer if no encoding specified
-          return new Uint8Array(hashBuffer);
-        } catch (e) {
-          console.error('Error using Web Crypto API:', e);
-          return encoding === 'hex' ? '' : new Uint8Array();
-        }
-      }
-    };
-  } else {
-    // In Node.js, try to use native crypto module
-    try {
-      // Only attempt to use require in non-browser environments
-      const crypto = require('crypto');
-      return crypto.createHash(normalizedAlg);
-    } catch (e) {
-      console.error('Crypto module not available:', e);
-      
-      // Return a dummy hash object that does nothing
-      return {
-        update: function() { return this; },
-        digest: function(encoding) { 
-          return encoding === 'hex' ? 'no-crypto-available' : new Uint8Array();
-        }
-      };
-    }
-  }
-};
-
 export default class HashValidator {
   /**
    * Constructor for HashValidator
@@ -129,7 +61,7 @@ export default class HashValidator {
     }
     
     // Convert to lowercase string and remove dashes for consistency
-    const normalizedAlgo = String(hashAlgorithm).toLowerCase().replace('-', '');
+    const normalizedAlgo = String(hashAlgorithm).toLowerCase().replace(/-/g, '');
     
     // Validate the hash algorithm
     if (!HashValidator.isValidHashFunction(normalizedAlgo)) {
@@ -159,23 +91,25 @@ export default class HashValidator {
     ];
     
     return validAlgorithms.includes(normalizedFunc) || 
-           validAlgorithms.includes(normalizedFunc.replace('-', ''));
+           validAlgorithms.includes(normalizedFunc.replace(/-/g, ''));
   }
 
   /**
    * Compute hash from content
-   * @returns {string} Computed hash
+   * @returns {string|Promise<string>} Computed hash or promise to hash
    */
   computeHash() {
-    if (isBrowser) {
-      // In browser, we can't compute synchronously
-      return "computing...";
-    }
-    
     try {
       const hash = createHash(this.hashAlgorithm);
       hash.update(this.content);
-      return hash.digest('hex');
+      const result = hash.digest('hex');
+      
+      // Handle the case where result is a Promise
+      if (result instanceof Promise) {
+        return "computing...";
+      }
+      
+      return result;
     } catch (e) {
       console.error('Error computing hash:', e);
       return '';
@@ -211,12 +145,6 @@ export default class HashValidator {
     
     const hash = createHash(hashAlgorithm);
     hash.update(buffer);
-    
-    if (isBrowser) {
-      // In browser, we need to handle async
-      return hash.digest('hex');
-    }
-    
     return hash.digest('hex');
   }
 
@@ -238,6 +166,14 @@ export default class HashValidator {
     return this.hashValue === expectedHash;
   }
 
+  /**
+   * Return string representation
+   * @returns {string} String representation
+   */
+  toString() {
+    return `HashValidator(alg=${this.hashAlgorithm}, hash=${this.hashValue})`;
+  }
+
   /**
    * Gets the strength order of hash algorithms
    * @returns {string[]} Ordered list of hash algorithms by strength
diff --git a/src/utils/cryptoPolyfill.js b/src/utils/cryptoPolyfill.js
new file mode 100644
index 0000000..e926714
--- /dev/null
+++ b/src/utils/cryptoPolyfill.js
@@ -0,0 +1,165 @@
+/**
+ * Cross-environment crypto polyfill
+ * 
+ * This module provides a unified interface for cryptographic operations
+ * that works in both browser and Node.js/SSR environments.
+ */
+
+import { encodeText } from './textEncoderPolyfill.js';
+
+// Since Astro SSR environment is complex and sometimes behaves like browser, 
+// sometimes like Node.js, we need to carefully detect capabilities
+const hasWebCrypto = typeof window !== 'undefined' && window.crypto && window.crypto.subtle;
+const hasNodeCrypto = typeof process !== 'undefined' && process.versions && process.versions.node;
+
+/**
+ * Create a hash object that works in any environment
+ * @param {string} algorithm - Hash algorithm to use
+ * @returns {Object} Hash object with update and digest methods
+ */
+export function createHash(algorithm) {
+  // Normalize algorithm name for consistency
+  const normalizedAlg = String(algorithm).toLowerCase().replace(/-/g, '');
+  
+  // Map to standardized algorithm names
+  const webCryptoAlg = 
+    normalizedAlg === 'md5' ? 'SHA-1' : // Web Crypto doesn't support MD5, fallback to SHA-1
+    normalizedAlg === 'sha1' ? 'SHA-1' :
+    normalizedAlg === 'sha224' ? 'SHA-256' : // Web Crypto doesn't support SHA-224
+    normalizedAlg === 'sha256' ? 'SHA-256' :
+    normalizedAlg === 'sha384' ? 'SHA-384' :
+    normalizedAlg === 'sha512' ? 'SHA-512' : 'SHA-256';
+  
+  // Implement a unified hash interface
+  return {
+    data: null,
+    
+    /**
+     * Update hash with data
+     * @param {string|Uint8Array} data - Data to hash
+     * @returns {Object} This hash object for chaining
+     */
+    update: function(data) {
+      this.data = data;
+      return this;
+    },
+    
+    /**
+     * Complete hash computation and return result
+     * @param {string} [encoding='hex'] - Encoding for output ('hex' or undefined for buffer)
+     * @returns {string|Uint8Array|Promise<string|Uint8Array>} Hash result
+     */
+    digest: function(encoding = 'hex') {
+      // Handle empty data case
+      if (!this.data) {
+        return encoding === 'hex' ? '' : new Uint8Array();
+      }
+      
+      // Use Web Crypto API if available
+      if (hasWebCrypto) {
+        // Ensure data is properly encoded
+        const dataBuffer = this.data instanceof Uint8Array 
+          ? this.data.buffer
+          : encodeText(String(this.data)).buffer;
+        
+        // Return a promise that resolves to the hash
+        return window.crypto.subtle.digest(webCryptoAlg, dataBuffer)
+          .then(hashBuffer => {
+            if (encoding === 'hex') {
+              return Array.from(new Uint8Array(hashBuffer))
+                .map(b => b.toString(16).padStart(2, '0'))
+                .join('');
+            }
+            return new Uint8Array(hashBuffer);
+          })
+          .catch(err => {
+            console.error('Web Crypto error:', err);
+            // Return empty result on error
+            return encoding === 'hex' ? '' : new Uint8Array();
+          });
+      }
+      
+      try {
+        // Try to use Node.js crypto if available, without direct require
+        if (typeof global !== 'undefined' && global.process && global.process.versions && global.process.versions.node) {
+          // In Node.js environment, we can safely try to require crypto
+          const crypto = require('crypto');
+          const nodeHash = crypto.createHash(normalizedAlg);
+          
+          if (this.data instanceof Uint8Array) {
+            nodeHash.update(Buffer.from(this.data));
+          } else {
+            nodeHash.update(String(this.data));
+          }
+          
+          return nodeHash.digest(encoding);
+        }
+      } catch (e) {
+        console.warn('Node.js crypto module not available:', e.message);
+        // Fall through to fallback implementation
+      }
+      
+      // If we're in neither environment or if detection fails, use a better fallback
+      // that doesn't require 'require()' calls but produces reasonable output
+      const fallbackHash = enhancedFallbackHash(normalizedAlg, this.data);
+      return encoding === 'hex' ? fallbackHash : encodeText(fallbackHash);
+    }
+  };
+}
+
+/**
+ * Enhanced fallback hash implementation that produces output
+ * with the correct length for the requested algorithm
+ * 
+ * @param {string} algorithm - Hash algorithm name
+ * @param {string|Uint8Array} data - Data to hash
+ * @returns {string} Hash string with appropriate length
+ */
+function enhancedFallbackHash(algorithm, data) {
+  // Convert data to string if it's a Uint8Array
+  const inputStr = data instanceof Uint8Array 
+    ? Array.from(data).map(b => String.fromCharCode(b)).join('')
+    : String(data);
+  
+  // Determine output length based on algorithm
+  const hashLength = 
+    algorithm === 'md5' ? 32 :
+    algorithm === 'sha1' ? 40 :
+    algorithm === 'sha224' ? 56 :
+    algorithm === 'sha256' ? 64 :
+    algorithm === 'sha384' ? 96 :
+    algorithm === 'sha512' ? 128 : 64; // Default to SHA-256 length
+  
+  // More sophisticated hash function
+  // This still isn't cryptographically secure, but it's better than the simple one
+  // and will produce the right length output
+  
+  // Start with a seed based on algorithm
+  const seed = algorithm.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
+  
+  // Generate initial hash chunks
+  const chunks = [];
+  let lastVal = seed;
+  
+  // Generate enough raw material for our hash length
+  for (let i = 0; i < hashLength / 8 + 1; i++) {
+    let chunk = 0;
+    for (let j = 0; j < inputStr.length; j++) {
+      const char = inputStr.charCodeAt(j);
+      chunk = ((chunk << 5) - chunk + char + j + i + lastVal) & 0xFFFFFFFF;
+    }
+    lastVal = chunk;
+    chunks.push(chunk);
+  }
+  
+  // Convert chunks to hex and combine into final hash
+  let hexHash = '';
+  for (let i = 0; i < chunks.length && hexHash.length < hashLength; i++) {
+    hexHash += Math.abs(chunks[i]).toString(16).padStart(8, '0');
+  }
+  
+  // Ensure exact length
+  return hexHash.substring(0, hashLength);
+}
+
+export default { createHash };

commit 1bf93a866cb8be4691994e8b8600441e255ee48a
Author: Henrykoo <lckoo1230@gmail.com>
Date:   Wed Mar 26 11:12:08 2025 +0800

    working retival

diff --git a/public/data/cards.db b/public/data/cards.db
index e26bdb1..2ac22d5 100644
Binary files a/public/data/cards.db and b/public/data/cards.db differ
diff --git a/public/data/cards.db-shm b/public/data/cards.db-shm
index f1f7ba0..fe9ac28 100644
Binary files a/public/data/cards.db-shm and b/public/data/cards.db-shm differ
diff --git a/public/data/cards.db-wal b/public/data/cards.db-wal
index c1671bd..e69de29 100644
Binary files a/public/data/cards.db-wal and b/public/data/cards.db-wal differ
diff --git a/src/config/browser-constants.js b/src/config/browser-constants.js
index 622c434..3a61cc5 100644
--- a/src/config/browser-constants.js
+++ b/src/config/browser-constants.js
@@ -13,7 +13,7 @@ const SHA512 = 'sha512';
 
 // Browser-safe constants
 const DEFAULT_PAGE_SIZE = 10;
-const DEFAULT_HASH_ALGORITHM = MD5;
+const DEFAULT_HASH_ALGORITHM = SHA256;
 const DEFAULT_HASH_LENGTH = 64;
 const DEFAULT_LOG_LEVEL = 'info';
 const LOG_LEVEL = DEFAULT_LOG_LEVEL;
diff --git a/src/config/config_constants.js b/src/config/config_constants.js
index a4285d3..fd8bb1c 100644
--- a/src/config/config_constants.js
+++ b/src/config/config_constants.js
@@ -1,21 +1,65 @@
-import dotenv from 'dotenv';
-dotenv.config();
-import path from 'path';
-
-// Determine the current directory path
-const projectRoot = process.cwd();
+// Check if we're in a browser environment
+const isBrowser = typeof window !== 'undefined';
+
+// Default empty values that will be replaced in Node.js environment
+let projectRoot = '';
+let dotenv = null;
+let path = null;
+
+// Only import Node.js modules when in Node.js environment
+// Use try/catch to make this safe in any environment
+if (!isBrowser) {
+  try {
+    // Use dynamic import with eval to prevent browser parsing errors
+    // This code won't execute in the browser because of the isBrowser check
+    if (typeof process !== 'undefined') {
+      projectRoot = process.cwd();
+      
+      // Only attempt to load Node.js modules in a Node.js environment
+      try {
+        // Use a function wrapper to avoid direct require syntax that browsers will parse
+        const dynamicRequire = new Function('module', 'return require(module)');
+        dotenv = dynamicRequire('dotenv');
+        path = dynamicRequire('path');
+        
+        // Configure dotenv if available
+        if (dotenv && dotenv.config) {
+          dotenv.config();
+        }
+      } catch (e) {
+        console.warn('Node.js modules not available:', e.message);
+      }
+    }
+  } catch (e) {
+    console.warn('Unable to determine environment:', e.message);
+  }
+}
+
+// Safe path join function that works in any environment
+const safePath = (base, ...parts) => {
+  if (path && path.join) {
+    return path.join(base, ...parts);
+  } else {
+    return [base, ...parts].filter(Boolean).join('/');
+  }
+};
 
 // Database Configuration
-const DEFAULT_PAGE_SIZE = process.env.DEFAULT_PAGE_SIZE || 10;
-const CARDS_DB_PATH = process.env.MCARD_DB_PATH || path.join(projectRoot, 'public', 'data', 'cards.db');
-const TEST_DB_PATH = process.env.TEST_DB_PATH || path.join(projectRoot,'src','test', 'db' ,'test.db');
+const DEFAULT_PAGE_SIZE = isBrowser ? 10 : (process.env?.DEFAULT_PAGE_SIZE || 10);
+const CARDS_DB_PATH = isBrowser 
+  ? '/data/cards.db' 
+  : (process.env?.MCARD_DB_PATH || safePath(projectRoot, 'public', 'data', 'cards.db'));
+const TEST_DB_PATH = isBrowser
+  ? '/test/db/test.db'
+  : (process.env?.TEST_DB_PATH || safePath(projectRoot, 'src', 'test', 'db', 'test.db'));
+
 // Default Configuration Values
-const DEFAULT_HASH_ALGORITHM = process.env.MCARD_HASH_ALGORITHM || 'md5';
-const DEFAULT_HASH_LENGTH = process.env.DEFAULT_HASH_LENGTH || 64;
+const DEFAULT_HASH_ALGORITHM = isBrowser ? 'sha256' : (process.env?.MCARD_HASH_ALGORITHM || 'sha256');
+const DEFAULT_HASH_LENGTH = isBrowser ? 64 : (process.env?.DEFAULT_HASH_LENGTH || 64);
 
 // Logging Configuration
 const DEFAULT_LOG_LEVEL = 'info';
-const LOG_LEVEL = process.env.LOG_LEVEL || DEFAULT_LOG_LEVEL;
+const LOG_LEVEL = isBrowser ? DEFAULT_LOG_LEVEL : (process.env?.LOG_LEVEL || DEFAULT_LOG_LEVEL);
 
 // Hash Algorithm Configuration
 const HashAlgorithm = (input) => {
@@ -39,7 +83,7 @@ HashAlgorithm.SHA256 = 'sha256';
 HashAlgorithm.SHA384 = 'sha384';
 HashAlgorithm.SHA512 = 'sha512';
 HashAlgorithm.CUSTOM = 'custom';
-HashAlgorithm.DEFAULT = 'md5';
+HashAlgorithm.DEFAULT = 'sha256';
 
 // Hash Algorithm Hierarchy
 const HASH_ALGORITHM_HIERARCHY = {
@@ -56,7 +100,7 @@ const HashAlgorithmMetadata = {
     name: HashAlgorithm.MD5,
     description: 'MD5 hash function',
     outputLength: 32,
-    isDefault: true
+    isDefault: false
   },
   [HashAlgorithm.SHA1]: {
     name: HashAlgorithm.SHA1,
@@ -74,7 +118,7 @@ const HashAlgorithmMetadata = {
     name: HashAlgorithm.SHA256,
     description: 'SHA-256 hash function',
     outputLength: 64,
-    isDefault: false
+    isDefault: true
   },
   [HashAlgorithm.SHA384]: {
     name: HashAlgorithm.SHA384,
diff --git a/src/config/index.js b/src/config/index.js
index 6db52d3..4f8fece 100644
--- a/src/config/index.js
+++ b/src/config/index.js
@@ -8,32 +8,26 @@
 // Check if we're in a browser environment
 const isBrowser = typeof window !== 'undefined';
 
-let config;
+// Import the configuration module - this will work because config_constants.js 
+// now has environment-aware code that works in both browser and Node.js
+import * as config from './config_constants.js';
 
-// Dynamic import based on environment
-if (isBrowser) {
-  // In the browser, use the browser-safe configuration
-  config = require('./browser-constants.js');
-} else {
-  // In Node.js, use the full configuration with process.env support
-  config = require('./config_constants.js');
-}
-
-// Re-export everything from the selected configuration
-module.exports = config;
-
-// Maintain compatibility with both named and default exports
-if (config.default) {
-  module.exports.default = config.default;
-}
-
-// Handle direct module references in ESM
+// Export everything from config_constants
 export default config.default || config;
-export const configConstants = config.configConstants || config;
+export const configConstants = config;
 
-// Export all named exports
-for (const key in config) {
-  if (key !== 'default' && key !== 'configConstants') {
-    exports[key] = config[key];
-  }
-}
+// Re-export named exports for convenience
+export const {
+  DEFAULT_PAGE_SIZE,
+  CARDS_DB_PATH,
+  TEST_DB_PATH,
+  DEFAULT_HASH_ALGORITHM,
+  DEFAULT_HASH_LENGTH,
+  DEFAULT_LOG_LEVEL,
+  LOG_LEVEL,
+  HashAlgorithm,
+  HASH_ALGORITHM_HIERARCHY,
+  HashAlgorithmMetadata,
+  VALID_HASH_FUNCTIONS,
+  projectRoot
+} = config;
diff --git a/src/content/model/event-producer.js b/src/content/model/event-producer.js
index 2faa2cc..cedc8a4 100644
--- a/src/content/model/event-producer.js
+++ b/src/content/model/event-producer.js
@@ -1,4 +1,4 @@
-import HashAlgorithmEnum from './hash/enums.js';
+import { HashAlgorithm as HashAlgorithmEnum } from './hash/enums.js';
 import HashValidator from './hash/validator.js';
 import { GTime as GTimeUtil } from './g_time.js';
 import { HASH_ALGORITHM_HIERARCHY as ALGORITHM_HIERARCHY } from '../../config/config_constants.js';
@@ -10,7 +10,8 @@ const {
   SHA224, 
   SHA256, 
   SHA384, 
-  SHA512 
+  SHA512, 
+  DEFAULT
 } = HashAlgorithmEnum;
 
 // Event type constants
@@ -33,33 +34,43 @@ const COLLISION_EVENT_TYPE = 'collision';
 const HASH_FUNCTION_ORDER = ['md5', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512'];
 
 // Create a new HashValidator instance for use
-const hashValidator = new HashValidator(Buffer.from(''), HashAlgorithmEnum.DEFAULT);
+const hashValidator = new HashValidator(Buffer.from(''), 'sha256');
 
 // Explicitly define HASH_ALGORITHM_HIERARCHY
 const HASH_ALGORITHM_HIERARCHY = {
-  [HashAlgorithmEnum.MD5]: [HashAlgorithmEnum.SHA1],
-  [HashAlgorithmEnum.SHA1]: [HashAlgorithmEnum.SHA224],
-  [HashAlgorithmEnum.SHA224]: [HashAlgorithmEnum.SHA256],
-  [HashAlgorithmEnum.SHA256]: [HashAlgorithmEnum.SHA384],
-  [HashAlgorithmEnum.SHA384]: [HashAlgorithmEnum.SHA512],
-  [HashAlgorithmEnum.SHA512]: []
+  [MD5]: [SHA1],
+  [SHA1]: [SHA224],
+  [SHA224]: [SHA256],
+  [SHA256]: [SHA384],
+  [SHA384]: [SHA512],
+  [SHA512]: []
 };
 
 // Replace existing nextHashFunction with method from instance
 function nextHashFunction(currentHashFunction) {
+  const algMap = {
+    'md5': MD5,
+    'sha1': SHA1,
+    'sha224': SHA224, 
+    'sha256': SHA256,
+    'sha384': SHA384,
+    'sha512': SHA512
+  };
+  
+  const currFunc = algMap[currentHashFunction] || currentHashFunction;
+  
   const hashFunctions = Object.values(HashAlgorithmEnum).filter(
-    func => func !== currentHashFunction
+    func => func !== currFunc && typeof func === 'string' 
   );
   
-  // Find the first stronger hash function based on hierarchy
   const strongerFunctions = hashFunctions.filter(func => {
-    const currentStrongerFuncs = HASH_ALGORITHM_HIERARCHY[currentHashFunction] || [];
+    const currentStrongerFuncs = HASH_ALGORITHM_HIERARCHY[currFunc] || [];
     return currentStrongerFuncs.includes(func);
   });
   
   return strongerFunctions.length > 0 
     ? strongerFunctions[0] 
-    : hashFunctions[0];  // Fallback to first available if no stronger function
+    : currFunc; 
 }
 
 // Generate a duplication event for the given card
@@ -98,8 +109,8 @@ function generateCollisionEvent(newCard, existingCard = null) {
   if (existingCard) {
     const upgradedFunction = nextHashFunction(existingCard.hashFunction);
     event.upgraded_function = upgradedFunction;
-    event.upgraded_hash = existingCard.hash;  // Use existing hash instead of calling non-existent method
-    event.hash_algorithm = upgradedFunction;  // Add hash algorithm for test
+    event.upgraded_hash = existingCard.hash;  
+    event.hash_algorithm = upgradedFunction;  
   }
 
   return JSON.stringify(event);
diff --git a/src/content/model/hash/__init__.js b/src/content/model/hash/__init__.js
index 2309cd6..17f400f 100644
--- a/src/content/model/hash/__init__.js
+++ b/src/content/model/hash/__init__.js
@@ -1,12 +1,24 @@
-const { HashAlgorithm, HASH_ALGORITHM_HIERARCHY } = require('../config/config_constants.js');
-const HashValidator = require('./validator');
-const HashEnums = require('./enums');
-const HashConstants = require('../config/config_constants.js');
+/**
+ * Hash module initialization
+ * Exports all hash-related functionality
+ */
 
-module.exports = {
+import { HashAlgorithm, HASH_ALGORITHM_HIERARCHY } from '../../../config/config_constants.js';
+import HashValidator from './validator.js';
+import * as HashEnums from './enums.js';
+
+// Re-export everything
+export {
+  HashAlgorithm,
+  HASH_ALGORITHM_HIERARCHY,
+  HashValidator,
+  HashEnums
+};
+
+// Default export for convenience
+export default {
   HashAlgorithm,
   HASH_ALGORITHM_HIERARCHY,
   HashValidator,
-  HashEnums,
-  HashConstants
+  HashEnums
 };
diff --git a/src/content/model/hash/algorithms/base_algorithm.js b/src/content/model/hash/algorithms/base_algorithm.js
index 767a21d..9c37430 100644
--- a/src/content/model/hash/algorithms/base_algorithm.js
+++ b/src/content/model/hash/algorithms/base_algorithm.js
@@ -1,4 +1,60 @@
-import crypto from 'crypto';
+// Replace direct crypto import with environment-aware implementation
+// import crypto from 'crypto';
+import { encodeText } from '../../../../utils/textEncoderPolyfill.js';
+
+// Check if we're in a browser environment
+const isBrowser = typeof window !== 'undefined';
+
+// Cross-environment hash function (similar to the one in validator.js)
+const createHash = (algorithm) => {
+  if (isBrowser) {
+    // In browser environments, use Web Crypto API
+    return {
+      update: function(data) {
+        this.data = data;
+        return this;
+      },
+      digest: async function(encoding) {
+        // Convert algorithm name to one supported by Web Crypto API
+        const webCryptoAlg = algorithm === 'md5' ? 'SHA-1' : // Web Crypto doesn't support MD5, fallback to SHA-1
+                            algorithm === 'sha1' ? 'SHA-1' :
+                            algorithm === 'sha224' ? 'SHA-256' : // Web Crypto doesn't support SHA-224, fallback to SHA-256
+                            algorithm === 'sha256' ? 'SHA-256' :
+                            algorithm === 'sha384' ? 'SHA-384' :
+                            algorithm === 'sha512' ? 'SHA-512' : 'SHA-256';
+                            
+        // Convert data to ArrayBuffer if needed
+        const dataBuffer = this.data instanceof Uint8Array 
+          ? this.data.buffer 
+          : encodeText(this.data).buffer;
+        
+        // Use Web Crypto API to compute hash
+        const hashBuffer = await window.crypto.subtle.digest(webCryptoAlg, dataBuffer);
+        
+        // Convert to hex string if requested
+        if (encoding === 'hex') {
+          return Array.from(new Uint8Array(hashBuffer))
+            .map(b => b.toString(16).padStart(2, '0'))
+            .join('');
+        }
+        
+        // Return raw buffer if no encoding specified
+        return new Uint8Array(hashBuffer);
+      }
+    };
+  } else {
+    // In Node.js, use native crypto module
+    try {
+      // Dynamic require to avoid browser parsing issues
+      const dynamicRequire = new Function('module', 'return require(module)');
+      const crypto = dynamicRequire('crypto');
+      return crypto.createHash(algorithm);
+    } catch (e) {
+      console.error('Crypto module not available:', e);
+      throw new Error('Hash functionality not available in this environment');
+    }
+  }
+};
 
 /**
  * Base class for hash algorithms
@@ -17,15 +73,15 @@ class BaseHashAlgorithm {
    * @param {Uint8Array|string} content - Content to hash
    * @returns {string} Computed hash as hex string
    */
-  computeHash(content) {
+  async computeHash(content) {
     // Convert content to Uint8Array if it's a string
     const contentToHash = content instanceof Uint8Array 
       ? content 
-      : new TextEncoder().encode(content);
+      : encodeText(content);
 
-    const hash = crypto.createHash(this.algorithmName);
+    const hash = createHash(this.algorithmName);
     hash.update(contentToHash);
-    return hash.digest('hex');
+    return isBrowser ? await hash.digest('hex') : hash.digest('hex');
   }
 
   /**
@@ -34,8 +90,8 @@ class BaseHashAlgorithm {
    * @param {string} expectedHash - Expected hash value
    * @returns {boolean} True if hash matches, false otherwise
    */
-  validateHash(content, expectedHash) {
-    const computedHash = this.computeHash(content);
+  async validateHash(content, expectedHash) {
+    const computedHash = await this.computeHash(content);
     return computedHash === expectedHash;
   }
 }
diff --git a/src/content/model/hash/enums.js b/src/content/model/hash/enums.js
index 08acd2f..ab56615 100644
--- a/src/content/model/hash/enums.js
+++ b/src/content/model/hash/enums.js
@@ -1,70 +1,172 @@
-import crypto from 'crypto';
-import { HashAlgorithm, HashAlgorithmMetadata } from '../../../config/config_constants.js';
+import { 
+  HashAlgorithm as ConfigHashAlgorithm, 
+  HashAlgorithmMetadata 
+} from '../../../config/config_constants.js';
+import { encodeText } from '../../../utils/textEncoderPolyfill.js';
 
 /**
- * Create a function to get hash algorithm details
- * @param {string} algorithm - Hash algorithm to get details for
- * @returns {Object} Details of the hash algorithm
+ * Common hash algorithm enumerations
  */
-export function getHashAlgorithmDetails(algorithm) {
-  const normalizedAlgorithm = HashAlgorithm(algorithm);
-  return HashAlgorithmMetadata[normalizedAlgorithm] || null;
-}
+
+// Check if we're in a browser environment
+const isBrowser = typeof window !== 'undefined';
+
+// Define valid hash algorithms across environments
+const VALID_HASH_ALGORITHMS = [
+  'md5',
+  'sha1',
+  'sha224',
+  'sha256',
+  'sha384',
+  'sha512'
+];
+
+// Get list of supported hash functions in the current environment
+const getSupportedHashAlgorithms = () => {
+  if (isBrowser) {
+    // In browser, Web Crypto API generally supports these algorithms
+    return [
+      'sha-1',
+      'sha-256',
+      'sha-384',
+      'sha-512'
+    ];
+  } else {
+    // In Node.js, try to get the full list from crypto
+    try {
+      // Dynamic require to avoid browser parsing issues
+      const dynamicRequire = new Function('module', 'return require(module)');
+      const crypto = dynamicRequire('crypto');
+      return crypto.getHashes();
+    } catch (e) {
+      console.warn('Unable to get hash algorithms from crypto:', e.message);
+      // Return common algorithms as fallback
+      return VALID_HASH_ALGORITHMS;
+    }
+  }
+};
+
+export const HashAlgorithm = {
+  MD5: 'md5',
+  SHA1: 'sha1',
+  SHA224: 'sha224',
+  SHA256: 'sha256',
+  SHA384: 'sha384',
+  SHA512: 'sha512',
+  DEFAULT: 'sha256',
+  
+  // Method to check if algorithm is supported
+  isSupported: (algorithm) => {
+    if (!algorithm) return false;
+    const normalized = String(algorithm).toLowerCase().trim();
+    
+    // Get algorithms supported in current environment
+    const supportedAlgorithms = getSupportedHashAlgorithms();
+    
+    return supportedAlgorithms.includes(normalized);
+  }
+};
 
 /**
- * Get the output length of a hash algorithm
- * @param {string} algorithm - Hash algorithm to get output length for
- * @returns {number} Output length of the hash algorithm
+ * Create a function to get hash algorithm details
+ * 
+ * @param {string} algorithm - Algorithm name
+ * @returns {Object} Algorithm details
  */
-export function getHashOutputLength(algorithm) {
-  const details = getHashAlgorithmDetails(algorithm);
-  return details ? details.outputLength : 64; // Default to 64 if not found
+export function getHashAlgorithmDetails(algorithm = HashAlgorithm.DEFAULT) {
+  const normalizedAlgorithm = ConfigHashAlgorithm(algorithm);
+  return HashAlgorithmMetadata[normalizedAlgorithm] || HashAlgorithmMetadata[HashAlgorithm.DEFAULT];
 }
 
 /**
- * Check if a hash algorithm is the default
- * @param {string} algorithm - Hash algorithm to check
- * @returns {boolean} Whether the algorithm is the default
+ * Verify if a hash is valid for a given algorithm
+ * 
+ * @param {string} hash - Hash to verify
+ * @param {string} algorithm - Algorithm name
+ * @returns {boolean} True if hash is valid
  */
-export function isDefaultHashAlgorithm(algorithm) {
-  const details = getHashAlgorithmDetails(algorithm);
-  return details ? details.isDefault : false;
+export function isValidHash(hash, algorithm = HashAlgorithm.DEFAULT) {
+  if (!hash) return false;
+  
+  const algDetails = getHashAlgorithmDetails(algorithm);
+  return hash.length === algDetails.outputLength;
 }
 
 /**
- * Generate a hash using a specified algorithm
+ * Generate a hash from input using specified algorithm
+ * 
  * @param {string} input - Input to hash
- * @param {string} [algorithm] - Hash algorithm to use
- * @returns {string} Generated hash
+ * @param {string} algorithm - Algorithm to use
+ * @returns {string|Promise<string>} Generated hash (Promise in browser)
  */
 export function generateHash(input, algorithm = HashAlgorithm.DEFAULT) {
-  const normalizedAlgorithm = HashAlgorithm(algorithm);
-  const hash = crypto.createHash(normalizedAlgorithm);
-  hash.update(input);
-  return hash.digest('hex');
+  const normalizedAlgorithm = ConfigHashAlgorithm(algorithm);
+  
+  // Convert algorithm name to format supported by Web Crypto API
+  const getCryptoAlgorithm = (alg) => {
+    switch(alg) {
+      case 'md5': return 'SHA-1'; // Web Crypto doesn't support MD5
+      case 'sha1': return 'SHA-1';
+      case 'sha224': return 'SHA-256'; // Fallback to SHA-256
+      case 'sha256': return 'SHA-256';
+      case 'sha384': return 'SHA-384';
+      case 'sha512': return 'SHA-512';
+      default: return 'SHA-256';
+    }
+  };
+  
+  if (isBrowser) {
+    // In browser, use Web Crypto API
+    const textData = typeof input === 'string' ? input : JSON.stringify(input);
+    const encodedData = encodeText(textData);
+    
+    return window.crypto.subtle.digest(
+      getCryptoAlgorithm(normalizedAlgorithm),
+      encodedData.buffer
+    ).then(hash => {
+      return Array.from(new Uint8Array(hash))
+        .map(b => b.toString(16).padStart(2, '0'))
+        .join('');
+    });
+  } else {
+    // In Node.js, use crypto
+    try {
+      const dynamicRequire = new Function('module', 'return require(module)');
+      const crypto = dynamicRequire('crypto');
+      const hash = crypto.createHash(normalizedAlgorithm);
+      hash.update(typeof input === 'string' ? input : JSON.stringify(input));
+      return hash.digest('hex');
+    } catch (e) {
+      console.error('Error generating hash:', e);
+      return '';
+    }
+  }
 }
 
 /**
- * Validate a hash against its algorithm
- * @param {string} hash - Hash to validate
- * @param {string} algorithm - Hash algorithm to validate against
- * @returns {boolean} Whether the hash is valid
+ * Compare two hashes securely
+ * 
+ * @param {string} hash1 - First hash
+ * @param {string} hash2 - Second hash
+ * @returns {boolean} True if hashes match
  */
-export function validateHash(hash, algorithm) {
-  const details = getHashAlgorithmDetails(algorithm);
-  if (!details) return false;
-
-  // Check hash length
-  if (hash.length !== details.outputLength) return false;
-
-  // Check if hash contains only hexadecimal characters
-  return /^[0-9a-fA-F]+$/.test(hash);
+export function compareHashes(hash1, hash2) {
+  if (!hash1 || !hash2) return false;
+  if (hash1.length !== hash2.length) return false;
+  
+  let result = 0;
+  for (let i = 0; i < hash1.length; i++) {
+    result |= hash1.charCodeAt(i) ^ hash2.charCodeAt(i);
+  }
+  
+  return result === 0;
 }
 
 export default {
+  HashAlgorithm,
+  VALID_HASH_ALGORITHMS,
   getHashAlgorithmDetails,
-  getHashOutputLength,
-  isDefaultHashAlgorithm,
+  isValidHash,
   generateHash,
-  validateHash
+  compareHashes
 };
diff --git a/src/content/model/hash/validator.js b/src/content/model/hash/validator.js
index f946969..f3b4f72 100644
--- a/src/content/model/hash/validator.js
+++ b/src/content/model/hash/validator.js
@@ -1,23 +1,115 @@
-import crypto from 'crypto';
-import { TextEncoder } from 'util';
+// Replace direct crypto import with environment-aware implementation
+import { encodeText } from '../../../utils/textEncoderPolyfill.js';
+import { SafeBuffer } from '../../../utils/bufferPolyfill.js';
 import { 
   HashAlgorithm, 
   HASH_ALGORITHM_HIERARCHY, 
   VALID_HASH_FUNCTIONS 
 } from '../../../config/config_constants.js';
 
+// Check if we're in a browser environment
+const isBrowser = typeof window !== 'undefined';
+
+// Create a cross-environment crypto hash function that works in both browser and Node.js
+const createHash = (algorithm) => {
+  // Convert to lowercase and remove hyphens for consistency
+  const normalizedAlg = String(algorithm).toLowerCase().replace('-', '');
+  
+  if (isBrowser) {
+    // In browser environments, use Web Crypto API
+    return {
+      data: null,
+      update: function(data) {
+        this.data = data;
+        return this;
+      },
+      digest: async function(encoding) {
+        if (!this.data) return encoding === 'hex' ? '' : new Uint8Array();
+        
+        // Convert algorithm name to one supported by Web Crypto API
+        const webCryptoAlg = 
+          normalizedAlg === 'md5' ? 'SHA-1' : // Web Crypto doesn't support MD5, fallback to SHA-1
+          normalizedAlg === 'sha1' ? 'SHA-1' :
+          normalizedAlg === 'sha224' ? 'SHA-256' : // Web Crypto doesn't support SHA-224
+          normalizedAlg === 'sha256' ? 'SHA-256' :
+          normalizedAlg === 'sha384' ? 'SHA-384' :
+          normalizedAlg === 'sha512' ? 'SHA-512' : 'SHA-256';
+        
+        try {
+          // Ensure data is a proper Uint8Array
+          const dataBuffer = this.data instanceof Uint8Array 
+            ? this.data.buffer 
+            : encodeText(this.data).buffer;
+          
+          // Use Web Crypto API to compute hash
+          const hashBuffer = await window.crypto.subtle.digest(webCryptoAlg, dataBuffer);
+          
+          // Convert to hex string if requested
+          if (encoding === 'hex') {
+            return Array.from(new Uint8Array(hashBuffer))
+              .map(b => b.toString(16).padStart(2, '0'))
+              .join('');
+          }
+          
+          // Return raw buffer if no encoding specified
+          return new Uint8Array(hashBuffer);
+        } catch (e) {
+          console.error('Error using Web Crypto API:', e);
+          return encoding === 'hex' ? '' : new Uint8Array();
+        }
+      }
+    };
+  } else {
+    // In Node.js, try to use native crypto module
+    try {
+      // Only attempt to use require in non-browser environments
+      const crypto = require('crypto');
+      return crypto.createHash(normalizedAlg);
+    } catch (e) {
+      console.error('Crypto module not available:', e);
+      
+      // Return a dummy hash object that does nothing
+      return {
+        update: function() { return this; },
+        digest: function(encoding) { 
+          return encoding === 'hex' ? 'no-crypto-available' : new Uint8Array();
+        }
+      };
+    }
+  }
+};
+
 export default class HashValidator {
   /**
    * Constructor for HashValidator
    */
   constructor(content, hashAlgorithm = HashAlgorithm.DEFAULT) {
-    // Convert content to Buffer if it's a string
-    this.content = content instanceof Buffer 
+    // Convert content to Buffer/Uint8Array if it's a string
+    this.content = SafeBuffer.isBuffer(content) 
       ? content 
-      : new TextEncoder().encode(content);
+      : encodeText(content);
     
     this.hashAlgorithm = this.normalizeHashAlgorithm(hashAlgorithm);
-    this.hashValue = this.computeHash();
+    
+    // In browser environments, we can't synchronously compute crypto hashes
+    if (isBrowser) {
+      this.hashValue = "computing...";
+      this._computeHashAsync().then(hash => {
+        this.hashValue = hash;
+      });
+    } else {
+      this.hashValue = this.computeHash();
+    }
+  }
+  
+  /**
+   * Async computation of hash for browser environments
+   * @private
+   */
+  async _computeHashAsync() {
+    const hash = createHash(this.hashAlgorithm);
+    hash.update(this.content);
+    return await hash.digest('hex');
   }
 
   /**
@@ -28,20 +120,21 @@ export default class HashValidator {
   normalizeHashAlgorithm(hashAlgorithm) {
     // Handle undefined or null input
     if (hashAlgorithm === undefined || hashAlgorithm === null) {
-      return HashAlgorithm.DEFAULT;
+      return HashAlgorithm.DEFAULT || 'sha256';
     }
     
     // If input is an object, try to extract the type
     if (typeof hashAlgorithm === 'object') {
-      hashAlgorithm = hashAlgorithm.type || hashAlgorithm.value || HashAlgorithm.DEFAULT;
+      hashAlgorithm = hashAlgorithm.type || hashAlgorithm.value || HashAlgorithm.DEFAULT || 'sha256';
     }
     
-    // Convert to lowercase string
-    const normalizedAlgo = String(hashAlgorithm).toLowerCase();
+    // Convert to lowercase string and remove dashes for consistency
+    const normalizedAlgo = String(hashAlgorithm).toLowerCase().replace('-', '');
     
     // Validate the hash algorithm
     if (!HashValidator.isValidHashFunction(normalizedAlgo)) {
-      throw new Error(`Invalid hash algorithm: ${normalizedAlgo}`);
+      console.warn(`Invalid hash algorithm: ${normalizedAlgo}, using default instead`);
+      return HashAlgorithm.DEFAULT || 'sha256';
     }
     
     return normalizedAlgo;
@@ -56,21 +149,36 @@ export default class HashValidator {
     if (!hashFunction) return false;
     
     const normalizedFunc = String(hashFunction).toLowerCase().trim();
-    return crypto.getHashes().includes(normalizedFunc);
+    
+    // Accept both formats: with dashes (Web Crypto format) and without dashes (Node.js format)
+    const validAlgorithms = [
+      // Node.js format
+      'md5', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512',
+      // Web Crypto format
+      'sha-1', 'sha-256', 'sha-384', 'sha-512'
+    ];
+    
+    return validAlgorithms.includes(normalizedFunc) || 
+           validAlgorithms.includes(normalizedFunc.replace('-', ''));
   }
 
   /**
-   * Computes hash for the content
+   * Compute hash from content
    * @returns {string} Computed hash
    */
   computeHash() {
+    if (isBrowser) {
+      // In browser, we can't compute synchronously
+      return "computing...";
+    }
+    
     try {
-      const hash = crypto.createHash(this.hashAlgorithm);
+      const hash = createHash(this.hashAlgorithm);
       hash.update(this.content);
       return hash.digest('hex');
-    } catch (error) {
-      console.error(`Error computing hash with ${this.hashAlgorithm}:`, error);
-      return null;
+    } catch (e) {
+      console.error('Error computing hash:', e);
+      return '';
     }
   }
 
@@ -92,28 +200,41 @@ export default class HashValidator {
 
   /**
    * Static method to compute hash
-   * @param {Buffer|string} content - Content to hash
-   * @param {string} [hashAlgorithm=HashAlgorithm.DEFAULT] - Hash algorithm to use
-   * @returns {string} Computed hash
+   * @param {string|Buffer} content - Content to hash
+   * @param {string} hashAlgorithm - Algorithm to use
+   * @returns {string|Promise<string>} Computed hash or Promise of hash in browser
    */
   static computeHash(content, hashAlgorithm = HashAlgorithm.DEFAULT) {
-    const encoder = new TextEncoder();
-    const buffer = content instanceof Buffer 
+    const buffer = SafeBuffer.isBuffer(content) 
       ? content 
-      : encoder.encode(content);
+      : encodeText(content);
     
-    const hash = crypto.createHash(hashAlgorithm);
+    const hash = createHash(hashAlgorithm);
     hash.update(buffer);
+    
+    if (isBrowser) {
+      // In browser, we need to handle async
+      return hash.digest('hex');
+    }
+    
     return hash.digest('hex');
   }
 
   /**
    * Validate hash against an expected hash
    * @param {string} [expectedHash] - Expected hash value
-   * @returns {boolean} True if hash matches, false otherwise
+   * @returns {boolean|Promise<boolean>} True if hash matches, false otherwise
    */
   validate(expectedHash) {
     if (!expectedHash) return false;
+    
+    if (isBrowser) {
+      // In browser, we need to handle async validation
+      return this._computeHashAsync().then(computedHash => {
+        return computedHash === expectedHash;
+      });
+    }
+    
     return this.hashValue === expectedHash;
   }
 
diff --git a/src/content/model/interpreter.ts b/src/content/model/interpreter.ts
index 045dc3a..85c1a3f 100644
--- a/src/content/model/interpreter.ts
+++ b/src/content/model/interpreter.ts
@@ -1,3 +1,5 @@
+import { encodeText } from '../../utils/textEncoderPolyfill.js';
+
 /**
  * Content Type Interpreter for Client-Side Use
  * Lightweight and efficient content type detection
@@ -41,7 +43,7 @@ export class ContentTypeInterpreter {
     }
 
     if (typeof input === 'string') {
-      return new TextEncoder().encode(input);
+      return encodeText(input);
     }
 
     // Handle Node.js Buffer
@@ -53,7 +55,7 @@ export class ContentTypeInterpreter {
     if (typeof input === 'object') {
       try {
         const jsonString = JSON.stringify(input);
-        return new TextEncoder().encode(jsonString);
+        return encodeText(jsonString);
       } catch {
         throw new Error('Failed to convert object to Uint8Array');
       }
diff --git a/src/lib/auth/authentikService.js b/src/lib/auth/authentikService.js
index d3a6a7c..feb04b3 100644
--- a/src/lib/auth/authentikService.js
+++ b/src/lib/auth/authentikService.js
@@ -9,6 +9,8 @@
 // Helper to check if code is running in browser
 const isBrowser = typeof window !== 'undefined';
 
+import { encodeText } from '../../utils/textEncoderPolyfill.js';
+
 /**
  * Default authentication configuration
  */
@@ -64,8 +66,7 @@ export async function generateCodeChallenge(codeVerifier) {
   }
   
   // Convert string to Uint8Array
-  const encoder = new TextEncoder();
-  const data = encoder.encode(codeVerifier);
+  const data = encodeText(codeVerifier);
   
   // Hash the code verifier with SHA-256
   const hash = await window.crypto.subtle.digest('SHA-256', data);
diff --git a/src/utils/bufferPolyfill.js b/src/utils/bufferPolyfill.js
new file mode 100644
index 0000000..00f5cf3
--- /dev/null
+++ b/src/utils/bufferPolyfill.js
@@ -0,0 +1,151 @@
+/**
+ * Cross-environment Buffer compatibility layer
+ * 
+ * This module provides a Buffer implementation that works in both
+ * Node.js and browser environments, preventing hydration errors.
+ */
+
+import { encodeText } from './textEncoderPolyfill.js';
+
+// Check if we're in a browser environment
+const isBrowser = typeof window !== 'undefined';
+
+/**
+ * SafeBuffer - A cross-environment Buffer-like implementation
+ * 
+ * Uses Node.js Buffer when available, or a Uint8Array-based implementation in browsers.
+ */
+class SafeBuffer {
+  /**
+   * Create a new Buffer from string, array, or ArrayBuffer
+   * @param {string|Array|ArrayBuffer|Uint8Array} data - Input data
+   * @param {string} [encoding='utf8'] - Encoding to use if data is a string
+   * @returns {Uint8Array} - Buffer-like Uint8Array
+   */
+  static from(data, encoding = 'utf8') {
+    // If in Node.js environment, use native Buffer
+    if (!isBrowser && typeof Buffer !== 'undefined') {
+      return Buffer.from(data, encoding);
+    }
+    
+    // Browser environment implementation
+    if (typeof data === 'string') {
+      return encodeText(data);
+    } else if (data instanceof Uint8Array || data instanceof ArrayBuffer) {
+      return data instanceof Uint8Array ? data : new Uint8Array(data);
+    } else if (Array.isArray(data)) {
+      return new Uint8Array(data);
+    } else if (data === null || data === undefined) {
+      return new Uint8Array();
+    } else if (typeof data === 'object') {
+      // Try to convert object to JSON string
+      try {
+        return encodeText(JSON.stringify(data));
+      } catch (e) {
+        console.error('Error converting object to Buffer:', e);
+        return new Uint8Array();
+      }
+    }
+    
+    // Fallback for unexpected inputs
+    return new Uint8Array();
+  }
+  
+  /**
+   * Create a new Buffer of specified size
+   * @param {number} size - Size of the buffer to allocate
+   * @param {number} [fill=0] - Value to fill the buffer with
+   * @returns {Uint8Array} - Buffer-like Uint8Array
+   */
+  static alloc(size, fill = 0) {
+    // If in Node.js environment, use native Buffer
+    if (!isBrowser && typeof Buffer !== 'undefined') {
+      return Buffer.alloc(size, fill);
+    }
+    
+    // Browser implementation
+    const buffer = new Uint8Array(size);
+    if (fill !== 0) {
+      buffer.fill(fill);
+    }
+    return buffer;
+  }
+  
+  /**
+   * Combine multiple buffers into one
+   * @param {Array<Uint8Array>} buffers - Array of buffers to combine
+   * @returns {Uint8Array} - Combined buffer
+   */
+  static concat(buffers) {
+    // If in Node.js environment, use native Buffer
+    if (!isBrowser && typeof Buffer !== 'undefined') {
+      return Buffer.concat(buffers);
+    }
+    
+    // Browser implementation
+    // Calculate total length
+    const totalLength = buffers.reduce((acc, buf) => acc + buf.length, 0);
+    
+    // Create new buffer with total length
+    const result = new Uint8Array(totalLength);
+    
+    // Copy each buffer into the result buffer
+    let offset = 0;
+    for (const buf of buffers) {
+      result.set(buf, offset);
+      offset += buf.length;
+    }
+    
+    return result;
+  }
+  
+  /**
+   * Check if object is a Buffer
+   * @param {any} obj - Object to check
+   * @returns {boolean} - True if obj is a Buffer or Uint8Array
+   */
+  static isBuffer(obj) {
+    // If in Node.js environment, use native Buffer.isBuffer
+    if (!isBrowser && typeof Buffer !== 'undefined') {
+      return Buffer.isBuffer(obj);
+    }
+    
+    // In browser, check if it's a Uint8Array
+    return obj instanceof Uint8Array;
+  }
+  
+  /**
+   * Convert buffer to string
+   * @param {Uint8Array} buffer - Buffer to convert
+   * @param {string} [encoding='utf8'] - Encoding to use
+   * @returns {string} - String representation of buffer
+   */
+  static toString(buffer, encoding = 'utf8') {
+    // If in Node.js environment, use native Buffer
+    if (!isBrowser && typeof Buffer !== 'undefined' && Buffer.isBuffer(buffer)) {
+      return buffer.toString(encoding);
+    }
+    
+    // Browser implementation
+    // For now, only support UTF-8 encoding
+    if (!(buffer instanceof Uint8Array)) {
+      return '';
+    }
+    
+    // Use TextDecoder if available
+    if (typeof TextDecoder !== 'undefined') {
+      return new TextDecoder('utf-8').decode(buffer);
+    }
+    
+    // Fallback implementation
+    let result = '';
+    for (let i = 0; i < buffer.length; i++) {
+      result += String.fromCharCode(buffer[i]);
+    }
+    return result;
+  }
+}
+
+// Export SafeBuffer as default and named export
+export default SafeBuffer;
+export { SafeBuffer };
diff --git a/src/utils/storeAdapter.ts b/src/utils/storeAdapter.ts
index 2b3484e..4d301d8 100644
--- a/src/utils/storeAdapter.ts
+++ b/src/utils/storeAdapter.ts
@@ -1,6 +1,7 @@
 import { MCard } from '../content/model/mcard.js';
 import { SQLiteEngine, SQLiteConnection } from '../engine/sqlite_engine.js';
 import { CARDS_DB_PATH } from '../config/config_constants.js';
+import { encodeText } from './textEncoderPolyfill.js';
 
 // Singleton instance
 let engineInstance: SQLiteEngine | null = null;
@@ -30,9 +31,8 @@ export function getStoreEngine(): SQLiteEngine {
  */
 function safeBufferFrom(content: string): any {
   try {
-    // Use TextEncoder to convert string to Uint8Array in any environment
-    const encoder = new TextEncoder();
-    return encoder.encode(content);
+    // Use polyfill to convert string to Uint8Array in any environment
+    return encodeText(content);
   } catch (error) {
     console.error('Error creating buffer:', error);
     throw error;
diff --git a/src/utils/textEncoderPolyfill.js b/src/utils/textEncoderPolyfill.js
new file mode 100644
index 0000000..51eda6d
--- /dev/null
+++ b/src/utils/textEncoderPolyfill.js
@@ -0,0 +1,88 @@
+/**
+ * Cross-environment TextEncoder compatibility layer
+ * 
+ * This module provides a TextEncoder implementation that works in both
+ * Node.js and browser environments, avoiding hydration errors.
+ */
+
+// Detect the environment
+const isBrowser = typeof window !== 'undefined';
+
+// Get the appropriate TextEncoder instance based on environment
+const getTextEncoder = () => {
+  // Browser environment - use built-in TextEncoder if available
+  if (isBrowser && typeof window.TextEncoder !== 'undefined') {
+    return new window.TextEncoder();
+  }
+  
+  // Global TextEncoder (modern browsers and some Node.js environments)
+  if (typeof TextEncoder !== 'undefined') {
+    return new TextEncoder();
+  }
+  
+  // Node.js environment - use util.TextEncoder but only if we're not in a browser
+  if (!isBrowser && typeof process !== 'undefined' && process.versions && process.versions.node) {
+    try {
+      // Use dynamic import technique to avoid browser parsing issues
+      const dynamicRequire = new Function('module', 'return require(module)');
+      const util = dynamicRequire('util');
+      if (util && util.TextEncoder) {
+        return new util.TextEncoder();
+      }
+    } catch (e) {
+      // Fall through to the polyfill
+    }
+  }
+  
+  // Fallback implementation for environments without TextEncoder
+  return {
+    encode: (str) => {
+      if (!str) return new Uint8Array();
+      
+      const utf8 = [];
+      for (let i = 0; i < str.length; i++) {
+        let charCode = str.charCodeAt(i);
+        if (charCode < 0x80) {
+          utf8.push(charCode);
+        } else if (charCode < 0x800) {
+          utf8.push(0xc0 | (charCode >> 6), 
+                    0x80 | (charCode & 0x3f));
+        } else if (charCode < 0xd800 || charCode >= 0xe000) {
+          utf8.push(0xe0 | (charCode >> 12), 
+                    0x80 | ((charCode >> 6) & 0x3f), 
+                    0x80 | (charCode & 0x3f));
+        } else {
+          // Handle surrogate pair
+          i++;
+          charCode = ((charCode & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff);
+          charCode += 0x10000;
+          utf8.push(0xf0 | (charCode >> 18), 
+                    0x80 | ((charCode >> 12) & 0x3f), 
+                    0x80 | ((charCode >> 6) & 0x3f), 
+                    0x80 | (charCode & 0x3f));
+        }
+      }
+      return new Uint8Array(utf8);
+    }
+  };
+};
+
+// Create a singleton instance
+const textEncoder = getTextEncoder();
+
+// Export the encode function as the main API
+export const encodeText = (text) => {
+  if (text === null || text === undefined) {
+    return new Uint8Array();
+  }
+  
+  // Convert non-string inputs to strings
+  const inputString = typeof text === 'string' ? text : String(text);
+  return textEncoder.encode(inputString);
+};
+
+// Export the encoder instance itself
+export { textEncoder };
+
+// Default export is the encode function
+export default encodeText;

commit b41d4d15c9e8592dc5a44bfe077738cfa1104901
Author: Henrykoo <lckoo1230@gmail.com>
Date:   Wed Mar 26 10:57:04 2025 +0800

    new retriver

diff --git a/src/components/panels/DatabaseRetrievePanel.tsx b/src/components/panels/DatabaseRetrievePanel.tsx
new file mode 100644
index 0000000..22e5bc5
--- /dev/null
+++ b/src/components/panels/DatabaseRetrievePanel.tsx
@@ -0,0 +1,386 @@
+import React, { useState, useEffect } from 'react';
+import { ContentTypeInterpreter } from '../../content/model/interpreter';
+import { MCardFromData } from '../../content/model/mcard';
+
+interface PageData {
+  items: MCardFromData[];
+  total_items: number;
+  page_number: number;
+  page_size: number;
+  has_next: boolean;
+  has_previous: boolean;
+  total_pages: number;
+  previous_page: number | null;
+  next_page: number | null;
+  serverTimestamp?: string;
+  retrievalMethod?: string;
+}
+
+export const DatabaseRetrievePanel: React.FC = () => {
+  const [cards, setCards] = useState<PageData | null>(null);
+  const [loading, setLoading] = useState(false);
+  const [error, setError] = useState<string | null>(null);
+  const [page, setPage] = useState(1);
+  const [pageSize, setPageSize] = useState(10);
+  const [searchTerm, setSearchTerm] = useState('');
+  const [hashValue, setHashValue] = useState('');
+  const [selectedCard, setSelectedCard] = useState<MCardFromData | null>(null);
+  const [viewMode, setViewMode] = useState<'raw' | 'formatted'>('formatted');
+
+  // Function to fetch cards
+  const fetchCards = async (params: {
+    page?: number;
+    pageSize?: number;
+    search?: string;
+    hash?: string;
+  }) => {
+    try {
+      setLoading(true);
+      setError(null);
+
+      // Build the query parameters
+      const queryParams = new URLSearchParams();
+      if (params.page) queryParams.append('page', params.page.toString());
+      if (params.pageSize) queryParams.append('pageSize', params.pageSize.toString());
+      if (params.search) queryParams.append('search', params.search);
+      if (params.hash) queryParams.append('hash', params.hash);
+
+      // Make the API request
+      const response = await fetch(`/api/retrieve?${queryParams.toString()}`);
+
+      if (!response.ok) {
+        const errorData = await response.json();
+        throw new Error(errorData.error || 'Failed to fetch cards');
+      }
+
+      const data = await response.json();
+      setCards(data);
+      
+      // Clear selected card when fetching new cards
+      setSelectedCard(null);
+    } catch (err) {
+      setError(err instanceof Error ? err.message : 'An unknown error occurred');
+      console.error('Error fetching cards:', err);
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  // Initial fetch on component mount
+  useEffect(() => {
+    fetchCards({ page, pageSize });
+  }, []);
+
+  // Handle search form submission
+  const handleSearch = (e: React.FormEvent) => {
+    e.preventDefault();
+    if (searchTerm) {
+      setPage(1); // Reset to first page when searching
+      fetchCards({ search: searchTerm, page: 1, pageSize });
+    }
+  };
+
+  // Handle hash lookup form submission
+  const handleHashLookup = (e: React.FormEvent) => {
+    e.preventDefault();
+    if (hashValue) {
+      fetchCards({ hash: hashValue });
+    }
+  };
+
+  // Handle pagination
+  const handlePageChange = (newPage: number) => {
+    setPage(newPage);
+    if (searchTerm) {
+      fetchCards({ search: searchTerm, page: newPage, pageSize });
+    } else {
+      fetchCards({ page: newPage, pageSize });
+    }
+  };
+
+  // Handle viewing card details
+  const handleViewCard = (card: MCardFromData) => {
+    setSelectedCard(card);
+  };
+
+  // Helper function to format content based on type
+  const formatContent = (content: any): string => {
+    if (typeof content === 'object') {
+      return JSON.stringify(content, null, 2);
+    }
+    return String(content);
+  };
+
+  // Helper function to detect content type
+  const detectContentType = (card: MCardFromData) => {
+    // First try to use the card's native content type if available
+    if (card._content_type) {
+      return card._content_type;
+    }
+    
+    // Fallback to static detection
+    return ContentTypeInterpreter.detectContentType(card.content);
+  };
+
+  // Helper function to get a display label for content type
+  const getContentTypeLabel = (contentType: any) => {
+    if (!contentType) return 'Unknown';
+    
+    // Handle different content type structures
+    if (contentType.mimeType) {
+      const mime = contentType.mimeType;
+      const ext = contentType.extension || '';
+      return `${mime}${ext ? ` (.${ext})` : ''}`;
+    }
+    
+    // Fallback to string representation
+    return String(contentType);
+  };
+
+  // Helper function to format date
+  const formatDate = (dateString: string) => {
+    try {
+      return new Date(dateString).toLocaleString();
+    } catch (e) {
+      return dateString;
+    }
+  };
+
+  return (
+    <div className="bg-white shadow-md rounded-lg p-6">
+      {/* Search and Hash Lookup Forms */}
+      <div className="flex flex-col md:flex-row gap-4 mb-6">
+        <form onSubmit={handleSearch} className="flex-1">
+          <div className="flex flex-col md:flex-row gap-2">
+            <input
+              type="text"
+              value={searchTerm}
+              onChange={(e) => setSearchTerm(e.target.value)}
+              placeholder="Search by content..."
+              className="flex-1 px-4 py-2 border rounded"
+            />
+            <button
+              type="submit"
+              className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
+              disabled={loading}
+            >
+              Search
+            </button>
+          </div>
+        </form>
+
+        <form onSubmit={handleHashLookup} className="flex-1">
+          <div className="flex flex-col md:flex-row gap-2">
+            <input
+              type="text"
+              value={hashValue}
+              onChange={(e) => setHashValue(e.target.value)}
+              placeholder="Lookup by hash..."
+              className="flex-1 px-4 py-2 border rounded"
+            />
+            <button
+              type="submit"
+              className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600"
+              disabled={loading}
+            >
+              Lookup
+            </button>
+          </div>
+        </form>
+      </div>
+
+      {/* Reset and Page Size Controls */}
+      <div className="flex flex-col md:flex-row justify-between items-center mb-6">
+        <button
+          onClick={() => {
+            setSearchTerm('');
+            setHashValue('');
+            setPage(1);
+            fetchCards({ page: 1, pageSize });
+          }}
+          className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 mb-2 md:mb-0"
+          disabled={loading}
+        >
+          Reset
+        </button>
+        
+        <div className="flex items-center">
+          <span className="mr-2">Items per page:</span>
+          <select
+            value={pageSize}
+            onChange={(e) => {
+              const newSize = Number(e.target.value);
+              setPageSize(newSize);
+              setPage(1); // Reset to first page when changing page size
+              
+              // Refetch with new page size
+              if (searchTerm) {
+                fetchCards({ search: searchTerm, page: 1, pageSize: newSize });
+              } else {
+                fetchCards({ page: 1, pageSize: newSize });
+              }
+            }}
+            className="px-2 py-1 border rounded"
+          >
+            <option value="5">5</option>
+            <option value="10">10</option>
+            <option value="20">20</option>
+            <option value="50">50</option>
+          </select>
+        </div>
+      </div>
+
+      {/* Error Display */}
+      {error && (
+        <div className="bg-red-100 border-l-4 border-red-500 text-red-700 p-4 mb-6">
+          <p>{error}</p>
+        </div>
+      )}
+
+      {/* Loading Indicator */}
+      {loading && (
+        <div className="flex justify-center mb-6">
+          <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-blue-500"></div>
+        </div>
+      )}
+
+      {/* Results Display */}
+      {cards && cards.items.length > 0 ? (
+        <div>
+          {/* Results Summary */}
+          <div className="mb-4">
+            <p className="text-gray-700">
+              {cards.retrievalMethod === 'hash'
+                ? 'Card found by hash'
+                : `Showing ${cards.items.length} of ${cards.total_items} cards`}
+              {cards.serverTimestamp && ` (as of ${formatDate(cards.serverTimestamp)})`}
+            </p>
+          </div>
+
+          {/* Card List */}
+          <div className="grid grid-cols-1 gap-4 mb-6">
+            {cards.items.map((card) => (
+              <div
+                key={card.hash}
+                className="border rounded p-4 cursor-pointer hover:bg-gray-50"
+                onClick={() => handleViewCard(card)}
+              >
+                <div className="flex justify-between mb-2">
+                  <span className="font-medium text-blue-600">
+                    {card.hash.substring(0, 10)}...
+                  </span>
+                  <span className="text-gray-500 text-sm">
+                    {formatDate(card.g_time)}
+                  </span>
+                </div>
+                <div className="text-gray-700 truncate">
+                  {typeof card.content === 'object'
+                    ? '{...}'
+                    : String(card.content).substring(0, 80)}
+                </div>
+              </div>
+            ))}
+          </div>
+
+          {/* Pagination */}
+          {cards.total_pages > 1 && (
+            <div className="flex justify-center gap-2 mb-6">
+              <button
+                onClick={() => handlePageChange(page - 1)}
+                disabled={!cards.has_previous}
+                className={`px-3 py-1 rounded ${
+                  cards.has_previous
+                    ? 'bg-blue-100 text-blue-800 hover:bg-blue-200'
+                    : 'bg-gray-100 text-gray-400 cursor-not-allowed'
+                }`}
+              >
+                Previous
+              </button>
+              <span className="px-3 py-1">
+                Page {cards.page_number} of {cards.total_pages}
+              </span>
+              <button
+                onClick={() => handlePageChange(page + 1)}
+                disabled={!cards.has_next}
+                className={`px-3 py-1 rounded ${
+                  cards.has_next
+                    ? 'bg-blue-100 text-blue-800 hover:bg-blue-200'
+                    : 'bg-gray-100 text-gray-400 cursor-not-allowed'
+                }`}
+              >
+                Next
+              </button>
+            </div>
+          )}
+        </div>
+      ) : (
+        !loading && (
+          <div className="text-center text-gray-500 py-8">
+            {cards ? 'No cards found' : 'Enter search terms or fetch cards'}
+          </div>
+        )
+      )}
+
+      {/* Selected Card Detail View */}
+      {selectedCard && (
+        <div className="mt-8 border-t pt-6">
+          <h3 className="text-xl font-semibold mb-4">Card Details</h3>
+          
+          <div className="mb-4">
+            <div className="flex justify-between">
+              <div>
+                <span className="font-medium">Hash: </span>
+                <span className="font-mono">{selectedCard.hash}</span>
+              </div>
+              <div>
+                <button
+                  onClick={() => setViewMode(viewMode === 'raw' ? 'formatted' : 'raw')}
+                  className="px-3 py-1 text-sm bg-gray-200 rounded hover:bg-gray-300"
+                >
+                  {viewMode === 'raw' ? 'Formatted View' : 'Raw View'}
+                </button>
+              </div>
+            </div>
+          </div>
+          
+          <div className="mb-4">
+            <span className="font-medium">Created: </span>
+            <span>{formatDate(selectedCard.g_time)}</span>
+          </div>
+          
+          <div className="mb-4">
+            <span className="font-medium">Content Type: </span>
+            <span>{getContentTypeLabel(detectContentType(selectedCard))}</span>
+          </div>
+          
+          <div className="mb-4">
+            <div className="font-medium mb-2">Content:</div>
+            <pre className="bg-gray-100 p-4 rounded overflow-auto max-h-96 font-mono text-sm">
+              {viewMode === 'raw' 
+                ? typeof selectedCard.content === 'object' 
+                  ? JSON.stringify(selectedCard.content)
+                  : String(selectedCard.content)
+                : formatContent(selectedCard.content)
+              }
+            </pre>
+          </div>
+          
+          <div className="mt-2">
+            <button
+              onClick={() => {
+                const content = typeof selectedCard.content === 'object' 
+                  ? JSON.stringify(selectedCard.content, null, 2)
+                  : String(selectedCard.content);
+                navigator.clipboard.writeText(content);
+                // You could add a toast notification here
+              }}
+              className="px-3 py-1 text-sm bg-blue-500 text-white rounded hover:bg-blue-600"
+            >
+              Copy Content
+            </button>
+          </div>
+        </div>
+      )}
+    </div>
+  );
+};
diff --git a/src/config/browser-constants.js b/src/config/browser-constants.js
new file mode 100644
index 0000000..622c434
--- /dev/null
+++ b/src/config/browser-constants.js
@@ -0,0 +1,146 @@
+/**
+ * Browser-compatible configuration constants
+ * This file is only used in browser environments and contains no Node.js specific code
+ */
+
+// Hash constants
+const MD5 = 'md5';
+const SHA1 = 'sha1';
+const SHA224 = 'sha224';
+const SHA256 = 'sha256';
+const SHA384 = 'sha384';
+const SHA512 = 'sha512';
+
+// Browser-safe constants
+const DEFAULT_PAGE_SIZE = 10;
+const DEFAULT_HASH_ALGORITHM = MD5;
+const DEFAULT_HASH_LENGTH = 64;
+const DEFAULT_LOG_LEVEL = 'info';
+const LOG_LEVEL = DEFAULT_LOG_LEVEL;
+const CARDS_DB_PATH = '/data/cards.db';
+const TEST_DB_PATH = '/test/db/test.db';
+const projectRoot = '';
+
+// Browser-safe algorithm config
+const HashAlgorithm = function(input) {
+  if (!input) return DEFAULT_HASH_ALGORITHM;
+  
+  if (typeof input === 'string') {
+    const normalized = input.toLowerCase();
+    switch (normalized) {
+      case MD5:
+      case SHA1:
+      case SHA224:
+      case SHA256:
+      case SHA384:
+      case SHA512:
+        return normalized;
+      default:
+        return DEFAULT_HASH_ALGORITHM;
+    }
+  }
+  
+  return DEFAULT_HASH_ALGORITHM;
+};
+
+// Add properties to HashAlgorithm
+HashAlgorithm.MD5 = MD5;
+HashAlgorithm.SHA1 = SHA1;
+HashAlgorithm.SHA224 = SHA224;
+HashAlgorithm.SHA256 = SHA256;
+HashAlgorithm.SHA384 = SHA384;
+HashAlgorithm.SHA512 = SHA512;
+HashAlgorithm.DEFAULT = DEFAULT_HASH_ALGORITHM;
+
+// Hash algorithm hierarchy
+const HASH_ALGORITHM_HIERARCHY = {
+  [MD5]: SHA1,
+  [SHA1]: SHA224,
+  [SHA224]: SHA256,
+  [SHA256]: SHA384,
+  [SHA384]: SHA512,
+  [SHA512]: SHA512
+};
+
+// Hash metadata
+const HashAlgorithmMetadata = {
+  [MD5]: {
+    name: 'MD5',
+    description: 'MD5 message digest algorithm',
+    secure: false,
+    strength: 1
+  },
+  [SHA1]: {
+    name: 'SHA-1',
+    description: 'Secure Hash Algorithm 1',
+    secure: false,
+    strength: 2
+  },
+  [SHA224]: {
+    name: 'SHA-224',
+    description: 'Secure Hash Algorithm 2 (224 bits)',
+    secure: true,
+    strength: 3
+  },
+  [SHA256]: {
+    name: 'SHA-256',
+    description: 'Secure Hash Algorithm 2 (256 bits)',
+    secure: true,
+    strength: 4
+  },
+  [SHA384]: {
+    name: 'SHA-384',
+    description: 'Secure Hash Algorithm 2 (384 bits)',
+    secure: true,
+    strength: 5
+  },
+  [SHA512]: {
+    name: 'SHA-512',
+    description: 'Secure Hash Algorithm 2 (512 bits)',
+    secure: true,
+    strength: 6
+  }
+};
+
+const VALID_HASH_FUNCTIONS = Object.keys(HashAlgorithmMetadata);
+
+// Browser-safe path joining utility
+const pathJoin = (...parts) => {
+  return parts.filter(part => part && part.trim() !== '').join('/');
+};
+
+// Create config object for export
+const configConstants = {
+  DEFAULT_PAGE_SIZE,
+  CARDS_DB_PATH,
+  TEST_DB_PATH,
+  DEFAULT_HASH_ALGORITHM,
+  DEFAULT_HASH_LENGTH,
+  DEFAULT_LOG_LEVEL,
+  LOG_LEVEL,
+  HashAlgorithm,
+  HASH_ALGORITHM_HIERARCHY,
+  HashAlgorithmMetadata,
+  VALID_HASH_FUNCTIONS,
+  projectRoot,
+  pathJoin
+};
+
+// ES modules exports
+export default configConstants;
+export {
+  DEFAULT_PAGE_SIZE,
+  CARDS_DB_PATH,
+  TEST_DB_PATH,
+  DEFAULT_HASH_ALGORITHM,
+  DEFAULT_HASH_LENGTH,
+  DEFAULT_LOG_LEVEL,
+  LOG_LEVEL,
+  HashAlgorithm,
+  HASH_ALGORITHM_HIERARCHY,
+  HashAlgorithmMetadata,
+  VALID_HASH_FUNCTIONS,
+  projectRoot,
+  pathJoin,
+  configConstants
+};
diff --git a/src/config/index.js b/src/config/index.js
new file mode 100644
index 0000000..6db52d3
--- /dev/null
+++ b/src/config/index.js
@@ -0,0 +1,39 @@
+/**
+ * Environment-aware configuration entry point
+ * 
+ * This file detects whether we're in a browser or Node.js environment
+ * and exports the appropriate configuration constants accordingly.
+ */
+
+// Check if we're in a browser environment
+const isBrowser = typeof window !== 'undefined';
+
+let config;
+
+// Dynamic import based on environment
+if (isBrowser) {
+  // In the browser, use the browser-safe configuration
+  config = require('./browser-constants.js');
+} else {
+  // In Node.js, use the full configuration with process.env support
+  config = require('./config_constants.js');
+}
+
+// Re-export everything from the selected configuration
+module.exports = config;
+
+// Maintain compatibility with both named and default exports
+if (config.default) {
+  module.exports.default = config.default;
+}
+
+// Handle direct module references in ESM
+export default config.default || config;
+export const configConstants = config.configConstants || config;
+
+// Export all named exports
+for (const key in config) {
+  if (key !== 'default' && key !== 'configConstants') {
+    exports[key] = config[key];
+  }
+}
diff --git a/src/pages/api/retrieve.ts b/src/pages/api/retrieve.ts
new file mode 100644
index 0000000..55e25e9
--- /dev/null
+++ b/src/pages/api/retrieve.ts
@@ -0,0 +1,99 @@
+import type { APIRoute } from 'astro';
+import { SQLiteEngine } from '../../engine/sqlite_engine.js';
+import { CardCollection } from '../../content/model/card-collection.js';
+
+interface RetrieverParams {
+  hashValue?: string;
+  pageNumber?: number;
+  pageSize?: number;
+  searchTerm?: string;
+}
+
+/**
+ * API endpoint to retrieve cards from the database
+ * Supports:
+ * - Get by hash: ?hash=<hash_value>
+ * - Get all cards with pagination: ?page=<number>&pageSize=<number>
+ * - Search by content: ?search=<term>&page=<number>&pageSize=<number>
+ */
+export const GET: APIRoute = async ({ request }) => {
+  console.log('GET /api/retrieve called');
+  
+  // Parse the URL to get the query parameters
+  const url = new URL(request.url);
+  const params: RetrieverParams = {
+    hashValue: url.searchParams.get('hash') || undefined,
+    pageNumber: parseInt(url.searchParams.get('page') || '1'),
+    pageSize: parseInt(url.searchParams.get('pageSize') || '10'),
+    searchTerm: url.searchParams.get('search') || undefined
+  };
+
+  try {
+    // Create a database connection and CardCollection
+    const engine = new SQLiteEngine();
+    const cardCollection = new CardCollection(engine);
+    
+    let result: any;
+    
+    // Handle different retrieval scenarios
+    if (params.hashValue) {
+      // Get a specific card by hash
+      console.log(`Retrieving card with hash: ${params.hashValue}`);
+      const card = cardCollection.get(params.hashValue);
+      
+      if (!card) {
+        return new Response(
+          JSON.stringify({ error: 'Card not found' }),
+          { status: 404, headers: { 'Content-Type': 'application/json' } }
+        );
+      }
+      
+      // Transform to a standardized format using CardCollection's Page format
+      result = {
+        items: [card],
+        total_items: 1,
+        page_number: 1,
+        page_size: 1,
+        has_next: false,
+        has_previous: false,
+        total_pages: 1,
+        previous_page: null,
+        next_page: null
+      };
+    } else if (params.searchTerm) {
+      // Search cards by content using CardCollection
+      console.log(`Searching for cards with term: ${params.searchTerm}`);
+      result = cardCollection.search_by_content(
+        params.searchTerm, 
+        params.pageNumber, 
+        params.pageSize
+      );
+    } else {
+      // Get all cards with pagination using CardCollection
+      console.log(`Retrieving all cards, page ${params.pageNumber}, size ${params.pageSize}`);
+      result = cardCollection.get_page(params.pageNumber, params.pageSize);
+    }
+
+    // Add server timestamp and metadata
+    const responseData = {
+      ...result,
+      serverTimestamp: new Date().toISOString(),
+      retrievalMethod: params.hashValue ? 'hash' : 
+                       params.searchTerm ? 'search' : 'all'
+    };
+
+    return new Response(
+      JSON.stringify(responseData),
+      { status: 200, headers: { 'Content-Type': 'application/json' } }
+    );
+  } catch (error) {
+    console.error('Error retrieving cards:', error);
+    return new Response(
+      JSON.stringify({ 
+        error: 'Failed to retrieve cards', 
+        details: error instanceof Error ? error.message : String(error)
+      }),
+      { status: 500, headers: { 'Content-Type': 'application/json' } }
+    );
+  }
+};
diff --git a/src/utils/dotenv-browser.js b/src/utils/dotenv-browser.js
new file mode 100644
index 0000000..b23d701
--- /dev/null
+++ b/src/utils/dotenv-browser.js
@@ -0,0 +1,29 @@
+/**
+ * Browser-compatible dotenv replacement
+ * Provides a no-op implementation of dotenv for browser environments
+ */
+
+// Create browser-safe "process.env" equivalent
+const browserEnv = {};
+
+// Create a browser-safe version of the dotenv module
+const dotenvBrowser = {
+  // No-op config function that returns an empty object in browser context
+  config: () => ({ parsed: {} }),
+  
+  // Provide access to our browser environment variables
+  env: browserEnv,
+  
+  // Add any variables from window.__ENV__ if it exists (useful for SSR)
+  init: () => {
+    if (typeof window !== 'undefined' && window.__ENV__) {
+      Object.assign(browserEnv, window.__ENV__);
+    }
+    return browserEnv;
+  }
+};
+
+// Initialize immediately
+dotenvBrowser.init();
+
+export default dotenvBrowser;

commit 577df63568c3ed09e86e06cb7845022cc75d9d3a
Author: Henrykoo <lckoo1230@gmail.com>
Date:   Wed Mar 26 10:21:50 2025 +0800

    reset

diff --git a/src/components/panels/DatabaseRetrievePanel.tsx b/src/components/panels/DatabaseRetrievePanel.tsx
deleted file mode 100644
index e23d40b..0000000
--- a/src/components/panels/DatabaseRetrievePanel.tsx
+++ /dev/null
@@ -1,101 +0,0 @@
-import React, { useState, useEffect } from 'react';
-import { Page } from '../../content/model/card-collection';
-import { MCard } from '../../content/model/mcard';
-
-interface DatabaseRetrievePanelProps {
-  onDataRetrieve?: (data: Page) => void;
-}
-
-export const DatabaseRetrievePanel: React.FC<DatabaseRetrievePanelProps> = ({ onDataRetrieve }) => {
-  const [page, setPage] = useState<Page | null>(null);
-  const [loading, setLoading] = useState(false);
-  const [error, setError] = useState<string | null>(null);
-  const [pageNumber, setPageNumber] = useState(1);
-
-  const fetchData = async (page = 1) => {
-    setLoading(true);
-    setError(null);
-
-    try {
-      const response = await fetch(`/api/cards?page=${page}`);
-      
-      if (!response.ok) {
-        throw new Error('Failed to fetch cards');
-      }
-
-      const data: Page = await response.json();
-      setPage(data);
-      
-      if (onDataRetrieve) {
-        onDataRetrieve(data);
-      }
-    } catch (err) {
-      setError(err instanceof Error ? err.message : 'An unknown error occurred');
-    } finally {
-      setLoading(false);
-    }
-  };
-
-  useEffect(() => {
-    fetchData(pageNumber);
-  }, [pageNumber]);
-
-  const handleNextPage = () => {
-    if (page && page.has_next) {
-      setPageNumber(prev => prev + 1);
-    }
-  };
-
-  const handlePreviousPage = () => {
-    if (page && page.has_previous) {
-      setPageNumber(prev => prev - 1);
-    }
-  };
-
-  return (
-    <div className="database-retrieve-panel">
-      {loading && <div className="text-center">Loading...</div>}
-      {error && <div className="text-red-500 text-center">{error}</div>}
-      
-      {page && (
-        <div>
-          <h2 className="text-xl font-bold mb-4">Retrieved Cards</h2>
-          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
-            {page.items.map((card: MCard, index: number) => (
-              <div 
-                key={card.hash || `card-${index}`} 
-                className="border p-4 rounded-lg shadow-md"
-              >
-                <div className="font-semibold">Hash: {card.hash}</div>
-                <div className="text-sm text-gray-600">Time: {card.g_time}</div>
-                <pre className="mt-2 text-sm overflow-auto max-h-40">
-                  {JSON.stringify(card.content, null, 2)}
-                </pre>
-              </div>
-            ))}
-          </div>
-
-          <div className="flex justify-between mt-4">
-            <button 
-              onClick={handlePreviousPage} 
-              disabled={!page.has_previous}
-              className="px-4 py-2 bg-blue-500 text-white rounded disabled:bg-gray-300"
-            >
-              Previous
-            </button>
-            <div className="text-center">
-              Page {page.page_number} of {page.total_pages}
-            </div>
-            <button 
-              onClick={handleNextPage} 
-              disabled={!page.has_next}
-              className="px-4 py-2 bg-blue-500 text-white rounded disabled:bg-gray-300"
-            >
-              Next
-            </button>
-          </div>
-        </div>
-      )}
-    </div>
-  );
-};
diff --git a/src/pages/api/cards.ts b/src/pages/api/cards.ts
deleted file mode 100644
index 284994d..0000000
--- a/src/pages/api/cards.ts
+++ /dev/null
@@ -1,71 +0,0 @@
-import type { APIRoute } from 'astro';
-import { SQLiteEngine } from '../../engine/sqlite_engine';
-import { DEFAULT_PAGE_SIZE } from '../../config/config_constants';
-
-export const GET: APIRoute = async ({ url }) => {
-  try {
-    // Parse page number from query parameters, default to 1
-    const pageParam = url.searchParams.get('page');
-    const page = pageParam !== null 
-      ? Number.parseInt(pageParam, 10) 
-      : 1;
-
-    // Optional: Allow custom page size, default to config
-    const pageSizeParam = url.searchParams.get('pageSize');
-    const pageSize = pageSizeParam !== null 
-      ? Number.parseInt(pageSizeParam, 10)
-      : DEFAULT_PAGE_SIZE;
-
-    // Validate parsed numbers
-    const parsedPage = Number(page);
-    const parsedPageSize = Number(pageSize);
-
-    if (Number.isNaN(parsedPage) || parsedPage <= 0) {
-      return new Response(JSON.stringify({ 
-        error: 'Invalid page parameter' 
-      }), {
-        status: 400,
-        headers: {
-          'Content-Type': 'application/json'
-        }
-      });
-    }
-
-    if (Number.isNaN(parsedPageSize) || parsedPageSize <= 0) {
-      return new Response(JSON.stringify({ 
-        error: 'Invalid page size parameter' 
-      }), {
-        status: 400,
-        headers: {
-          'Content-Type': 'application/json'
-        }
-      });
-    }
-
-    // Create SQLite engine instance
-    const engine = new SQLiteEngine();
-
-    // Fetch page of cards
-    const cardPage = engine.get_all(parsedPage, parsedPageSize);
-
-    // Return as JSON response
-    return new Response(JSON.stringify(cardPage), {
-      status: 200,
-      headers: {
-        'Content-Type': 'application/json'
-      }
-    });
-  } catch (error) {
-    console.error('Error fetching cards:', error);
-    
-    return new Response(JSON.stringify({ 
-      error: 'Failed to retrieve cards', 
-      details: error instanceof Error ? error.message : 'Unknown error' 
-    }), {
-      status: 500,
-      headers: {
-        'Content-Type': 'application/json'
-      }
-    });
-  }
-};
diff --git a/src/pages/api/get-all-cards.ts b/src/pages/api/get-all-cards.ts
deleted file mode 100644
index 610ae17..0000000
--- a/src/pages/api/get-all-cards.ts
+++ /dev/null
@@ -1,46 +0,0 @@
-import type { APIRoute } from 'astro';
-import { getAllCards } from '../../utils/storeAdapter';
-
-/**
- * API endpoint to retrieve all cards with pagination
- */
-export const GET: APIRoute = async ({ request }) => {
-  console.log('GET /api/get-all-cards called');
-  
-  // Parse the URL to get the query parameters
-  const url = new URL(request.url);
-  const pageNumber = parseInt(url.searchParams.get('page') || '1');
-  const pageSize = parseInt(url.searchParams.get('pageSize') || '10');
-
-  try {
-    console.log(`Retrieving cards page ${pageNumber} with size ${pageSize}`);
-    const paginatedCards = getAllCards(pageNumber, pageSize);
-    
-    // Add server timestamp
-    const responseData = {
-      ...paginatedCards,
-      serverTimestamp: new Date().toISOString(),
-    };
-
-    console.log(`Retrieved ${paginatedCards?.items?.length || 0} cards successfully`);
-    return new Response(
-      JSON.stringify(responseData),
-      { 
-        status: 200, 
-        headers: { 'Content-Type': 'application/json' } 
-      }
-    );
-  } catch (error) {
-    console.error('Error retrieving cards:', error);
-    return new Response(
-      JSON.stringify({ 
-        error: 'Failed to retrieve cards', 
-        details: error instanceof Error ? error.message : String(error)
-      }),
-      { 
-        status: 500, 
-        headers: { 'Content-Type': 'application/json' } 
-      }
-    );
-  }
-};

commit 50cdeed0c1e771943f070c3b79e516b7fb3adb69
Author: Henrykoo <lckoo1230@gmail.com>
Date:   Tue Mar 25 23:56:41 2025 +0800

    content interpreter

diff --git a/jest.config.js b/jest.config.js
index 6e3a77f..a1a02ce 100644
--- a/jest.config.js
+++ b/jest.config.js
@@ -1,15 +1,24 @@
 export default {
   testEnvironment: 'jsdom',
+  preset: 'ts-jest',
   transform: {
-    '^.+\\.(js|jsx)$': ['babel-jest', { configFile: './babel.config.cjs' }]
+    '^.+\\.(js|jsx|ts|tsx)$': 'ts-jest'
   },
-  testMatch: ['**/__tests__/**/*.js?(x)', '**/?(*.)+(spec|test).js?(x)'],
-  extensionsToTreatAsEsm: ['.jsx'],
+  testMatch: [
+    '**/__tests__/**/*.ts?(x)', 
+    '**/?(*.)+(spec|test).ts?(x)'
+  ],
+  extensionsToTreatAsEsm: ['.ts', '.tsx'],
   moduleNameMapper: {
     '^src/(.*)$': '<rootDir>/src/$1'
   },
   resolver: '<rootDir>/jest-resolver.cjs',
   transformIgnorePatterns: [
     'node_modules/(?!(@astrojs)/)'
-  ]
+  ],
+  globals: {
+    'ts-jest': {
+      useESM: true
+    }
+  }
 };
\ No newline at end of file
diff --git a/package.json b/package.json
index 2731176..d55f6a6 100644
--- a/package.json
+++ b/package.json
@@ -11,7 +11,8 @@
     "test": "jest",
     "test:all": "bash src/test/run_all_tests.sh",
     "generate-pwa-icons": "node scripts/generate-pwa-icons.js",
-    "test:state": "node src/tests/stateCapture.test.js"
+    "test:state": "node src/tests/stateCapture.test.js",
+    "test:interpreter": "jest src/content/model/interpreter.test.ts"
   },
   "dependencies": {
     "@astrojs/react": "latest",
@@ -43,7 +44,9 @@
   "devDependencies": {
     "@babel/preset-env": "^7.26.9",
     "@babel/preset-react": "^7.26.3",
+    "@jest/globals": "^29.7.0",
     "@tailwindcss/typography": "^0.5.10",
+    "@types/jest": "^29.5.14",
     "@typescript-eslint/eslint-plugin": "^8.26.0",
     "@typescript-eslint/parser": "^8.26.0",
     "@vite-pwa/astro": "^0.5.0",
@@ -56,6 +59,7 @@
     "jest-environment-jsdom": "^29.7.0",
     "jsdom": "^26.0.0",
     "tailwindcss": "^3.3.3",
-    "tailwindcss-animate": "^1.0.7"
+    "tailwindcss-animate": "^1.0.7",
+    "ts-jest": "^29.3.0"
   }
 }
diff --git a/src/content/model/interpreter.test.ts b/src/content/model/interpreter.test.ts
new file mode 100644
index 0000000..89ed437
--- /dev/null
+++ b/src/content/model/interpreter.test.ts
@@ -0,0 +1,142 @@
+import { describe, it, expect } from '@jest/globals';
+import { ContentTypeInterpreter } from './interpreter';
+
+describe('ContentTypeInterpreter', () => {
+  // Binary Type Detection Tests
+  describe('Binary Type Detection', () => {
+    const testBinarySignatures = [
+      { 
+        name: 'PNG Image', 
+        input: new Uint8Array([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52]),
+        expectedType: 'image/png',
+        expectedSubtype: 'png'
+      },
+      { 
+        name: 'JPEG Image', 
+        input: new Uint8Array([0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46]),
+        expectedType: 'image/jpeg',
+        expectedSubtype: 'jpeg'
+      },
+      { 
+        name: 'PDF Document', 
+        input: new Uint8Array([0x25, 0x50, 0x44, 0x46, 0x2D, 0x31, 0x2E, 0x37]),
+        expectedType: 'application/pdf',
+        expectedSubtype: 'pdf'
+      }
+    ];
+
+    testBinarySignatures.forEach(({ name, input, expectedType, expectedSubtype }) => {
+      it(`should detect ${name}`, () => {
+        const result = ContentTypeInterpreter.detectContentType(input);
+        expect(result.type).toBe(expectedType);
+        expect(result.subtype).toBe(expectedSubtype);
+      });
+    });
+  });
+
+  // Text Type Detection Tests
+  describe('Text Type Detection', () => {
+    const testTextTypes = [
+      {
+        name: 'JSON Object',
+        input: '{"name": "test", "value": 42}',
+        expectedType: 'text/json',
+        expectedSubtype: 'json'
+      },
+      {
+        name: 'JSON Array',
+        input: '[1, 2, 3, 4]',
+        expectedType: 'text/json',
+        expectedSubtype: 'json'
+      },
+      {
+        name: 'Markdown',
+        input: '# Heading\n\nThis is a paragraph with a [link](https://example.com)',
+        expectedType: 'text/markdown',
+        expectedSubtype: 'markdown'
+      },
+      {
+        name: 'CSV',
+        input: 'name,age,city\nJohn,30,New York\nJane,25,San Francisco',
+        expectedType: 'text/csv',
+        expectedSubtype: 'csv'
+      },
+      {
+        name: 'XML',
+        input: '<?xml version="1.0" encoding="UTF-8"?>\n<root><child>value</child></root>',
+        expectedType: 'text/xml',
+        expectedSubtype: 'xml'
+      }
+    ];
+
+    testTextTypes.forEach(({ name, input, expectedType, expectedSubtype }) => {
+      it(`should detect ${name}`, () => {
+        const result = ContentTypeInterpreter.detectContentType(input);
+        expect(result.type).toBe(expectedType);
+        expect(result.subtype).toBe(expectedSubtype);
+      });
+    });
+  });
+
+  // Content Analysis Tests
+  describe('Content Analysis', () => {
+    it('should handle string input', () => {
+      const result = ContentTypeInterpreter.analyzeContentType('Hello, world!');
+      expect(result.isString).toBe(true);
+      expect(result.isBinary).toBe(false);
+      expect(result.contentType).toBe('text/plain');
+      expect(result.length).toBe(13);
+    });
+
+    it('should detect binary content', () => {
+      const binaryData = new Uint8Array([0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07]);
+      const result = ContentTypeInterpreter.analyzeContentType(binaryData);
+      expect(result.isString).toBe(false);
+      expect(result.isBinary).toBe(true);
+      expect(result.length).toBe(8);
+    });
+  });
+
+  // Utility Method Tests
+  describe('Utility Methods', () => {
+    it('should detect Markdown content', () => {
+      const markdownContent = '# Title\n\n- List item\n1. Numbered list\n[Link](url)';
+      const nonMarkdownContent = 'Plain text without Markdown elements';
+
+      expect(ContentTypeInterpreter['isMarkdownContent'](markdownContent)).toBe(true);
+      expect(ContentTypeInterpreter['isMarkdownContent'](nonMarkdownContent)).toBe(false);
+    });
+
+    it('should detect JSON content', () => {
+      const jsonContent = '{"key": "value"}';
+      const invalidJsonContent = '{key: "value"}';
+
+      expect(ContentTypeInterpreter['isJSONContent'](jsonContent)).toBe(true);
+      expect(ContentTypeInterpreter['isJSONContent'](invalidJsonContent)).toBe(false);
+    });
+
+    it('should detect CSV content', () => {
+      const csvContent = 'name,age\nJohn,30\nJane,25';
+      const nonCsvContent = 'Just some text';
+
+      expect(ContentTypeInterpreter['isCSVContent'](csvContent)).toBe(true);
+      expect(ContentTypeInterpreter['isCSVContent'](nonCsvContent)).toBe(false);
+    });
+  });
+
+  // Edge Case Tests
+  describe('Edge Cases', () => {
+    it('should handle empty input', () => {
+      const result = ContentTypeInterpreter.detectContentType('');
+      expect(result.type).toBe('text/plain');
+      expect(result.subtype).toBe('plain');
+    });
+
+    it('should handle conversion error', () => {
+      const invalidInput = Symbol('invalid');
+      const result = ContentTypeInterpreter.detectContentType(invalidInput);
+      expect(result.type).toBe('application/octet-stream');
+      expect(result.subtype).toBe('unknown');
+    });
+  });
+});
diff --git a/src/content/model/interpreter.ts b/src/content/model/interpreter.ts
index 6888bfd..045dc3a 100644
--- a/src/content/model/interpreter.ts
+++ b/src/content/model/interpreter.ts
@@ -227,6 +227,58 @@ export class ContentTypeInterpreter {
   static detectContentType(input: any): ContentTypeResult {
     const startTime = performance.now();
 
+    // Direct handling for string inputs
+    if (typeof input === 'string') {
+      const trimmedInput = input.trim();
+      
+      // Handle empty input
+      if (trimmedInput === '') {
+        return {
+          type: 'text/plain',
+          subtype: 'plain',
+          label: 'TXT',
+          preview: ''
+        };
+      }
+
+      // Direct type detection for strings
+      if (this.isJSONContent(trimmedInput)) {
+        return {
+          type: 'text/json',
+          subtype: 'json',
+          label: 'JSON',
+          preview: trimmedInput.slice(0, 100)
+        };
+      }
+
+      if (this.isMarkdownContent(trimmedInput)) {
+        return {
+          type: 'text/markdown',
+          subtype: 'markdown',
+          label: 'MD',
+          preview: trimmedInput.slice(0, 100)
+        };
+      }
+
+      if (this.isCSVContent(trimmedInput)) {
+        return {
+          type: 'text/csv',
+          subtype: 'csv',
+          label: 'CSV',
+          preview: `CSV, ${trimmedInput.split('\n').length} rows, ${trimmedInput.length} bytes`
+        };
+      }
+
+      if (this.isXMLContent(trimmedInput)) {
+        return {
+          type: 'text/xml',
+          subtype: 'xml',
+          label: 'XML',
+          preview: trimmedInput.slice(0, 100)
+        };
+      }
+    }
+
     let buffer: Uint8Array;
     try {
       buffer = this.convertToUint8Array(input);
@@ -263,10 +315,53 @@ export class ContentTypeInterpreter {
       const decodedText = decoder.decode(buffer);
       
       const previewText = bufferToPreviewString(buffer);
-      const textTypeResult = this.detectTextType(previewText);
       
+      // Enhanced text type detection with more robust checks
+      // Check for specific text types in order of specificity
+      if (this.isXMLContent(previewText)) {
+        return {
+          type: 'text/xml',
+          subtype: 'xml',
+          label: 'XML',
+          preview: previewText.slice(0, 100)
+        };
+      }
+
+      if (this.isJSONContent(previewText)) {
+        return {
+          type: 'text/json',
+          subtype: 'json',
+          label: 'JSON',
+          preview: previewText.slice(0, 100)
+        };
+      }
+
+      if (this.isMarkdownContent(previewText)) {
+        return {
+          type: 'text/markdown',
+          subtype: 'markdown',
+          label: 'MD',
+          preview: previewText.slice(0, 100)
+        };
+      }
+
+      if (this.isCSVContent(previewText)) {
+        return {
+          type: 'text/csv',
+          subtype: 'csv',
+          label: 'CSV',
+          preview: `CSV, ${previewText.split('\n').length} rows, ${previewText.length} bytes`
+        };
+      }
+      
+      // Fallback to text/plain if no specific type is detected
       const endTime = performance.now();
-      return textTypeResult;
+      return {
+        type: 'text/plain',
+        subtype: 'plain',
+        label: 'TXT',
+        preview: previewText.slice(0, 100)
+      };
     } catch (textDecodeError) {
       // Completely unrecognized
       const endTime = performance.now();
@@ -304,8 +399,15 @@ export class ContentTypeInterpreter {
       
       if (!isJsonStructure) return false;
       
-      JSON.parse(trimmed);
-      return true;
+      // Validate JSON structure
+      const parsed = JSON.parse(trimmed);
+      
+      // Additional checks for JSON validity
+      if (typeof parsed === 'object' && parsed !== null) {
+        return true;
+      }
+      
+      return false;
     } catch {
       return false;
     }
@@ -322,10 +424,14 @@ export class ContentTypeInterpreter {
       /^\s*-\s/m,  // Unordered list
       /^\s*\d+\.\s/m,  // Ordered list
       /`{3}/,  // Code blocks
-      /\[.*\]\(.*\)/  // Links
+      /\[.*\]\(.*\)/,  // Links
+      /\*{1,2}.*\*{1,2}/,  // Bold or italic
+      /_{1,2}.*_{1,2}/     // Underline or italic
     ];
 
-    return markdownPatterns.some(pattern => pattern.test(content));
+    // Require at least two markdown-specific patterns to match
+    const matchCount = markdownPatterns.filter(pattern => pattern.test(content)).length;
+    return matchCount >= 2;
   }
 
   /**
@@ -336,10 +442,20 @@ export class ContentTypeInterpreter {
   private static isCSVContent(content: string): boolean {
     const csvPatterns = [
       /^.*,(?=.*\n)/m,  // Comma-separated values
-      /^.*\t.*\n/m  // Tab-separated values
+      /^.*\t.*\n/m,  // Tab-separated values
+      /^[^,\n]+,[^,\n]+/  // At least two comma-separated columns
     ];
 
-    return csvPatterns.some(pattern => pattern.test(content));
+    // Require multiple rows and multiple columns
+    const lines = content.split('\n').filter(line => line.trim() !== '');
+    const hasMultipleRows = lines.length > 1;
+    const hasMultipleColumns = lines.some(line => {
+      const cols = line.split(',');
+      return cols.length > 1 && cols.every(col => col.trim() !== '');
+    });
+    
+    const patternMatches = csvPatterns.filter(pattern => pattern.test(content)).length;
+    return hasMultipleRows && hasMultipleColumns && patternMatches > 0;
   }
 
   /**
@@ -351,10 +467,14 @@ export class ContentTypeInterpreter {
     const xmlPatterns = [
       /^\s*<\?xml\s+version=/,  // XML declaration
       /^\s*<\w+\s*xmlns:/,      // XML with namespace
-      /^\s*<!DOCTYPE\s+\w+/     // DOCTYPE declaration
+      /^\s*<!DOCTYPE\s+\w+/,    // DOCTYPE declaration
+      /<\w+>.*<\/\w+>/,         // Basic tag structure
+      /&\w+;/                   // XML entities
     ];
 
-    return xmlPatterns.some(pattern => pattern.test(content));
+    // Require at least two XML-specific patterns to match
+    const matchCount = xmlPatterns.filter(pattern => pattern.test(content)).length;
+    return matchCount >= 2;
   }
 
   /**
@@ -415,8 +535,10 @@ export class ContentTypeInterpreter {
       // Analyze binary content
       const firstBytes = Array.from(buffer.slice(0, 16)).map(b => parseInt(b.toString(16).padStart(2, '0'), 16));
       
-      // Determine if content is likely binary
-      const isBinary = this.isPotentialBinaryContent(buffer);
+      // More aggressive binary detection
+      const isBinary = buffer.length > 0 && 
+        (this.isPotentialBinaryContent(buffer) || 
+         this.detectBinaryType(buffer) !== null);
 
       // Attempt to detect specific binary type
       const detectedType = this.detectContentType(buffer);
@@ -424,7 +546,7 @@ export class ContentTypeInterpreter {
       return {
         isString: false,
         isBinary: isBinary,
-        contentType: detectedType?.type || 'unknown',
+        contentType: detectedType?.type || 'application/octet-stream',
         length: buffer.length,
         firstBytes: firstBytes
       };
```
