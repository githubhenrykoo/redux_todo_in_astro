# Git Activity Log - Henry Koo
Generated at: Tue Apr  1 00:50:20 UTC 2025
## Changes by Henry Koo
```diff
commit 00372250c99106eb6d7613b49d99bafab4e475ab
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Mon Mar 31 16:20:41 2025 +0800

    better formatted clm

diff --git a/public/data/cards.db-wal b/public/data/cards.db-wal
index 5455038..d56aa0c 100644
Binary files a/public/data/cards.db-wal and b/public/data/cards.db-wal differ
diff --git a/src/components/Content.jsx b/src/components/Content.jsx
index 8affaf8..aa199d6 100644
--- a/src/components/Content.jsx
+++ b/src/components/Content.jsx
@@ -78,9 +78,6 @@ const Content = () => {
 
                 {/* Metadata and Actions */}
                 <div className="flex justify-between items-center text-xs">
-                  <div className="text-gray-500 dark:text-neutral-500 truncate max-w-[50%]">
-                    Created: {new Date(card.createdAt).toLocaleString()}
-                  </div>
                   <div>
                     <button 
                       onClick={() => handleContentDelete(card.hash)}
diff --git a/src/components/panels/CLMDisplayPanel.jsx b/src/components/panels/CLMDisplayPanel.jsx
index fc3427c..62fa84d 100644
--- a/src/components/panels/CLMDisplayPanel.jsx
+++ b/src/components/panels/CLMDisplayPanel.jsx
@@ -23,7 +23,12 @@ const CLMDisplayPanel = () => {
     const rootClm = useMemo(() => {
         // Find the card by hash
         const selectedCard = selectedHash ? cards[selectedHash] : null;
-        return selectedCard ? selectedCard.content : null;
+        if (selectedCard && selectedCard.content) {
+            // Filter out createdAt if it exists in the content
+            const { createdAt, ...filteredContent } = selectedCard.content;
+            return filteredContent;
+        }
+        return null;
     }, [cards, selectedHash]);
 
     // Load dimensions when root CLM changes
@@ -137,7 +142,9 @@ const CLMDisplayPanel = () => {
         // If it's an object (parsed JSON), stringify it for display
         if (typeof content === 'object') {
             try {
-                return JSON.stringify(content, null, 2);
+                // Filter out createdAt if it exists
+                const { createdAt, ...filteredContent } = content;
+                return JSON.stringify(filteredContent, null, 2);
             } catch (e) {
                 console.error('Error stringifying content:', e);
             }
diff --git a/src/components/panels/CLMInputPanel.jsx b/src/components/panels/CLMInputPanel.jsx
index 30e1581..baa8c3c 100644
--- a/src/components/panels/CLMInputPanel.jsx
+++ b/src/components/panels/CLMInputPanel.jsx
@@ -285,7 +285,6 @@ const CLMInputPanel = () => {
             console.log("Creating root CLM with dimension hash references...");
             const rootClmJson = {
                 title: documentTitle,
-                createdAt: new Date().toISOString(),
                 type: 'clm_document',
                 // Reference dimensions by their hash values according to the CLM_for_CLM_Mcard.md spec
                 dimensions: {
diff --git a/src/features/contentSlice.js b/src/features/contentSlice.js
index 04a3163..a645090 100644
--- a/src/features/contentSlice.js
+++ b/src/features/contentSlice.js
@@ -7,7 +7,6 @@ const generateHash = () => `content_${Math.random().toString(36).substr(2, 9)}`;
 const createContentCard = (content, relationships = {}) => ({
   hash: generateHash(),
   content,
-  createdAt: new Date().toISOString(),
   metadata: {},
   relationships: {
     parentHash: null,
@@ -138,7 +137,6 @@ export const contentSlice = createSlice({
       state.cards[hash] = {
         hash,
         content,
-        createdAt: new Date().toISOString(),
         metadata,
         relationships: {
           parentHash: relationships?.parentHash || null,

commit c8c50ed2234041aa9cd9677fcea39175733ea94d
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Mon Mar 31 16:13:04 2025 +0800

    better display

diff --git a/public/data/cards.db-wal b/public/data/cards.db-wal
index 922fda2..5455038 100644
Binary files a/public/data/cards.db-wal and b/public/data/cards.db-wal differ
diff --git a/src/components/panels/CLMDisplayPanel.jsx b/src/components/panels/CLMDisplayPanel.jsx
index d806209..fc3427c 100644
--- a/src/components/panels/CLMDisplayPanel.jsx
+++ b/src/components/panels/CLMDisplayPanel.jsx
@@ -199,7 +199,6 @@ const CLMDisplayPanel = () => {
             <h2 className="clm-title">{rootClm?.title || 'Cubical Logic Model'}</h2>
             
             <div className="clm-metadata">
-                <p><strong>Created:</strong> {rootClm?.createdAt && new Date(rootClm.createdAt).toLocaleString()}</p>
                 <p><strong>CLM Hash:</strong> <code>{selectedHash?.substring(0, 10) || 'N/A'}...</code></p>
             </div>
             

commit 461c34372ede01f8761285d67a7b9f4dd9d80724
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Mon Mar 31 16:03:30 2025 +0800

    CLM veiwer

diff --git a/public/data/cards.db-wal b/public/data/cards.db-wal
index d9f766d..922fda2 100644
Binary files a/public/data/cards.db-wal and b/public/data/cards.db-wal differ
diff --git a/src/components/panels/CLMDisplayPanel.jsx b/src/components/panels/CLMDisplayPanel.jsx
index f18a6cd..d806209 100644
--- a/src/components/panels/CLMDisplayPanel.jsx
+++ b/src/components/panels/CLMDisplayPanel.jsx
@@ -1,105 +1,104 @@
-import React, { useState, useEffect } from 'react';
+'use client';
+
+import React, { useState, useEffect, useMemo } from 'react';
+import { useDispatch, useSelector } from 'react-redux';
 import '../../styles/clm-display.css';
 
-// Make parameters optional and accept proper types
-const CLMDisplayPanel = ({ clmHash = null, initialHash = '' }) => {
-    const [loading, setLoading] = useState(true);
+const CLMDisplayPanel = () => {
+    const [loading, setLoading] = useState(false);
     const [error, setError] = useState(null);
-    const [rootClm, setRootClm] = useState(null);
     const [dimensions, setDimensions] = useState({
         abstractSpecification: null,
         concreteImplementation: null,
         balancedExpectations: null
     });
 
-    // If clmHash is not provided as a prop, try to get it from initialHash or URL
+    const dispatch = useDispatch();
+    
+    // Use Redux selectors to get the selected hash and cards
+    const selectedHash = useSelector(state => state?.content?.selectedHash);
+    const cards = useSelector(state => state?.content?.cards || {});
+    
+    // Get the root CLM card from Redux store
+    const rootClm = useMemo(() => {
+        // Find the card by hash
+        const selectedCard = selectedHash ? cards[selectedHash] : null;
+        return selectedCard ? selectedCard.content : null;
+    }, [cards, selectedHash]);
+
+    // Load dimensions when root CLM changes
     useEffect(() => {
-        const hashToUse = clmHash || initialHash;
-        
-        if (!hashToUse && typeof window !== 'undefined') {
-            const urlParams = new URLSearchParams(window.location.search);
-            const hashFromUrl = urlParams.get('hash');
-            if (hashFromUrl) {
-                console.log(`Getting CLM hash from URL: ${hashFromUrl}`);
-                loadClmData(hashFromUrl);
-            } else {
-                setError("No CLM hash provided");
-                setLoading(false);
-            }
-        } else if (hashToUse) {
-            loadClmData(hashToUse);
+        if (rootClm && rootClm.dimensions) {
+            loadDimensions(rootClm.dimensions);
         } else {
-            setError("No CLM hash provided and not running in browser");
-            setLoading(false);
+            // Reset dimensions if no root CLM
+            setDimensions({
+                abstractSpecification: null,
+                concreteImplementation: null,
+                balancedExpectations: null
+            });
+            
+            // If rootClm exists but dimensions are missing, set error
+            if (rootClm && !rootClm.dimensions) {
+                setError("Invalid CLM format: dimensions property is missing");
+            }
         }
-    }, [clmHash, initialHash]);
+    }, [rootClm]);
 
-    // Main function to load CLM data
-    const loadClmData = async (hash) => {
+    // Load all dimensions from the Redux store or fetch if needed
+    const loadDimensions = async (dimensionHashes) => {
         try {
+            // If dimensionHashes is undefined or null, throw an error
+            if (!dimensionHashes) {
+                throw new Error("Dimension hashes are undefined");
+            }
+            
             setLoading(true);
             setError(null);
             
-            console.log(`Fetching root CLM with hash: ${hash}`);
-            const response = await fetch('/api/card-collection', {
-                method: 'POST',
-                headers: {
-                    'Content-Type': 'application/json'
-                },
-                body: JSON.stringify({
-                    action: 'get',
-                    hash: hash
-                })
-            });
-
-            if (!response.ok) {
-                throw new Error(`Failed to fetch CLM: ${response.status}`);
-            }
-
-            const result = await response.json();
-            if (!result.success) {
-                throw new Error(result.error || 'Failed to retrieve CLM data');
-            }
-
-            console.log('Root CLM received:', result.card);
-            setRootClm(result.card.content);
-            
-            // Now fetch each dimension by its hash
-            await fetchDimensions(result.card.content.dimensions);
-        } catch (error) {
-            console.error('Error fetching CLM:', error);
-            setError(`Error loading CLM: ${error.message}`);
-        } finally {
-            setLoading(false);
-        }
-    };
-
-    // Fetch each dimension by hash
-    const fetchDimensions = async (dimensionHashes) => {
-        try {
-            // Fetch abstract specification
+            // Check if abstract specification is already in Redux store
+            let abstractSpec = null;
             if (dimensionHashes.abstractSpecification) {
-                console.log(`Fetching Abstract Specification with hash: ${dimensionHashes.abstractSpecification}`);
-                const abstractSpec = await fetchDimension(dimensionHashes.abstractSpecification);
+                const abstractHash = dimensionHashes.abstractSpecification;
+                if (cards[abstractHash]) {
+                    abstractSpec = cards[abstractHash].content;
+                } else {
+                    // If not in store, fetch it
+                    abstractSpec = await fetchDimension(abstractHash);
+                }
                 setDimensions(prev => ({ ...prev, abstractSpecification: abstractSpec }));
             }
-
-            // Fetch concrete implementation
+            
+            // Check if concrete implementation is already in Redux store
+            let concreteImpl = null;
             if (dimensionHashes.concreteImplementation) {
-                console.log(`Fetching Concrete Implementation with hash: ${dimensionHashes.concreteImplementation}`);
-                const concreteImpl = await fetchDimension(dimensionHashes.concreteImplementation);
+                const concreteHash = dimensionHashes.concreteImplementation;
+                if (cards[concreteHash]) {
+                    concreteImpl = cards[concreteHash].content;
+                } else {
+                    // If not in store, fetch it
+                    concreteImpl = await fetchDimension(concreteHash);
+                }
                 setDimensions(prev => ({ ...prev, concreteImplementation: concreteImpl }));
             }
-
-            // Fetch balanced expectations
+            
+            // Check if balanced expectations is already in Redux store
+            let balancedExp = null;
             if (dimensionHashes.balancedExpectations) {
-                console.log(`Fetching Balanced Expectations with hash: ${dimensionHashes.balancedExpectations}`);
-                const balancedExp = await fetchDimension(dimensionHashes.balancedExpectations);
+                const balancedHash = dimensionHashes.balancedExpectations;
+                if (cards[balancedHash]) {
+                    balancedExp = cards[balancedHash].content;
+                } else {
+                    // If not in store, fetch it
+                    balancedExp = await fetchDimension(balancedHash);
+                }
                 setDimensions(prev => ({ ...prev, balancedExpectations: balancedExp }));
             }
         } catch (error) {
-            console.error('Error fetching dimensions:', error);
+            console.error('Error loading dimensions:', error);
             setError(`Error loading dimension data: ${error.message}`);
+        } finally {
+            setLoading(false);
         }
     };
 
@@ -128,34 +127,80 @@ const CLMDisplayPanel = ({ clmHash = null, initialHash = '' }) => {
         return result.card.content;
     };
 
+    // Helper function to format content based on type
+    const formatContent = (content) => {
+        if (!content) return '';
+        
+        // If content is already a string, return it
+        if (typeof content === 'string') return content;
+        
+        // If it's an object (parsed JSON), stringify it for display
+        if (typeof content === 'object') {
+            try {
+                return JSON.stringify(content, null, 2);
+            } catch (e) {
+                console.error('Error stringifying content:', e);
+            }
+        }
+        
+        // Fallback: convert to string
+        return String(content);
+    };
+
+    // Show loading state while dimensions are being loaded
     if (loading) {
-        return <div className="clm-display-loading">Loading CLM data...</div>;
+        return <div className="clm-display-loading">Loading CLM dimensions...</div>;
     }
 
+    // Show error message if there was a problem
     if (error) {
         return <div className="clm-display-error">{error}</div>;
     }
 
-    if (!rootClm || !dimensions.abstractSpecification || !dimensions.concreteImplementation || !dimensions.balancedExpectations) {
-        return <div className="clm-display-error">Unable to load complete CLM data</div>;
+    // Show placeholder if no CLM is selected
+    if (!selectedHash || !rootClm) {
+        return <div className="clm-display-placeholder">
+            <h3>CLM Viewer</h3>
+            <p>Select a CLM from the content panel to view it</p>
+        </div>;
+    }
+
+    // Show error if dimensions couldn't be loaded
+    if (!dimensions.abstractSpecification || !dimensions.concreteImplementation || !dimensions.balancedExpectations) {
+        return <div className="clm-display-error">
+            <h3>Incomplete CLM Data</h3>
+            <p>Unable to load all dimensions for this CLM. Some dimension hashes may be invalid or unavailable.</p>
+            <div className="clm-incomplete-details">
+                <p>CLM Hash: <code>{selectedHash}</code></p>
+                <p>Missing dimensions:</p>
+                <ul>
+                    {!dimensions.abstractSpecification && rootClm?.dimensions?.abstractSpecification && 
+                        <li>Abstract Specification ({rootClm.dimensions.abstractSpecification})</li>}
+                    {!dimensions.concreteImplementation && rootClm?.dimensions?.concreteImplementation && 
+                        <li>Concrete Implementation ({rootClm.dimensions.concreteImplementation})</li>}
+                    {!dimensions.balancedExpectations && rootClm?.dimensions?.balancedExpectations && 
+                        <li>Balanced Expectations ({rootClm.dimensions.balancedExpectations})</li>}
+                </ul>
+            </div>
+        </div>;
     }
 
     // Extract the abstract specification dimension data
-    const { context, goal, successCriteria } = dimensions.abstractSpecification;
+    const { context, goal, successCriteria } = dimensions.abstractSpecification || {};
     
     // Extract the concrete implementation dimension data
-    const { inputs, activities, outputs } = dimensions.concreteImplementation;
+    const { inputs, activities, outputs } = dimensions.concreteImplementation || {};
     
     // Extract the balanced expectations dimension data
-    const { practicalBoundaries, evaluationMetrics, feedbackLoops } = dimensions.balancedExpectations;
+    const { practicalBoundaries, evaluationMetrics, feedbackLoops } = dimensions.balancedExpectations || {};
 
     return (
         <div className="clm-display-panel">
-            <h2 className="clm-title">{rootClm.title || 'Cubical Logic Model'}</h2>
+            <h2 className="clm-title">{rootClm?.title || 'Cubical Logic Model'}</h2>
             
             <div className="clm-metadata">
-                <p><strong>Created:</strong> {new Date(rootClm.createdAt).toLocaleString()}</p>
-                <p><strong>CLM Hash:</strong> <code>{clmHash.substring(0, 10)}...</code></p>
+                <p><strong>Created:</strong> {rootClm?.createdAt && new Date(rootClm.createdAt).toLocaleString()}</p>
+                <p><strong>CLM Hash:</strong> <code>{selectedHash?.substring(0, 10) || 'N/A'}...</code></p>
             </div>
             
             <table className="clm-table">
@@ -164,25 +209,27 @@ const CLMDisplayPanel = ({ clmHash = null, initialHash = '' }) => {
                     <tr>
                         <th colSpan={6}>
                             <a href="#abstract-specification">Abstract Specification</a>
-                            <small className="dimension-hash">Hash: {rootClm.dimensions.abstractSpecification.substring(0, 8)}...</small>
+                            {rootClm?.dimensions?.abstractSpecification && (
+                                <small className="dimension-hash">Hash: {rootClm.dimensions.abstractSpecification.substring(0, 8)}...</small>
+                            )}
                         </th>
                     </tr>
                     <tr>
                         <th colSpan={1}><a href="#context">Context</a></th>
                         <td colSpan={5} style={{ wordWrap: 'break-word' }}>
-                            {context}
+                            {formatContent(context)}
                         </td>
                     </tr>
                     <tr>
                         <th colSpan={1}><a href="#goal">Goal</a></th>
                         <td colSpan={5} style={{ wordWrap: 'break-word' }}>
-                            {goal}
+                            {formatContent(goal)}
                         </td>
                     </tr>
                     <tr>
                         <th colSpan={1}><a href="#success-criteria">Success Criteria</a></th>
                         <td colSpan={5} style={{ wordWrap: 'break-word' }}>
-                            {successCriteria}
+                            {formatContent(successCriteria)}
                         </td>
                     </tr>
                     
@@ -190,7 +237,9 @@ const CLMDisplayPanel = ({ clmHash = null, initialHash = '' }) => {
                     <tr>
                         <th colSpan={6}>
                             <a href="#concrete-implementation">Concrete Implementation</a>
-                            <small className="dimension-hash">Hash: {rootClm.dimensions.concreteImplementation.substring(0, 8)}...</small>
+                            {rootClm?.dimensions?.concreteImplementation && (
+                                <small className="dimension-hash">Hash: {rootClm.dimensions.concreteImplementation.substring(0, 8)}...</small>
+                            )}
                         </th>
                     </tr>
                     <tr>
@@ -200,13 +249,13 @@ const CLMDisplayPanel = ({ clmHash = null, initialHash = '' }) => {
                     </tr>
                     <tr>
                         <td colSpan={2} style={{ wordWrap: 'break-word' }}>
-                            {inputs}
+                            {formatContent(inputs)}
                         </td>
                         <td colSpan={2} style={{ wordWrap: 'break-word' }}>
-                            {activities}
+                            {formatContent(activities)}
                         </td>
                         <td colSpan={2} style={{ wordWrap: 'break-word' }}>
-                            {outputs}
+                            {formatContent(outputs)}
                         </td>
                     </tr>
 
@@ -214,25 +263,27 @@ const CLMDisplayPanel = ({ clmHash = null, initialHash = '' }) => {
                     <tr>
                         <th colSpan={6}>
                             <a href="#balanced-expectations">Balanced Expectations</a>
-                            <small className="dimension-hash">Hash: {rootClm.dimensions.balancedExpectations.substring(0, 8)}...</small>
+                            {rootClm?.dimensions?.balancedExpectations && (
+                                <small className="dimension-hash">Hash: {rootClm.dimensions.balancedExpectations.substring(0, 8)}...</small>
+                            )}
                         </th>
                     </tr>
                     <tr>
                         <th colSpan={2}><a href="#practical-boundaries">Practical Boundaries</a></th>
                         <td colSpan={4} style={{ wordWrap: 'break-word' }}>
-                            {practicalBoundaries}
+                            {formatContent(practicalBoundaries)}
                         </td>
                     </tr>
                     <tr>
                         <th colSpan={2}><a href="#evaluation-metrics">Evaluation Metrics</a></th>
                         <td colSpan={4} style={{ wordWrap: 'break-word' }}>
-                            {evaluationMetrics}
+                            {formatContent(evaluationMetrics)}
                         </td>
                     </tr>
                     <tr>
                         <th colSpan={2}><a href="#feedback-loops">Feedback Loops</a></th>
                         <td colSpan={4} style={{ wordWrap: 'break-word' }}>
-                            {feedbackLoops}
+                            {formatContent(feedbackLoops)}
                         </td>
                     </tr>
                 </tbody>
@@ -241,9 +292,15 @@ const CLMDisplayPanel = ({ clmHash = null, initialHash = '' }) => {
             <div className="clm-dimension-hashes">
                 <h3>Dimension Hash References</h3>
                 <ul>
-                    <li><strong>Abstract Specification:</strong> <code>{rootClm.dimensions.abstractSpecification}</code></li>
-                    <li><strong>Concrete Implementation:</strong> <code>{rootClm.dimensions.concreteImplementation}</code></li>
-                    <li><strong>Balanced Expectations:</strong> <code>{rootClm.dimensions.balancedExpectations}</code></li>
+                    {rootClm?.dimensions?.abstractSpecification && (
+                        <li><strong>Abstract Specification:</strong> <code>{rootClm.dimensions.abstractSpecification}</code></li>
+                    )}
+                    {rootClm?.dimensions?.concreteImplementation && (
+                        <li><strong>Concrete Implementation:</strong> <code>{rootClm.dimensions.concreteImplementation}</code></li>
+                    )}
+                    {rootClm?.dimensions?.balancedExpectations && (
+                        <li><strong>Balanced Expectations:</strong> <code>{rootClm.dimensions.balancedExpectations}</code></li>
+                    )}
                 </ul>
             </div>
         </div>
diff --git a/src/features/panellayoutSlice.json b/src/features/panellayoutSlice.json
index 16bf561..ef3cca3 100644
--- a/src/features/panellayoutSlice.json
+++ b/src/features/panellayoutSlice.json
@@ -41,13 +41,13 @@
     },
     "clm_layout": {
         "left": {
-            "type": "CLMDisplayPanel",
+            "type": "ContentDetailPanel",
             "size": 33,
             "minSize": 20,
             "visible": true
         },
         "middle": {
-            "type": "ContentDetailPanel", 
+            "type": "CLMInputPanel", 
             "size": 34,
             "minSize": 20,
             "visible": true
diff --git a/src/styles/clm-display.css b/src/styles/clm-display.css
index 653259a..809cfb1 100644
--- a/src/styles/clm-display.css
+++ b/src/styles/clm-display.css
@@ -24,19 +24,63 @@
 }
 
 .clm-display-loading, 
-.clm-display-error {
+.clm-display-error,
+.clm-display-placeholder {
     padding: 40px;
     text-align: center;
     background-color: #f7fafc;
     border-radius: 8px;
     color: #4a5568;
     font-size: 1.1rem;
+    min-height: 200px;
+    display: flex;
+    flex-direction: column;
+    justify-content: center;
+    align-items: center;
+}
+
+.clm-display-placeholder h3 {
+    margin-top: 0;
+    margin-bottom: 16px;
+    color: #2d3748;
+}
+
+.clm-display-placeholder p {
+    color: #718096;
 }
 
 .clm-display-error {
     color: #e53e3e;
     border: 1px solid #fed7d7;
     background-color: #fff5f5;
+    text-align: left;
+}
+
+.clm-display-error h3 {
+    margin-top: 0;
+    text-align: center;
+    margin-bottom: 16px;
+}
+
+.clm-incomplete-details {
+    background-color: #f8f8f8;
+    padding: 16px;
+    border-radius: 6px;
+    margin-top: 16px;
+    font-family: monospace;
+    font-size: 0.9rem;
+}
+
+.clm-incomplete-details code {
+    background-color: #2d3748;
+    color: #e2e8f0;
+    padding: 2px 6px;
+    border-radius: 4px;
+}
+
+.clm-incomplete-details ul {
+    margin-top: 8px;
+    padding-left: 24px;
 }
 
 .clm-table {

commit a1b52b9cc685c89499d65fc029b19f4d723938aa
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Mon Mar 31 15:52:03 2025 +0800

    new layout

diff --git a/src/features/panellayoutSlice.json b/src/features/panellayoutSlice.json
index 6d0ba82..16bf561 100644
--- a/src/features/panellayoutSlice.json
+++ b/src/features/panellayoutSlice.json
@@ -7,7 +7,7 @@
             "visible": true
         },
         "middle": {
-            "type": "ContentDetailPanel", 
+            "type": "CLMDisplayPanel", 
             "size": 40,
             "minSize": 20,
             "visible": true
@@ -47,7 +47,7 @@
             "visible": true
         },
         "middle": {
-            "type": "CLMInputPanel", 
+            "type": "ContentDetailPanel", 
             "size": 34,
             "minSize": 20,
             "visible": true

commit bf0155f2ce4453964a5147c9fb47f57566732081
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Mon Mar 31 15:51:02 2025 +0800

    new display

diff --git a/src/components/panels/CLMDisplayPanel.jsx b/src/components/panels/CLMDisplayPanel.jsx
new file mode 100644
index 0000000..f18a6cd
--- /dev/null
+++ b/src/components/panels/CLMDisplayPanel.jsx
@@ -0,0 +1,253 @@
+import React, { useState, useEffect } from 'react';
+import '../../styles/clm-display.css';
+
+// Make parameters optional and accept proper types
+const CLMDisplayPanel = ({ clmHash = null, initialHash = '' }) => {
+    const [loading, setLoading] = useState(true);
+    const [error, setError] = useState(null);
+    const [rootClm, setRootClm] = useState(null);
+    const [dimensions, setDimensions] = useState({
+        abstractSpecification: null,
+        concreteImplementation: null,
+        balancedExpectations: null
+    });
+
+    // If clmHash is not provided as a prop, try to get it from initialHash or URL
+    useEffect(() => {
+        const hashToUse = clmHash || initialHash;
+        
+        if (!hashToUse && typeof window !== 'undefined') {
+            const urlParams = new URLSearchParams(window.location.search);
+            const hashFromUrl = urlParams.get('hash');
+            if (hashFromUrl) {
+                console.log(`Getting CLM hash from URL: ${hashFromUrl}`);
+                loadClmData(hashFromUrl);
+            } else {
+                setError("No CLM hash provided");
+                setLoading(false);
+            }
+        } else if (hashToUse) {
+            loadClmData(hashToUse);
+        } else {
+            setError("No CLM hash provided and not running in browser");
+            setLoading(false);
+        }
+    }, [clmHash, initialHash]);
+
+    // Main function to load CLM data
+    const loadClmData = async (hash) => {
+        try {
+            setLoading(true);
+            setError(null);
+            
+            console.log(`Fetching root CLM with hash: ${hash}`);
+            const response = await fetch('/api/card-collection', {
+                method: 'POST',
+                headers: {
+                    'Content-Type': 'application/json'
+                },
+                body: JSON.stringify({
+                    action: 'get',
+                    hash: hash
+                })
+            });
+
+            if (!response.ok) {
+                throw new Error(`Failed to fetch CLM: ${response.status}`);
+            }
+
+            const result = await response.json();
+            if (!result.success) {
+                throw new Error(result.error || 'Failed to retrieve CLM data');
+            }
+
+            console.log('Root CLM received:', result.card);
+            setRootClm(result.card.content);
+            
+            // Now fetch each dimension by its hash
+            await fetchDimensions(result.card.content.dimensions);
+        } catch (error) {
+            console.error('Error fetching CLM:', error);
+            setError(`Error loading CLM: ${error.message}`);
+        } finally {
+            setLoading(false);
+        }
+    };
+
+    // Fetch each dimension by hash
+    const fetchDimensions = async (dimensionHashes) => {
+        try {
+            // Fetch abstract specification
+            if (dimensionHashes.abstractSpecification) {
+                console.log(`Fetching Abstract Specification with hash: ${dimensionHashes.abstractSpecification}`);
+                const abstractSpec = await fetchDimension(dimensionHashes.abstractSpecification);
+                setDimensions(prev => ({ ...prev, abstractSpecification: abstractSpec }));
+            }
+
+            // Fetch concrete implementation
+            if (dimensionHashes.concreteImplementation) {
+                console.log(`Fetching Concrete Implementation with hash: ${dimensionHashes.concreteImplementation}`);
+                const concreteImpl = await fetchDimension(dimensionHashes.concreteImplementation);
+                setDimensions(prev => ({ ...prev, concreteImplementation: concreteImpl }));
+            }
+
+            // Fetch balanced expectations
+            if (dimensionHashes.balancedExpectations) {
+                console.log(`Fetching Balanced Expectations with hash: ${dimensionHashes.balancedExpectations}`);
+                const balancedExp = await fetchDimension(dimensionHashes.balancedExpectations);
+                setDimensions(prev => ({ ...prev, balancedExpectations: balancedExp }));
+            }
+        } catch (error) {
+            console.error('Error fetching dimensions:', error);
+            setError(`Error loading dimension data: ${error.message}`);
+        }
+    };
+
+    // Helper function to fetch a single dimension by hash
+    const fetchDimension = async (hash) => {
+        const response = await fetch('/api/card-collection', {
+            method: 'POST',
+            headers: {
+                'Content-Type': 'application/json'
+            },
+            body: JSON.stringify({
+                action: 'get',
+                hash: hash
+            })
+        });
+
+        if (!response.ok) {
+            throw new Error(`Failed to fetch dimension: ${response.status}`);
+        }
+
+        const result = await response.json();
+        if (!result.success) {
+            throw new Error(result.error || 'Failed to retrieve dimension data');
+        }
+
+        return result.card.content;
+    };
+
+    if (loading) {
+        return <div className="clm-display-loading">Loading CLM data...</div>;
+    }
+
+    if (error) {
+        return <div className="clm-display-error">{error}</div>;
+    }
+
+    if (!rootClm || !dimensions.abstractSpecification || !dimensions.concreteImplementation || !dimensions.balancedExpectations) {
+        return <div className="clm-display-error">Unable to load complete CLM data</div>;
+    }
+
+    // Extract the abstract specification dimension data
+    const { context, goal, successCriteria } = dimensions.abstractSpecification;
+    
+    // Extract the concrete implementation dimension data
+    const { inputs, activities, outputs } = dimensions.concreteImplementation;
+    
+    // Extract the balanced expectations dimension data
+    const { practicalBoundaries, evaluationMetrics, feedbackLoops } = dimensions.balancedExpectations;
+
+    return (
+        <div className="clm-display-panel">
+            <h2 className="clm-title">{rootClm.title || 'Cubical Logic Model'}</h2>
+            
+            <div className="clm-metadata">
+                <p><strong>Created:</strong> {new Date(rootClm.createdAt).toLocaleString()}</p>
+                <p><strong>CLM Hash:</strong> <code>{clmHash.substring(0, 10)}...</code></p>
+            </div>
+            
+            <table className="clm-table">
+                <tbody>
+                    {/* Abstract Specification Section */}
+                    <tr>
+                        <th colSpan={6}>
+                            <a href="#abstract-specification">Abstract Specification</a>
+                            <small className="dimension-hash">Hash: {rootClm.dimensions.abstractSpecification.substring(0, 8)}...</small>
+                        </th>
+                    </tr>
+                    <tr>
+                        <th colSpan={1}><a href="#context">Context</a></th>
+                        <td colSpan={5} style={{ wordWrap: 'break-word' }}>
+                            {context}
+                        </td>
+                    </tr>
+                    <tr>
+                        <th colSpan={1}><a href="#goal">Goal</a></th>
+                        <td colSpan={5} style={{ wordWrap: 'break-word' }}>
+                            {goal}
+                        </td>
+                    </tr>
+                    <tr>
+                        <th colSpan={1}><a href="#success-criteria">Success Criteria</a></th>
+                        <td colSpan={5} style={{ wordWrap: 'break-word' }}>
+                            {successCriteria}
+                        </td>
+                    </tr>
+                    
+                    {/* Concrete Implementation Section */}
+                    <tr>
+                        <th colSpan={6}>
+                            <a href="#concrete-implementation">Concrete Implementation</a>
+                            <small className="dimension-hash">Hash: {rootClm.dimensions.concreteImplementation.substring(0, 8)}...</small>
+                        </th>
+                    </tr>
+                    <tr>
+                        <th colSpan={2}><a href="#inputs">Inputs</a></th>
+                        <th colSpan={2}><a href="#activities">Activities</a></th>
+                        <th colSpan={2}><a href="#outputs">Outputs</a></th>
+                    </tr>
+                    <tr>
+                        <td colSpan={2} style={{ wordWrap: 'break-word' }}>
+                            {inputs}
+                        </td>
+                        <td colSpan={2} style={{ wordWrap: 'break-word' }}>
+                            {activities}
+                        </td>
+                        <td colSpan={2} style={{ wordWrap: 'break-word' }}>
+                            {outputs}
+                        </td>
+                    </tr>
+
+                    {/* Balanced Expectations Section */}
+                    <tr>
+                        <th colSpan={6}>
+                            <a href="#balanced-expectations">Balanced Expectations</a>
+                            <small className="dimension-hash">Hash: {rootClm.dimensions.balancedExpectations.substring(0, 8)}...</small>
+                        </th>
+                    </tr>
+                    <tr>
+                        <th colSpan={2}><a href="#practical-boundaries">Practical Boundaries</a></th>
+                        <td colSpan={4} style={{ wordWrap: 'break-word' }}>
+                            {practicalBoundaries}
+                        </td>
+                    </tr>
+                    <tr>
+                        <th colSpan={2}><a href="#evaluation-metrics">Evaluation Metrics</a></th>
+                        <td colSpan={4} style={{ wordWrap: 'break-word' }}>
+                            {evaluationMetrics}
+                        </td>
+                    </tr>
+                    <tr>
+                        <th colSpan={2}><a href="#feedback-loops">Feedback Loops</a></th>
+                        <td colSpan={4} style={{ wordWrap: 'break-word' }}>
+                            {feedbackLoops}
+                        </td>
+                    </tr>
+                </tbody>
+            </table>
+            
+            <div className="clm-dimension-hashes">
+                <h3>Dimension Hash References</h3>
+                <ul>
+                    <li><strong>Abstract Specification:</strong> <code>{rootClm.dimensions.abstractSpecification}</code></li>
+                    <li><strong>Concrete Implementation:</strong> <code>{rootClm.dimensions.concreteImplementation}</code></li>
+                    <li><strong>Balanced Expectations:</strong> <code>{rootClm.dimensions.balancedExpectations}</code></li>
+                </ul>
+            </div>
+        </div>
+    );
+};
+
+export default CLMDisplayPanel;
diff --git a/src/components/panels/panels.json b/src/components/panels/panels.json
index c4db174..57a6de9 100644
--- a/src/components/panels/panels.json
+++ b/src/components/panels/panels.json
@@ -37,5 +37,8 @@
   },
   "CLMInputPanel": {
     "component": "../components/panels/CLMInputPanel.jsx"
+  },
+  "CLMDisplayPanel": {
+    "component": "../components/panels/CLMDisplayPanel.jsx"
   }
 }
diff --git a/src/features/panellayoutSlice.json b/src/features/panellayoutSlice.json
index bcda96a..6d0ba82 100644
--- a/src/features/panellayoutSlice.json
+++ b/src/features/panellayoutSlice.json
@@ -41,7 +41,7 @@
     },
     "clm_layout": {
         "left": {
-            "type": "SearchAndContent",
+            "type": "CLMDisplayPanel",
             "size": 33,
             "minSize": 20,
             "visible": true
diff --git a/src/pages/view-clm.astro b/src/pages/view-clm.astro
new file mode 100644
index 0000000..1ebaa00
--- /dev/null
+++ b/src/pages/view-clm.astro
@@ -0,0 +1,76 @@
+---
+import DefaultLayout from '../layouts/DefaultLayout.astro';
+import CLMDisplayPanel from '../components/panels/CLMDisplayPanel';
+
+// Get hash from URL if available (for SSR)
+const hash = Astro.url.searchParams.get('hash') || '';
+---
+
+<DefaultLayout title="View CLM">
+    <div class="clm-view-container">
+        <div class="clm-view-header">
+            <h1>Cubical Logic Model Viewer</h1>
+            <p>This component fetches and displays CLM data using the hash-based structure.</p>
+        </div>
+        
+        <div class="clm-hash-info">
+            <p>Viewing CLM with hash: <code id="clm-hash-display">Loading...</code></p>
+        </div>
+        
+        <div id="clm-display-mount" class="clm-display-container">
+            <CLMDisplayPanel client:load initialHash={hash} />
+        </div>
+    </div>
+</DefaultLayout>
+
+<script>
+    // Client-side script to get the hash from the URL and update the display
+    document.addEventListener('DOMContentLoaded', () => {
+        const params = new URLSearchParams(window.location.search);
+        const hash = params.get('hash');
+        
+        // Find the component container and render the hash
+        const hashDisplay = document.getElementById('clm-hash-display');
+        if (hashDisplay) {
+            hashDisplay.textContent = hash || 'No hash provided';
+        }
+        
+        // We don't need to manually update the component prop since it will
+        // read from the URL if no hash is provided
+    });
+</script>
+
+<style>
+    .clm-view-container {
+        max-width: 1200px;
+        margin: 0 auto;
+        padding: 20px;
+    }
+    
+    .clm-view-header {
+        margin-bottom: 20px;
+        text-align: center;
+    }
+    
+    .clm-hash-info {
+        background-color: #edf2f7;
+        padding: 10px 16px;
+        border-radius: 8px;
+        margin-bottom: 20px;
+        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
+    }
+    
+    .clm-hash-info code {
+        background-color: #2d3748;
+        color: #e2e8f0;
+        padding: 2px 6px;
+        border-radius: 4px;
+        font-family: monospace;
+    }
+    
+    .clm-display-container {
+        background-color: white;
+        border-radius: 8px;
+        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
+    }
+</style>
diff --git a/src/styles/clm-display.css b/src/styles/clm-display.css
new file mode 100644
index 0000000..653259a
--- /dev/null
+++ b/src/styles/clm-display.css
@@ -0,0 +1,140 @@
+.clm-display-panel {
+    max-width: 100%;
+    margin: 0 auto;
+    padding: 20px;
+    background: white;
+    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
+}
+
+.clm-title {
+    font-size: 1.8rem;
+    margin-bottom: 16px;
+    color: #1a202c;
+    text-align: center;
+}
+
+.clm-metadata {
+    display: flex;
+    justify-content: space-between;
+    margin-bottom: 20px;
+    color: #4a5568;
+    font-size: 0.9rem;
+    border-bottom: 1px solid #e2e8f0;
+    padding-bottom: 10px;
+}
+
+.clm-display-loading, 
+.clm-display-error {
+    padding: 40px;
+    text-align: center;
+    background-color: #f7fafc;
+    border-radius: 8px;
+    color: #4a5568;
+    font-size: 1.1rem;
+}
+
+.clm-display-error {
+    color: #e53e3e;
+    border: 1px solid #fed7d7;
+    background-color: #fff5f5;
+}
+
+.clm-table {
+    width: 100%;
+    border-collapse: collapse;
+    margin-bottom: 20px;
+    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
+}
+
+.clm-table th,
+.clm-table td {
+    border: 1px solid #cbd5e0;
+    padding: 12px;
+    vertical-align: top;
+}
+
+.clm-table th {
+    background-color: #2d3748;
+    color: #e2e8f0;
+    text-align: left;
+    position: relative;
+}
+
+.clm-table th a {
+    color: #63b3ed;
+    text-decoration: none;
+}
+
+.clm-table th a:hover {
+    text-decoration: underline;
+}
+
+.dimension-hash {
+    position: absolute;
+    right: 10px;
+    font-size: 0.7rem;
+    color: #a0aec0;
+    top: 50%;
+    transform: translateY(-50%);
+}
+
+.clm-dimension-hashes {
+    margin-top: 30px;
+    padding: 16px;
+    background-color: #edf2f7;
+    border-radius: 8px;
+    font-family: monospace;
+    font-size: 0.9rem;
+}
+
+.clm-dimension-hashes h3 {
+    margin-top: 0;
+    color: #4a5568;
+    font-size: 1.1rem;
+    margin-bottom: 12px;
+}
+
+.clm-dimension-hashes ul {
+    list-style-type: none;
+    padding: 0;
+    margin: 0;
+}
+
+.clm-dimension-hashes li {
+    margin-bottom: 8px;
+}
+
+.clm-dimension-hashes code {
+    background-color: #2d3748;
+    color: #e2e8f0;
+    padding: 2px 6px;
+    border-radius: 4px;
+    font-size: 0.8rem;
+    word-break: break-all;
+}
+
+.clm-table td {
+    white-space: pre-wrap;
+    line-height: 1.5;
+}
+
+@media (max-width: 768px) {
+    .clm-metadata {
+        flex-direction: column;
+        gap: 8px;
+    }
+    
+    .clm-table th,
+    .clm-table td {
+        padding: 8px;
+        font-size: 0.9rem;
+    }
+    
+    .dimension-hash {
+        position: static;
+        display: block;
+        text-align: right;
+        transform: none;
+        margin-top: 4px;
+    }
+}

commit 911c6de767376a36b77d7de8b3a81964f706b4e9
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Mon Mar 31 15:43:39 2025 +0800

    better CLM input

diff --git a/public/data/cards.db-wal b/public/data/cards.db-wal
index 4217a6d..d9f766d 100644
Binary files a/public/data/cards.db-wal and b/public/data/cards.db-wal differ
diff --git a/src/components/panels/CLMInputPanel.jsx b/src/components/panels/CLMInputPanel.jsx
index 2086556..30e1581 100644
--- a/src/components/panels/CLMInputPanel.jsx
+++ b/src/components/panels/CLMInputPanel.jsx
@@ -212,28 +212,92 @@ const CLMInputPanel = () => {
         }
 
         try {
-            // Generate JSON-formatted content for each dimension MCard according to CLM_for_CLM_Mcard.md spec
+            // Step 1: Generate JSON-formatted content for each dimension MCard
             const abstractSpecificationJson = generateJsonData('abstractSpecification');
             const concreteImplementationJson = generateJsonData('concreteImplementation');
             const balancedExpectationsJson = generateJsonData('balancedExpectations');
 
-            // Prepare the root CLM MCard JSON structure 
-            // Following the hierarchical structure defined in CLM_for_CLM_Mcard.md
+            // Step 2: Store each dimension as its own MCard to get hash references
+            // First, save Abstract Specification dimension
+            console.log("Saving Abstract Specification dimension...");
+            const abstractSpecResponse = await fetch('/api/card-collection', {
+                method: 'POST',
+                headers: {
+                    'Content-Type': 'application/json'
+                },
+                body: JSON.stringify({
+                    action: 'add',
+                    card: {
+                        content: abstractSpecificationJson
+                    }
+                })
+            });
+            
+            if (!abstractSpecResponse.ok) {
+                throw new Error(`Failed to save Abstract Specification: ${abstractSpecResponse.status}`);
+            }
+            const abstractSpecResult = await abstractSpecResponse.json();
+            const abstractSpecHash = abstractSpecResult.hash;
+            
+            // Next, save Concrete Implementation dimension
+            console.log("Saving Concrete Implementation dimension...");
+            const concreteImplResponse = await fetch('/api/card-collection', {
+                method: 'POST',
+                headers: {
+                    'Content-Type': 'application/json'
+                },
+                body: JSON.stringify({
+                    action: 'add',
+                    card: {
+                        content: concreteImplementationJson
+                    }
+                })
+            });
+            
+            if (!concreteImplResponse.ok) {
+                throw new Error(`Failed to save Concrete Implementation: ${concreteImplResponse.status}`);
+            }
+            const concreteImplResult = await concreteImplResponse.json();
+            const concreteImplHash = concreteImplResult.hash;
+            
+            // Finally, save Balanced Expectations dimension
+            console.log("Saving Balanced Expectations dimension...");
+            const balancedExpResponse = await fetch('/api/card-collection', {
+                method: 'POST',
+                headers: {
+                    'Content-Type': 'application/json'
+                },
+                body: JSON.stringify({
+                    action: 'add',
+                    card: {
+                        content: balancedExpectationsJson
+                    }
+                })
+            });
+            
+            if (!balancedExpResponse.ok) {
+                throw new Error(`Failed to save Balanced Expectations: ${balancedExpResponse.status}`);
+            }
+            const balancedExpResult = await balancedExpResponse.json();
+            const balancedExpHash = balancedExpResult.hash;
+
+            // Step 3: Create the root CLM MCard with references to the dimension hashes
+            console.log("Creating root CLM with dimension hash references...");
             const rootClmJson = {
                 title: documentTitle,
                 createdAt: new Date().toISOString(),
                 type: 'clm_document',
-                // In a full implementation, this would use actual hash references
-                // But for now we'll include the full content
+                // Reference dimensions by their hash values according to the CLM_for_CLM_Mcard.md spec
                 dimensions: {
-                    abstractSpecification: abstractSpecificationJson,
-                    concreteImplementation: concreteImplementationJson,
-                    balancedExpectations: balancedExpectationsJson
+                    abstractSpecification: abstractSpecHash,
+                    concreteImplementation: concreteImplHash,
+                    balancedExpectations: balancedExpHash
                 }
             };
 
-            // Store in database using the card-collection API endpoint
-            const response = await fetch('/api/card-collection', {
+            // Step 4: Store the root CLM MCard
+            console.log("Saving root CLM...");
+            const rootClmResponse = await fetch('/api/card-collection', {
                 method: 'POST',
                 headers: {
                     'Content-Type': 'application/json'
@@ -247,11 +311,11 @@ const CLMInputPanel = () => {
             });
 
             // Improved error handling to diagnose issues
-            if (!response.ok) {
-                const errorText = await response.text();
+            if (!rootClmResponse.ok) {
+                const errorText = await rootClmResponse.text();
                 console.error('Server response error:', {
-                    status: response.status,
-                    statusText: response.statusText,
+                    status: rootClmResponse.status,
+                    statusText: rootClmResponse.statusText,
                     responseText: errorText
                 });
                 
@@ -262,13 +326,13 @@ const CLMInputPanel = () => {
                     errorMessage = errorData.error || 'Failed to save CLM data';
                 } catch (e) {
                     // If it's not valid JSON (like HTML), provide a more helpful error
-                    errorMessage = `Server error (${response.status}): The API endpoint may not exist or returned HTML instead of JSON`;
+                    errorMessage = `Server error (${rootClmResponse.status}): The API endpoint may not exist or returned HTML instead of JSON`;
                 }
                 
                 throw new Error(errorMessage);
             }
 
-            const result = await response.json();
+            const result = await rootClmResponse.json();
             
             if (result.success) {
                 // Store the CLM hash for future updates

commit 62af95ed00aaba8c102d4b54200bafc2aff72663
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Mon Mar 31 15:40:32 2025 +0800

    succesfull upload

diff --git a/public/data/cards.db-shm b/public/data/cards.db-shm
index ede3cae..c9a166d 100644
Binary files a/public/data/cards.db-shm and b/public/data/cards.db-shm differ
diff --git a/public/data/cards.db-wal b/public/data/cards.db-wal
index a78b8b6..4217a6d 100644
Binary files a/public/data/cards.db-wal and b/public/data/cards.db-wal differ
diff --git a/src/components/panels/CLMInputPanel.jsx b/src/components/panels/CLMInputPanel.jsx
index ba64b06..2086556 100644
--- a/src/components/panels/CLMInputPanel.jsx
+++ b/src/components/panels/CLMInputPanel.jsx
@@ -3,7 +3,6 @@ import SaveButton from './clm/SaveButton';
 import AbstractSpecification from './clm/AbstractSpecification';
 import ConcreteImplementation from './clm/ConcreteImplementation';
 import BalancedExpectations from './clm/BalancedExpectations';
-import CubicalLogicModel from './clm/CubicalLogicModel';
 
 const CLMInputPanel = () => {
     // Title state
@@ -28,24 +27,6 @@ const CLMInputPanel = () => {
             practicalBoundaries: '',
             evaluationMetrics: '',
             feedbackLoops: ''
-        },
-        // Cubical Logic Model dimension
-        cubicalLogicModel: {
-            abstractSpecification: {
-                context: '',
-                goal: '',
-                successCriteria: ''
-            },
-            concreteImplementation: {
-                inputs: '',
-                activities: '',
-                outputs: ''
-            },
-            balancedExpectations: {
-                practicalBoundaries: '',
-                evaluationMetrics: '',
-                feedbackLoops: ''
-            }
         }
     });
     
@@ -66,21 +47,23 @@ const CLMInputPanel = () => {
         };
     };
 
-    // Auto-update a specific dimension
-    const updateDimension = async (dimension, content) => {
+    // Auto-update a specific dimension - defined using useCallback to memoize
+    const updateDimension = useCallback(async (dimension, content) => {
         if (!currentClmHash || !autoSaveEnabled) return;
         
         try {
-            // Create dimension update payload
+            // Create dimension update payload following CLM_for_CLM_Mcard.md structure
             const dimensionUpdate = {
-                parent_hash: currentClmHash,
+                parentHash: currentClmHash,
                 dimension: dimension,
                 type: 'clm_dimension_update',
                 timestamp: new Date().toISOString(),
-                // Include the content directly
-                ...content
+                // Include the dimension content with proper structure
+                content: content  // This already has the correct dimensionType field from generateJsonData
             };
 
+            console.log(`Starting update for ${dimension} dimension`);
+
             // Use the card-collection API with action=add to update the dimension
             const response = await fetch('/api/card-collection', {
                 method: 'POST',
@@ -116,44 +99,70 @@ const CLMInputPanel = () => {
         } catch (error) {
             console.error('Error in auto-update:', error);
         }
-    };
-
-    // Debounced update function
-    const debouncedUpdate = useCallback(
-        debounce((dimension, content) => {
-            updateDimension(dimension, content);
-        }, 2000),
-        [currentClmHash, autoSaveEnabled]
-    );
+    }, [currentClmHash, autoSaveEnabled]);
 
+    // Create debounced function outside of useCallback to avoid circular dependencies
+    const debouncedUpdateFn = debounce((updateFn, dimension, content) => {
+        console.log(`Debounced update for ${dimension} dimension triggered`);
+        updateFn(dimension, content);
+    }, 2000);
+    
     // Handle input changes for all dimensions
     const handleInputChange = (dimension, section, field, value) => {
-        if (dimension === 'cubicalLogicModel') {
-            // Handle nested structure for Cubical Logic Model
-            setClmData(prevState => ({
-                ...prevState,
-                [dimension]: {
-                    ...prevState[dimension],
-                    [section]: {
-                        ...prevState[dimension][section],
-                        [field]: value
+        console.log(`CLMInputPanel handleInputChange called:`, {
+            dimension, section, field, value
+        });
+
+        // If field is undefined but value is, then we're receiving params in a different order
+        // This happens when dimension components call handleInputChange(dimension, null, key, value)
+        if (value === undefined && field !== undefined) {
+            // Rearrange parameters to account for dimension components' call pattern
+            value = field;
+            field = section;
+            section = null;
+        }
+
+        console.log(`After parameter normalization:`, {
+            dimension, section, field, value
+        });
+
+        // Update local state first
+        if (section) {
+            // This handles nested structures (legacy format)
+            setClmData(prevState => {
+                console.log("Updating with section:", { dimension, section, field, value });
+                return {
+                    ...prevState,
+                    [dimension]: {
+                        ...prevState[dimension],
+                        [section]: {
+                            ...prevState[dimension][section],
+                            [field]: value
+                        }
                     }
-                }
-            }));
+                };
+            });
         } else {
-            // Handle flat structure for other dimensions
-            setClmData(prevState => ({
-                ...prevState,
-                [dimension]: {
-                    ...prevState[dimension],
-                    [field]: value
-                }
-            }));
+            // This handles direct field updates from dimension components
+            setClmData(prevState => {
+                console.log("Updating directly:", { dimension, field, value });
+                return {
+                    ...prevState,
+                    [dimension]: {
+                        ...prevState[dimension],
+                        [field]: value
+                    }
+                };
+            });
         }
 
-        // Trigger auto-save if enabled
+        // Trigger auto-save if enabled, but don't block input
         if (autoSaveEnabled && currentClmHash) {
-            debouncedUpdate(dimension, generateJsonData(dimension));
+            // Use a setTimeout to avoid blocking the UI thread during state updates
+            setTimeout(() => {
+                const jsonData = generateJsonData(dimension);
+                debouncedUpdateFn(updateDimension, dimension, jsonData);
+            }, 0);
         }
     };
 
@@ -162,15 +171,15 @@ const CLMInputPanel = () => {
         switch(dimension) {
             case 'abstractSpecification':
                 return {
-                    dimension_type: "abstract_specification",
+                    dimensionType: "abstractSpecification",
                     context: data.abstractSpecification.context,
                     goal: data.abstractSpecification.goal,
-                    success_criteria: data.abstractSpecification.successCriteria
+                    successCriteria: data.abstractSpecification.successCriteria
                 };
             
             case 'concreteImplementation':
                 return {
-                    dimension_type: "concrete_implementation",
+                    dimensionType: "concreteImplementation",
                     inputs: data.concreteImplementation.inputs,
                     activities: data.concreteImplementation.activities,
                     outputs: data.concreteImplementation.outputs
@@ -178,30 +187,10 @@ const CLMInputPanel = () => {
             
             case 'balancedExpectations':
                 return {
-                    dimension_type: "balanced_expectations",
-                    practical_boundaries: data.balancedExpectations.practicalBoundaries,
-                    evaluation_metrics: data.balancedExpectations.evaluationMetrics,
-                    feedback_loops: data.balancedExpectations.feedbackLoops
-                };
-            
-            case 'cubicalLogicModel':
-                return {
-                    dimension_type: "cubical_logic_model",
-                    abstract_specification: {
-                        context: data.cubicalLogicModel.abstractSpecification.context,
-                        goal: data.cubicalLogicModel.abstractSpecification.goal,
-                        success_criteria: data.cubicalLogicModel.abstractSpecification.successCriteria
-                    },
-                    concrete_implementation: {
-                        inputs: data.cubicalLogicModel.concreteImplementation.inputs,
-                        activities: data.cubicalLogicModel.concreteImplementation.activities,
-                        outputs: data.cubicalLogicModel.concreteImplementation.outputs
-                    },
-                    balanced_expectations: {
-                        practical_boundaries: data.cubicalLogicModel.balancedExpectations.practicalBoundaries,
-                        evaluation_metrics: data.cubicalLogicModel.balancedExpectations.evaluationMetrics,
-                        feedback_loops: data.cubicalLogicModel.balancedExpectations.feedbackLoops
-                    }
+                    dimensionType: "balancedExpectations",
+                    practicalBoundaries: data.balancedExpectations.practicalBoundaries,
+                    evaluationMetrics: data.balancedExpectations.evaluationMetrics,
+                    feedbackLoops: data.balancedExpectations.feedbackLoops
                 };
             
             default:
@@ -223,21 +212,23 @@ const CLMInputPanel = () => {
         }
 
         try {
-            // Generate JSON-formatted content for each dimension MCard
+            // Generate JSON-formatted content for each dimension MCard according to CLM_for_CLM_Mcard.md spec
             const abstractSpecificationJson = generateJsonData('abstractSpecification');
             const concreteImplementationJson = generateJsonData('concreteImplementation');
             const balancedExpectationsJson = generateJsonData('balancedExpectations');
-            const cubicalLogicModelJson = generateJsonData('cubicalLogicModel');
 
-            // Prepare the root CLM MCard JSON
+            // Prepare the root CLM MCard JSON structure 
+            // Following the hierarchical structure defined in CLM_for_CLM_Mcard.md
             const rootClmJson = {
                 title: documentTitle,
+                createdAt: new Date().toISOString(),
                 type: 'clm_document',
-                created_at: new Date().toISOString(),
+                // In a full implementation, this would use actual hash references
+                // But for now we'll include the full content
                 dimensions: {
-                    abstract_specification: abstractSpecificationJson,
-                    concrete_implementation: concreteImplementationJson,
-                    balanced_expectations: balancedExpectationsJson
+                    abstractSpecification: abstractSpecificationJson,
+                    concreteImplementation: concreteImplementationJson,
+                    balancedExpectations: balancedExpectationsJson
                 }
             };
 
@@ -407,49 +398,39 @@ const CLMInputPanel = () => {
                         generateJsonData={generateJsonData}
                     />
                 );
-            case 'cubicalLogicModel':
-                return (
-                    <CubicalLogicModel 
-                        data={clmData.cubicalLogicModel}
-                        onChange={handleInputChange}
-                        generateJsonData={generateJsonData}
-                    />
-                );
             default:
                 return null;
         }
     };
 
+    useEffect(() => {
+        // Make sure this function is updated when dependencies change
+    }, [updateDimension]);
+
     return (
         <div className="h-full bg-white overflow-y-auto p-6">
             <div className="max-w-3xl mx-auto space-y-8">
                 {/* Header with Navigation and Save Button */}
-                <div className="flex justify-between items-center border-b pb-4">
-                    <div className="tabs">
+                <div className="flex flex-col md:flex-row justify-between items-center border-b pb-4">
+                    <div className="tabs w-full md:w-auto mb-4 md:mb-0">
                         <button 
-                            className={activeDimension === 'abstractSpecification' ? 'active' : ''} 
+                            className={`px-4 py-2 rounded-md mr-2 ${activeDimension === 'abstractSpecification' ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-800'}`}
                             onClick={() => setActiveDimension('abstractSpecification')}
                         >
                             Abstract Specification
                         </button>
                         <button 
-                            className={activeDimension === 'concreteImplementation' ? 'active' : ''} 
+                            className={`px-4 py-2 rounded-md mr-2 ${activeDimension === 'concreteImplementation' ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-800'}`}
                             onClick={() => setActiveDimension('concreteImplementation')}
                         >
                             Concrete Implementation
                         </button>
                         <button 
-                            className={activeDimension === 'balancedExpectations' ? 'active' : ''} 
+                            className={`px-4 py-2 rounded-md ${activeDimension === 'balancedExpectations' ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-800'}`}
                             onClick={() => setActiveDimension('balancedExpectations')}
                         >
                             Balanced Expectations
                         </button>
-                        <button 
-                            className={activeDimension === 'cubicalLogicModel' ? 'active' : ''} 
-                            onClick={() => setActiveDimension('cubicalLogicModel')}
-                        >
-                            Cubical Logic Model
-                        </button>
                     </div>
                     <SaveButton 
                         onSave={handleSubmit} 
diff --git a/src/components/panels/clm/AbstractSpecification.jsx b/src/components/panels/clm/AbstractSpecification.jsx
index a55a4f7..b7dc701 100644
--- a/src/components/panels/clm/AbstractSpecification.jsx
+++ b/src/components/panels/clm/AbstractSpecification.jsx
@@ -2,6 +2,9 @@ import React from 'react';
 import DimensionPanel from './DimensionPanel';
 
 const AbstractSpecification = ({ data, onChange, generateJsonData }) => {
+    console.log("AbstractSpecification rendered with data:", data);
+    
+    // Define fields according to CLM_for_CLM_Mcard.md spec
     const fields = [
         {
             key: 'context',
@@ -20,17 +23,36 @@ const AbstractSpecification = ({ data, onChange, generateJsonData }) => {
         }
     ];
 
+    // Add dimensionType to local data before passing to parent
     const handleChange = (key, value) => {
-        onChange('abstractSpecification', key, value);
+        console.log(`AbstractSpecification handleChange: ${key} = "${value}"`);
+        // Important: DO NOT include section parameter for dimension components
+        onChange('abstractSpecification', null, key, value);
+    };
+
+    // Build the dimension data with proper structure - directly return object
+    const getDimensionData = () => {
+        if (!data) {
+            console.warn("No data provided to AbstractSpecification");
+            return { dimensionType: "abstractSpecification" };
+        }
+
+        // Create a clean object for JSON preview
+        return {
+            dimensionType: "abstractSpecification",
+            context: data.context || "",
+            goal: data.goal || "",
+            successCriteria: data.successCriteria || ""
+        };
     };
 
     return (
         <DimensionPanel
             title="Abstract Specification"
             fields={fields}
-            data={data}
+            data={data || {}}
             onChange={handleChange}
-            jsonData={generateJsonData('abstractSpecification')}
+            jsonData={getDimensionData()}
         />
     );
 };
diff --git a/src/components/panels/clm/BalancedExpectations.jsx b/src/components/panels/clm/BalancedExpectations.jsx
index 25e614e..702f23f 100644
--- a/src/components/panels/clm/BalancedExpectations.jsx
+++ b/src/components/panels/clm/BalancedExpectations.jsx
@@ -2,6 +2,9 @@ import React from 'react';
 import DimensionPanel from './DimensionPanel';
 
 const BalancedExpectations = ({ data, onChange, generateJsonData }) => {
+    console.log("BalancedExpectations rendered with data:", data);
+    
+    // Define fields according to CLM_for_CLM_Mcard.md spec
     const fields = [
         {
             key: 'practicalBoundaries',
@@ -20,17 +23,36 @@ const BalancedExpectations = ({ data, onChange, generateJsonData }) => {
         }
     ];
 
+    // Add dimensionType to local data before passing to parent
     const handleChange = (key, value) => {
-        onChange('balancedExpectations', key, value);
+        console.log(`BalancedExpectations handleChange: ${key} = "${value}"`);
+        // Important: DO NOT include section parameter for dimension components
+        onChange('balancedExpectations', null, key, value);
+    };
+
+    // Build the dimension data with proper structure - directly return object
+    const getDimensionData = () => {
+        if (!data) {
+            console.warn("No data provided to BalancedExpectations");
+            return { dimensionType: "balancedExpectations" };
+        }
+
+        // Create a clean object for JSON preview
+        return {
+            dimensionType: "balancedExpectations",
+            practicalBoundaries: data.practicalBoundaries || "",
+            evaluationMetrics: data.evaluationMetrics || "",
+            feedbackLoops: data.feedbackLoops || ""
+        };
     };
 
     return (
         <DimensionPanel
             title="Balanced Expectations"
             fields={fields}
-            data={data}
+            data={data || {}}
             onChange={handleChange}
-            jsonData={generateJsonData('balancedExpectations')}
+            jsonData={getDimensionData()}
         />
     );
 };
diff --git a/src/components/panels/clm/ConcreteImplementation.jsx b/src/components/panels/clm/ConcreteImplementation.jsx
index d3f01f9..6d7bfd6 100644
--- a/src/components/panels/clm/ConcreteImplementation.jsx
+++ b/src/components/panels/clm/ConcreteImplementation.jsx
@@ -2,6 +2,9 @@ import React from 'react';
 import DimensionPanel from './DimensionPanel';
 
 const ConcreteImplementation = ({ data, onChange, generateJsonData }) => {
+    console.log("ConcreteImplementation rendered with data:", data);
+    
+    // Define fields according to CLM_for_CLM_Mcard.md spec
     const fields = [
         {
             key: 'inputs',
@@ -20,17 +23,36 @@ const ConcreteImplementation = ({ data, onChange, generateJsonData }) => {
         }
     ];
 
+    // Add dimensionType to local data before passing to parent
     const handleChange = (key, value) => {
-        onChange('concreteImplementation', key, value);
+        console.log(`ConcreteImplementation handleChange: ${key} = "${value}"`);
+        // Important: DO NOT include section parameter for dimension components
+        onChange('concreteImplementation', null, key, value);
+    };
+
+    // Build the dimension data with proper structure - directly return object
+    const getDimensionData = () => {
+        if (!data) {
+            console.warn("No data provided to ConcreteImplementation");
+            return { dimensionType: "concreteImplementation" };
+        }
+
+        // Create a clean object for JSON preview
+        return {
+            dimensionType: "concreteImplementation",
+            inputs: data.inputs || "",
+            activities: data.activities || "",
+            outputs: data.outputs || ""
+        };
     };
 
     return (
         <DimensionPanel
             title="Concrete Implementation"
             fields={fields}
-            data={data}
+            data={data || {}}
             onChange={handleChange}
-            jsonData={generateJsonData('concreteImplementation')}
+            jsonData={getDimensionData()}
         />
     );
 };
diff --git a/src/components/panels/clm/CubicalLogicModel.jsx b/src/components/panels/clm/CubicalLogicModel.jsx
deleted file mode 100644
index e333a85..0000000
--- a/src/components/panels/clm/CubicalLogicModel.jsx
+++ /dev/null
@@ -1,164 +0,0 @@
-import React, { useState, useEffect } from 'react';
-import JsonPreview from './JsonPreview';
-import '../../../styles/clm-table.css';
-
-const CubicalLogicModel = ({ 
-    data = {}, 
-    onChange, 
-    generateJsonData,
-    isReadOnly = false 
-}) => {
-    const [localData, setLocalData] = useState({
-        // Three dimensions of Cubical Logic Model
-        abstractSpecification: {
-            context: '',
-            goal: '',
-            successCriteria: ''
-        },
-        concreteImplementation: {
-            inputs: '',
-            activities: '',
-            outputs: ''
-        },
-        balancedExpectations: {
-            practicalBoundaries: '',
-            evaluationMetrics: '',
-            feedbackLoops: ''
-        }
-    });
-
-    useEffect(() => {
-        // Initialize with provided data or keep defaults
-        if (data && Object.keys(data).length > 0) {
-            setLocalData(data);
-        }
-    }, [data]);
-
-    const handleInputChange = (section, field, value) => {
-        const updatedData = { 
-            ...localData, 
-            [section]: {
-                ...localData[section],
-                [field]: value
-            }
-        };
-        setLocalData(updatedData);
-        
-        // Notify parent component about data changes
-        if (onChange && !isReadOnly) {
-            onChange('cubicalLogicModel', section, field, value);
-        }
-    };
-
-    const renderSection = (sectionName, title, fields) => {
-        return (
-            <div className="clm-section">
-                <h4>{title}</h4>
-                <div className="section-content">
-                    {fields.map(field => (
-                        <div className="form-group" key={field.key}>
-                            <label>{field.label}</label>
-                            <textarea
-                                value={localData[sectionName][field.key]}
-                                onChange={(e) => handleInputChange(sectionName, field.key, e.target.value)}
-                                placeholder={field.placeholder}
-                                disabled={isReadOnly}
-                                rows={4}
-                            />
-                        </div>
-                    ))}
-                </div>
-            </div>
-        );
-    };
-
-    return (
-        <div className="cubical-logic-model-panel">
-            <h3>Cubical Logic Model</h3>
-            
-            {!isReadOnly && (
-                <div className="input-section clm-grid">
-                    {renderSection('abstractSpecification', 'Abstract Specification', [
-                        { key: 'context', label: 'Context', placeholder: 'Describe the contextual background' },
-                        { key: 'goal', label: 'Goal', placeholder: 'Define the primary goal' },
-                        { key: 'successCriteria', label: 'Success Criteria', placeholder: 'List the criteria for success' }
-                    ])}
-
-                    {renderSection('concreteImplementation', 'Concrete Implementation', [
-                        { key: 'inputs', label: 'Inputs', placeholder: 'List required inputs and resources' },
-                        { key: 'activities', label: 'Activities', placeholder: 'Describe implementation activities' },
-                        { key: 'outputs', label: 'Outputs', placeholder: 'Define expected outputs' }
-                    ])}
-
-                    {renderSection('balancedExpectations', 'Balanced Expectations', [
-                        { key: 'practicalBoundaries', label: 'Practical Boundaries', placeholder: 'Define practical boundaries and constraints' },
-                        { key: 'evaluationMetrics', label: 'Evaluation Metrics', placeholder: 'Describe evaluation data and performance metrics' },
-                        { key: 'feedbackLoops', label: 'Feedback Loops', placeholder: 'Outline feedback loops and validation mechanisms' }
-                    ])}
-                </div>
-            )}
-
-            {/* Table Display Preview */}
-            {isReadOnly && (
-                <div className="clm-table-preview">
-                    <table className="clm-table">
-                        <tbody>
-                            <tr>
-                                <th colSpan={6}>Abstract Specification</th>
-                            </tr>
-                            <tr>
-                                <th>Context</th>
-                                <td colSpan={5}>{localData.abstractSpecification.context}</td>
-                            </tr>
-                            <tr>
-                                <th>Goal</th>
-                                <td colSpan={5}>{localData.abstractSpecification.goal}</td>
-                            </tr>
-                            <tr>
-                                <th>Success Criteria</th>
-                                <td colSpan={5}>{localData.abstractSpecification.successCriteria}</td>
-                            </tr>
-
-                            <tr>
-                                <th colSpan={6}>Concrete Implementation</th>
-                            </tr>
-                            <tr>
-                                <th colSpan={2}>Inputs</th>
-                                <th colSpan={2}>Activities</th>
-                                <th colSpan={2}>Outputs</th>
-                            </tr>
-                            <tr>
-                                <td colSpan={2}>{localData.concreteImplementation.inputs}</td>
-                                <td colSpan={2}>{localData.concreteImplementation.activities}</td>
-                                <td colSpan={2}>{localData.concreteImplementation.outputs}</td>
-                            </tr>
-
-                            <tr>
-                                <th colSpan={6}>Balanced Expectations</th>
-                            </tr>
-                            <tr>
-                                <th colSpan={2}>Practical Boundaries</th>
-                                <td colSpan={4}>{localData.balancedExpectations.practicalBoundaries}</td>
-                            </tr>
-                            <tr>
-                                <th colSpan={2}>Evaluation Metrics</th>
-                                <td colSpan={4}>{localData.balancedExpectations.evaluationMetrics}</td>
-                            </tr>
-                            <tr>
-                                <th colSpan={2}>Feedback Loops</th>
-                                <td colSpan={4}>{localData.balancedExpectations.feedbackLoops}</td>
-                            </tr>
-                        </tbody>
-                    </table>
-                </div>
-            )}
-
-            <JsonPreview 
-                data={localData} 
-                title="Cubical Logic Model JSON" 
-            />
-        </div>
-    );
-};
-
-export default CubicalLogicModel;
diff --git a/src/components/panels/clm/DimensionPanel.jsx b/src/components/panels/clm/DimensionPanel.jsx
index d89fbee..22aed0f 100644
--- a/src/components/panels/clm/DimensionPanel.jsx
+++ b/src/components/panels/clm/DimensionPanel.jsx
@@ -3,23 +3,48 @@ import JsonPreview from './JsonPreview';
 
 // Base component for dimension panels
 const DimensionPanel = ({ title, fields, data, onChange, jsonData }) => {
+    // Add debugging to help diagnose issues
+    console.log(`DimensionPanel rendering ${title} with data:`, data);
+    console.log(`JsonData received:`, jsonData);
+    
+    const handleChange = (key, value) => {
+        console.log(`Field changed: ${key} = ${value}`);
+        onChange(key, value);
+    };
+    
     return (
         <div className="space-y-6">
             <h2 className="text-2xl font-bold">{title}</h2>
             
-            {fields.map(field => (
-                <div key={field.key}>
-                    <label className="block text-sm font-medium text-gray-700 mb-2">{field.label}</label>
-                    <textarea 
-                        className="w-full h-40 p-3 rounded-lg border border-gray-300 focus:ring-2 focus:ring-blue-500"
-                        placeholder={field.placeholder}
-                        value={data[field.key]}
-                        onChange={(e) => onChange(field.key, e.target.value)}
-                    />
-                </div>
-            ))}
+            {fields.map(field => {
+                // Check if the data object actually has this property
+                const fieldValue = data && typeof data[field.key] !== 'undefined' ? data[field.key] : '';
+                
+                // Ensure we're not passing an object as a string value
+                if (typeof fieldValue === 'object' && fieldValue !== null) {
+                    console.warn(`Field ${field.key} has object value`, fieldValue);
+                }
+                
+                return (
+                    <div key={field.key}>
+                        <label className="block text-sm font-medium text-gray-700 mb-2">{field.label}</label>
+                        <textarea 
+                            className="w-full h-40 p-3 rounded-lg border border-gray-300 focus:ring-2 focus:ring-blue-500"
+                            placeholder={field.placeholder}
+                            value={typeof fieldValue === 'string' ? fieldValue : ''}
+                            onChange={(e) => handleChange(field.key, e.target.value)}
+                        />
+                    </div>
+                );
+            })}
             
-            <JsonPreview jsonData={jsonData} />
+            {/* Only render the JSON preview if we have valid data */}
+            {jsonData && (
+                <JsonPreview 
+                    data={jsonData} 
+                    title={`${title} JSON`} 
+                />
+            )}
         </div>
     );
 };
diff --git a/src/components/panels/clm/JsonPreview.jsx b/src/components/panels/clm/JsonPreview.jsx
index 622bd7d..2ab1d19 100644
--- a/src/components/panels/clm/JsonPreview.jsx
+++ b/src/components/panels/clm/JsonPreview.jsx
@@ -1,8 +1,11 @@
 import React from 'react';
 
-const JsonPreview = ({ data, title = "JSON Preview" }) => {
+const JsonPreview = ({ data, jsonData, title = "JSON Preview" }) => {
+    // Use either data or jsonData prop, for backward compatibility
+    const dataToRender = data || jsonData || {};
+    
     // Format JSON with indentation for better readability
-    const formattedJson = JSON.stringify(data, null, 2);
+    const formattedJson = JSON.stringify(dataToRender, null, 2);
     
     return (
         <div className="json-preview-container">
diff --git a/src/components/panels/clm/YamlPreview.jsx b/src/components/panels/clm/YamlPreview.jsx
deleted file mode 100644
index bdd354c..0000000
--- a/src/components/panels/clm/YamlPreview.jsx
+++ /dev/null
@@ -1,14 +0,0 @@
-import React from 'react';
-
-const YamlPreview = ({ yamlContent }) => {
-    return (
-        <div>
-            <h3 className="text-lg font-bold">YAML Preview</h3>
-            <pre className="p-3 rounded-lg bg-slate-100 text-sm">
-                {yamlContent}
-            </pre>
-        </div>
-    );
-};
-
-export default YamlPreview;

commit 236491400ce1ac2dddca9e00085d2f16dea623ff
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Mon Mar 31 15:11:16 2025 +0800

    new sw

diff --git a/public/custom-sw.js b/public/custom-sw.js
index a15dc7e..b7bd5a6 100644
--- a/public/custom-sw.js
+++ b/public/custom-sw.js
@@ -1,6 +1,7 @@
 // This is a custom service worker implementation
 
-const CACHE_NAME = 'redux-todo-app-v1';
+const CACHE_NAME = 'redux-todo-app-v2';
+const SW_VERSION = '2'; // Service worker version - increment when making changes
 const urlsToCache = [
   '/',
   '/index.html',
@@ -56,6 +57,85 @@ self.addEventListener('fetch', event => {
     return;
   }
   
+  // Handle API endpoint redirections for removed endpoints
+  const url = new URL(event.request.url);
+  const isApiRequest = url.pathname.startsWith('/api/');
+  
+  // Redirect deprecated API endpoints to the new card-collection endpoint
+  if (isApiRequest) {
+    // Map of old endpoints to new endpoints with appropriate actions
+    const apiRedirectMap = {
+      '/api/store-card': { path: '/api/card-collection', action: 'add' },
+      '/api/update-card': { path: '/api/card-collection', action: 'add' },
+      '/api/get-card': { path: '/api/card-collection', action: 'get' },
+      '/api/store-clm': { path: '/api/card-collection', action: 'add' },
+      '/api/update-clm': { path: '/api/card-collection', action: 'add' },
+      '/api/submit': { path: '/api/card-collection', action: 'add' }
+    };
+    
+    if (apiRedirectMap[url.pathname]) {
+      const newEndpoint = apiRedirectMap[url.pathname];
+      console.log(`[Custom ServiceWorker] Redirecting ${url.pathname} to ${newEndpoint.path} with action=${newEndpoint.action}`);
+      
+      // Create a new request with the redirected URL
+      const redirectedUrl = new URL(newEndpoint.path, self.location.origin);
+      
+      // For GET requests, add action parameter to query string
+      if (event.request.method === 'GET') {
+        redirectedUrl.searchParams.append('action', newEndpoint.action);
+        // Copy any existing query parameters
+        for (const [key, value] of url.searchParams.entries()) {
+          if (key !== 'action') { // Don't duplicate action parameter
+            redirectedUrl.searchParams.append(key, value);
+          }
+        }
+        
+        const redirectedRequest = new Request(redirectedUrl.toString(), {
+          method: event.request.method,
+          headers: event.request.headers,
+          mode: event.request.mode,
+          credentials: event.request.credentials,
+          redirect: event.request.redirect
+        });
+        
+        event.respondWith(fetch(redirectedRequest));
+        return;
+      }
+      
+      // For POST requests, need to modify the request body to include action
+      if (event.request.method === 'POST') {
+        event.respondWith(
+          event.request.clone().json()
+            .then(body => {
+              // Create a new body with the action field
+              const newBody = {
+                ...body,
+                action: newEndpoint.action
+              };
+              
+              // Create a new request with the modified body
+              const redirectedRequest = new Request(redirectedUrl.toString(), {
+                method: event.request.method,
+                headers: event.request.headers,
+                body: JSON.stringify(newBody),
+                mode: event.request.mode,
+                credentials: event.request.credentials,
+                redirect: event.request.redirect
+              });
+              
+              return fetch(redirectedRequest);
+            })
+            .catch(error => {
+              console.error('[Custom ServiceWorker] Error redirecting API request:', error);
+              // If we can't process the body, just pass through to the network
+              return fetch(event.request);
+            })
+        );
+        return;
+      }
+    }
+  }
+  
   event.respondWith(
     caches.match(event.request)
       .then(response => {
@@ -97,6 +177,11 @@ self.addEventListener('message', event => {
     console.log('[Custom ServiceWorker] Skip waiting message received');
     self.skipWaiting();
   }
+  
+  if (event.data && event.data.type === 'VERSION_CHECK') {
+    console.log('[Custom ServiceWorker] Version check message received');
+    event.ports[0].postMessage({ version: SW_VERSION });
+  }
 });
 
 // Push notification event handler
diff --git a/public/data/cards.db-shm b/public/data/cards.db-shm
index 964e9ef..ede3cae 100644
Binary files a/public/data/cards.db-shm and b/public/data/cards.db-shm differ
diff --git a/public/data/cards.db-wal b/public/data/cards.db-wal
index 834a4ba..a78b8b6 100644
Binary files a/public/data/cards.db-wal and b/public/data/cards.db-wal differ
diff --git a/src/components/CardViewer.tsx b/src/components/CardViewer.tsx
index e55bbc0..85cc1bb 100644
--- a/src/components/CardViewer.tsx
+++ b/src/components/CardViewer.tsx
@@ -10,6 +10,8 @@ interface CardData {
 interface CardResponse {
   error?: string;
   serverTimestamp?: string;
+  success?: boolean;
+  card?: CardData;
 }
 
 export const CardViewer: React.FC = () => {
@@ -36,23 +38,32 @@ export const CardViewer: React.FC = () => {
 
     try {
       console.log('Fetching card with hash:', hash);
-      const response = await fetch(`/api/get-card?hash=${encodeURIComponent(hash)}`);
-      const data: CardResponse & CardData = await response.json();
+      const response = await fetch(`/api/card-collection?action=get&hash=${encodeURIComponent(hash)}`);
+      const data: CardResponse = await response.json();
       console.log('Card fetch response:', data);
 
       if (response.ok && !data.error) {
-        setCard(data);
-        setServerTimestamp(data.serverTimestamp || null);
-        
-        // Extract available sections from the content
-        if (data.content) {
-          const sections = Object.keys(data.content);
-          setAvailableSections(sections);
+        // For the new API, the card data is nested under a 'card' property when successful
+        if (data.success && data.card) {
+          setCard(data.card);
+          setServerTimestamp(data.serverTimestamp || null);
           
-          // Set default selected section
-          if (sections.length > 0) {
-            setSelectedSection(sections[0]);
+          // Extract available sections from the content
+          if (data.card.content) {
+            const sections = Object.keys(data.card.content);
+            setAvailableSections(sections);
+            
+            // Select the first section by default if available
+            if (sections.length > 0) {
+              setSelectedSection(sections[0]);
+            }
+          } else {
+            setAvailableSections([]);
+            setSelectedSection(null);
           }
+        } else {
+          // Handle case where API returns success:false but HTTP status is 200
+          setError(data.error || 'Card not found');
         }
       } else {
         setError(data.error || 'Failed to retrieve card');
diff --git a/src/components/CommunicationTest.tsx b/src/components/CommunicationTest.tsx
index aee3403..682364a 100644
--- a/src/components/CommunicationTest.tsx
+++ b/src/components/CommunicationTest.tsx
@@ -60,12 +60,15 @@ export const CommunicationTest: React.FC = () => {
       const stringified = JSON.stringify(simplePayload);
       console.log('Payload JSON string length:', stringified.length);
       
-      const response = await fetch('/api/submit', {
+      const response = await fetch('/api/card-collection', {
         method: 'POST',
         headers: { 
           'Content-Type': 'application/json'
         },
-        body: stringified
+        body: JSON.stringify({
+          action: 'add',
+          card: simplePayload
+        })
       });
 
       console.log('Response status:', response.status);
diff --git a/src/components/panels/CLMInputPanel.jsx b/src/components/panels/CLMInputPanel.jsx
index aed51f6..ba64b06 100644
--- a/src/components/panels/CLMInputPanel.jsx
+++ b/src/components/panels/CLMInputPanel.jsx
@@ -1,5 +1,4 @@
 import React, { useState, useEffect, useCallback } from 'react';
-import DimensionNavigation from './clm/DimensionNavigation';
 import SaveButton from './clm/SaveButton';
 import AbstractSpecification from './clm/AbstractSpecification';
 import ConcreteImplementation from './clm/ConcreteImplementation';
@@ -72,6 +71,16 @@ const CLMInputPanel = () => {
         if (!currentClmHash || !autoSaveEnabled) return;
         
         try {
+            // Create dimension update payload
+            const dimensionUpdate = {
+                parent_hash: currentClmHash,
+                dimension: dimension,
+                type: 'clm_dimension_update',
+                timestamp: new Date().toISOString(),
+                // Include the content directly
+                ...content
+            };
+
             // Use the card-collection API with action=add to update the dimension
             const response = await fetch('/api/card-collection', {
                 method: 'POST',
@@ -81,19 +90,18 @@ const CLMInputPanel = () => {
                 body: JSON.stringify({
                     action: 'add',
                     card: {
-                        parent_hash: currentClmHash,
-                        content: content,
-                        metadata: {
-                            dimension: dimension,
-                            type: 'clm_dimension_update',
-                            timestamp: new Date().toISOString()
-                        }
+                        content: dimensionUpdate
                     }
                 })
             });
 
             if (!response.ok) {
-                console.error('Error auto-updating CLM dimension:', dimension);
+                const errorText = await response.text();
+                console.error('Error auto-updating CLM dimension:', {
+                    dimension,
+                    status: response.status,
+                    error: errorText
+                });
                 return;
             }
 
@@ -224,12 +232,12 @@ const CLMInputPanel = () => {
             // Prepare the root CLM MCard JSON
             const rootClmJson = {
                 title: documentTitle,
-                content: {
-                    dimensions: {
-                        abstract_specification: abstractSpecificationJson,
-                        concrete_implementation: concreteImplementationJson,
-                        balanced_expectations: balancedExpectationsJson
-                    }
+                type: 'clm_document',
+                created_at: new Date().toISOString(),
+                dimensions: {
+                    abstract_specification: abstractSpecificationJson,
+                    concrete_implementation: concreteImplementationJson,
+                    balanced_expectations: balancedExpectationsJson
                 }
             };
 
@@ -242,19 +250,31 @@ const CLMInputPanel = () => {
                 body: JSON.stringify({
                     action: 'add',
                     card: {
-                        content: rootClmJson,
-                        metadata: {
-                            type: 'clm_document',
-                            title: documentTitle,
-                            created_at: new Date().toISOString()
-                        }
+                        content: rootClmJson
                     }
                 })
             });
 
+            // Improved error handling to diagnose issues
             if (!response.ok) {
-                const errorData = await response.json();
-                throw new Error(errorData.error || 'Failed to save CLM data');
+                const errorText = await response.text();
+                console.error('Server response error:', {
+                    status: response.status,
+                    statusText: response.statusText,
+                    responseText: errorText
+                });
+                
+                let errorMessage;
+                try {
+                    // Try to parse the error as JSON
+                    const errorData = JSON.parse(errorText);
+                    errorMessage = errorData.error || 'Failed to save CLM data';
+                } catch (e) {
+                    // If it's not valid JSON (like HTML), provide a more helpful error
+                    errorMessage = `Server error (${response.status}): The API endpoint may not exist or returned HTML instead of JSON`;
+                }
+                
+                throw new Error(errorMessage);
             }
 
             const result = await response.json();
diff --git a/src/components/panels/TopBar.tsx b/src/components/panels/TopBar.tsx
index 79827e6..daa5e73 100644
--- a/src/components/panels/TopBar.tsx
+++ b/src/components/panels/TopBar.tsx
@@ -91,20 +91,22 @@ export const TopBar: React.FC<TopBarProps> = ({ initialTheme: initialPropTheme }
         return;
       }
       
-      console.log('Saving state to backend...', {
-        panelLayout: state.panellayout?.panels ? Object.keys(state.panellayout.panels) : 'none',
+      console.log('Making state snapshot at:', new Date().toISOString(), {
         themeMode: state.theme?.mode || 'unknown',
         todoCount: state.todos?.items?.length || 0
       });
       
       // Actually make the API request
-      console.log('Making POST request to /api/store-card');
-      const response = await fetch('/api/store-card', {
+      console.log('Making POST request to /api/card-collection');
+      const response = await fetch('/api/card-collection', {
         method: 'POST',
         headers: {
           'Content-Type': 'application/json',
         },
-        body: stateJson,
+        body: JSON.stringify({
+          action: 'add',
+          card: JSON.parse(stateJson)
+        }),
       });
       
       if (!response.ok) {
diff --git a/src/layouts/DefaultLayout.astro b/src/layouts/DefaultLayout.astro
index bbc6a02..16c9678 100644
--- a/src/layouts/DefaultLayout.astro
+++ b/src/layouts/DefaultLayout.astro
@@ -48,6 +48,16 @@ const initialTheme = store.getState().theme?.mode || 'light';
 
 <script>
 	import { store } from '../store';
+	import { initServiceWorkerManager } from '../utils/serviceWorkerManager';
+
+	// Initialize service worker manager to handle API endpoint redirection
+	document.addEventListener('DOMContentLoaded', async () => {
+		// Check and update service worker if needed
+		const updated = await initServiceWorkerManager();
+		if (updated) {
+			console.log('Service worker updated. Old API endpoints will now redirect properly.');
+		}
+	});
 
 	// Apply initial theme
 	const initialTheme = store.getState().theme?.mode || 'light';
diff --git a/src/tests/stateCapture.test.js b/src/tests/stateCapture.test.js
index cb633b2..2c0ba44 100644
--- a/src/tests/stateCapture.test.js
+++ b/src/tests/stateCapture.test.js
@@ -188,14 +188,14 @@ async function main() {
     // Enable request capturing for debugging auto-save API calls
     page.on('request', request => {
       const url = request.url();
-      if (url.includes('/api/store-card')) {
+      if (url.includes('/api/card-collection')) {
         console.log(' Detected auto-save request to:', url);
       }
     });
     
     page.on('response', async response => {
       const url = response.url();
-      if (url.includes('/api/store-card')) {
+      if (url.includes('/api/card-collection')) {
         console.log(` Auto-save response: ${response.status()} ${response.statusText()}`);
         try {
           const responseBody = await response.json();
diff --git a/src/utils/serviceWorkerManager.js b/src/utils/serviceWorkerManager.js
new file mode 100644
index 0000000..58e14b1
--- /dev/null
+++ b/src/utils/serviceWorkerManager.js
@@ -0,0 +1,122 @@
+/**
+ * Service Worker Manager
+ * 
+ * Utility functions to manage service worker registration and updates
+ * Helps ensure the service worker is up-to-date with the latest API endpoints
+ */
+
+// Force update any existing service worker
+export async function updateServiceWorker() {
+  if ('serviceWorker' in navigator) {
+    try {
+      // Get all service worker registrations
+      const registrations = await navigator.serviceWorker.getRegistrations();
+      
+      // Unregister all existing service workers
+      for (const registration of registrations) {
+        console.log('[ServiceWorkerManager] Unregistering service worker:', registration.scope);
+        await registration.unregister();
+      }
+      
+      // Register the new service worker
+      const newRegistration = await navigator.serviceWorker.register('/custom-sw.js');
+      console.log('[ServiceWorkerManager] New service worker registered:', newRegistration);
+      
+      return true;
+    } catch (error) {
+      console.error('[ServiceWorkerManager] Error updating service worker:', error);
+      return false;
+    }
+  }
+  return false;
+}
+
+// Check if the service worker needs to be updated by comparing version
+export async function checkServiceWorkerVersion() {
+  if ('serviceWorker' in navigator) {
+    try {
+      // Try to communicate with the service worker to get its version
+      const registration = await navigator.serviceWorker.ready;
+      
+      // If there's no controller, we need to wait for the service worker to activate
+      if (!navigator.serviceWorker.controller) {
+        console.log('[ServiceWorkerManager] No active service worker controller yet');
+        return false;
+      }
+      
+      // Create a promise that will resolve when the service worker responds
+      const versionPromise = new Promise((resolve) => {
+        const messageChannel = new MessageChannel();
+        
+        // Set up the response handler
+        messageChannel.port1.onmessage = (event) => {
+          if (event.data && event.data.type === 'VERSION') {
+            resolve(event.data.version);
+          } else {
+            resolve(null);
+          }
+        };
+        
+        // Send the message
+        navigator.serviceWorker.controller.postMessage({
+          type: 'GET_VERSION'
+        }, [messageChannel.port2]);
+        
+        // Set a timeout in case the service worker doesn't respond
+        setTimeout(() => resolve(null), 1000);
+      });
+      
+      const swVersion = await versionPromise;
+      const currentVersion = '2'; // Update this when changing the service worker
+
+      console.log('[ServiceWorkerManager] Service Worker Version:', swVersion, 'Current Version:', currentVersion);
+      
+      if (swVersion !== currentVersion) {
+        console.log('[ServiceWorkerManager] Service worker needs update');
+        return true;
+      }
+      
+      return false;
+    } catch (error) {
+      console.error('[ServiceWorkerManager] Error checking service worker version:', error);
+      return true; // If we can't check, assume we need to update
+    }
+  }
+  return false;
+}
+
+// Initialize the service worker manager
+export async function initServiceWorkerManager() {
+  const needsUpdate = await checkServiceWorkerVersion();
+  
+  if (needsUpdate) {
+    console.log('[ServiceWorkerManager] Updating service worker...');
+    return updateServiceWorker();
+  }
+  
+  console.log('[ServiceWorkerManager] Service worker is up-to-date');
+  return false;
+}
+
+// Make sure all API requests are using the unified endpoints
+export function checkApiEndpoints() {
+  const deprecatedEndpoints = [
+    '/api/store-card',
+    '/api/update-card',
+    '/api/get-card',
+    '/api/store-clm',
+    '/api/update-clm',
+    '/api/submit'
+  ];
+  
+  // Check for any code still using deprecated endpoints
+  window.addEventListener('fetch', (event) => {
+    const url = new URL(event.request.url);
+    if (deprecatedEndpoints.includes(url.pathname)) {
+      console.warn(
+        `[API Deprecation Warning] Detected use of deprecated API endpoint: ${url.pathname}\n` +
+        `Please update to use the unified Card Collection API: /api/card-collection`
+      );
+    }
+  }, { passive: true });
+}

commit fa9e006cf29d5fb397458b6100a3fb120b78cca6
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Mon Mar 31 14:52:38 2025 +0800

    api removal

diff --git a/src/pages/api/get-card.ts b/src/pages/api/get-card.ts
deleted file mode 100644
index be4969b..0000000
--- a/src/pages/api/get-card.ts
+++ /dev/null
@@ -1,72 +0,0 @@
-import type { APIRoute } from 'astro';
-import { getCardByHash } from '../../utils/storeAdapter';
-
-/**
- * API endpoint to retrieve a card by its hash
- */
-export const GET: APIRoute = async ({ request }) => {
-  console.log('GET /api/get-card called');
-  
-  // Parse the URL to get the query parameters
-  const url = new URL(request.url);
-  const hash = url.searchParams.get('hash');
-
-  // Validate hash parameter
-  if (!hash) {
-    console.error('Missing required hash parameter');
-    return new Response(
-      JSON.stringify({ 
-        error: 'Missing required hash parameter' 
-      }),
-      { 
-        status: 400, 
-        headers: { 'Content-Type': 'application/json' } 
-      }
-    );
-  }
-
-  try {
-    console.log('Retrieving card with hash:', hash);
-    const card = getCardByHash(hash);
-    
-    if (!card) {
-      console.log('Card not found for hash:', hash);
-      return new Response(
-        JSON.stringify({ 
-          error: 'Card not found' 
-        }),
-        { 
-          status: 404, 
-          headers: { 'Content-Type': 'application/json' } 
-        }
-      );
-    }
-
-    // Add server timestamp
-    const responseData = {
-      ...card,
-      serverTimestamp: new Date().toISOString(),
-    };
-
-    console.log('Card retrieved successfully');
-    return new Response(
-      JSON.stringify(responseData),
-      { 
-        status: 200, 
-        headers: { 'Content-Type': 'application/json' } 
-      }
-    );
-  } catch (error) {
-    console.error('Error retrieving card:', error);
-    return new Response(
-      JSON.stringify({ 
-        error: 'Failed to retrieve card', 
-        details: error instanceof Error ? error.message : String(error)
-      }),
-      { 
-        status: 500, 
-        headers: { 'Content-Type': 'application/json' } 
-      }
-    );
-  }
-};
diff --git a/src/pages/api/store-card.ts b/src/pages/api/store-card.ts
deleted file mode 100644
index fadb11a..0000000
--- a/src/pages/api/store-card.ts
+++ /dev/null
@@ -1,65 +0,0 @@
-import type { APIRoute } from 'astro';
-import { storeData, getCardByHash } from '../../utils/storeAdapter';
-
-/**
- * API endpoint to store Redux state as a card
- */
-export const POST: APIRoute = async ({ request }) => {
-  console.log('POST /api/store-card called');
-  
-  try {
-    // Get the request body
-    const data = await request.json();
-    console.log('Received data to store:', Object.keys(data || {}));
-    
-    // Add timestamp to the data
-    const stateTimestamp = new Date().toISOString();
-    const dataWithTimestamp = {
-      ...data,
-      __stateTimestamp: stateTimestamp
-    };
-    
-    // Store the data and get the hash
-    const hash = storeData(dataWithTimestamp);
-    console.log('Data stored successfully with hash:', hash);
-    
-    // Get the stored card to include in response
-    const storedCard = getCardByHash(hash);
-    
-    // Return success response
-    return new Response(
-      JSON.stringify({ 
-        success: true, 
-        hash,
-        stateTimestamp,
-        timestamp: new Date().toISOString(),
-        cardData: {
-          hash: storedCard?.hash,
-          contentType: typeof storedCard?.content,
-          createdAt: storedCard?.timestamp,
-          stateTimestamp: storedCard?.content?.__stateTimestamp,
-          size: typeof storedCard?.content === 'string' 
-            ? storedCard.content.length 
-            : JSON.stringify(storedCard?.content).length
-        }
-      }),
-      { 
-        status: 200, 
-        headers: { 'Content-Type': 'application/json' } 
-      }
-    );
-  } catch (error) {
-    console.error('Error storing data:', error);
-    return new Response(
-      JSON.stringify({ 
-        error: 'Failed to store data', 
-        details: error instanceof Error ? error.message : String(error),
-        timestamp: new Date().toISOString()
-      }),
-      { 
-        status: 500, 
-        headers: { 'Content-Type': 'application/json' } 
-      }
-    );
-  }
-};
diff --git a/src/pages/api/submit.ts b/src/pages/api/submit.ts
deleted file mode 100644
index 92b09c4..0000000
--- a/src/pages/api/submit.ts
+++ /dev/null
@@ -1,87 +0,0 @@
-import type { APIRoute } from 'astro';
-import { storeData } from '../../utils/storeAdapter.js';
-
-export const POST: APIRoute = async ({ request }) => {
-  console.log('API: Submit endpoint hit');
-  
-  try {
-    // Get request body as text
-    const bodyText = await request.text();
-    console.log('API: Request body length:', bodyText.length);
-    
-    // If we have data, try to parse it as JSON
-    if (bodyText && bodyText.trim()) {
-      try {
-        // Parse JSON
-        const jsonData = JSON.parse(bodyText);
-        console.log('API: Successfully parsed JSON with keys:', Object.keys(jsonData));
-        
-        // Store in database
-        const hash = storeData(jsonData);
-        console.log('API: Successfully stored data with hash:', hash);
-        
-        // Return success response
-        return new Response(
-          JSON.stringify({
-            success: true,
-            message: 'Data stored successfully',
-            hash: hash
-          }),
-          {
-            status: 200,
-            headers: {
-              'Content-Type': 'application/json'
-            }
-          }
-        );
-      } catch (error) {
-        console.error('API: Error parsing JSON:', error);
-        return new Response(
-          JSON.stringify({
-            success: false,
-            error: 'Invalid JSON data',
-            message: 'Could not parse request body as JSON'
-          }),
-          {
-            status: 400,
-            headers: {
-              'Content-Type': 'application/json'
-            }
-          }
-        );
-      }
-    } else {
-      // No data provided
-      console.log('API: No data provided in request body');
-      return new Response(
-        JSON.stringify({
-          success: false,
-          error: 'No data provided',
-          message: 'Request body is empty'
-        }),
-        {
-          status: 400,
-          headers: {
-            'Content-Type': 'application/json'
-          }
-        }
-      );
-    }
-  } catch (error) {
-    // Server error
-    console.error('API: Unexpected error:', error);
-    return new Response(
-      JSON.stringify({
-        success: false,
-        error: 'Server error',
-        message: error instanceof Error ? error.message : 'Unknown error'
-      }),
-      {
-        status: 500,
-        headers: {
-          'Content-Type': 'application/json'
-        }
-      }
-    );
-  }
-};
\ No newline at end of file
diff --git a/src/pages/api/update-card.ts b/src/pages/api/update-card.ts
deleted file mode 100644
index c876b3f..0000000
--- a/src/pages/api/update-card.ts
+++ /dev/null
@@ -1,101 +0,0 @@
-import type { APIRoute } from 'astro';
-import { SQLiteEngine } from '../../engine/sqlite_engine.js';
-import { CardCollection } from '../../content/model/card-collection.js';
-import { getCardByHash } from '../../utils/storeAdapter';
-
-/**
- * API endpoint to update a card's content by hash
- */
-export const POST: APIRoute = async ({ request }) => {
-  console.log('POST /api/update-card called');
-  
-  try {
-    // Get the request body
-    const data = await request.json();
-    console.log('Received update request:', { hash: data.hash, contentType: typeof data.content });
-    
-    // Validate request data
-    if (!data.hash || data.content === undefined) {
-      return new Response(
-        JSON.stringify({ 
-          error: 'Invalid request. Hash and content are required.', 
-          timestamp: new Date().toISOString() 
-        }),
-        { 
-          status: 400, 
-          headers: { 'Content-Type': 'application/json' } 
-        }
-      );
-    }
-    
-    // Add updated timestamp to the content (if it's an object)
-    let updatedContent = data.content;
-    if (typeof updatedContent === 'object' && updatedContent !== null) {
-      updatedContent = {
-        ...updatedContent,
-        __stateTimestamp: new Date().toISOString()
-      };
-    }
-    
-    // Initialize database connection and card collection
-    const engine = new SQLiteEngine();
-    const cardCollection = new CardCollection(engine);
-    
-    // Check if the card exists
-    const existingCard = cardCollection.get(data.hash);
-    if (!existingCard) {
-      return new Response(
-        JSON.stringify({ 
-          error: 'Card not found', 
-          timestamp: new Date().toISOString() 
-        }),
-        { 
-          status: 404, 
-          headers: { 'Content-Type': 'application/json' } 
-        }
-      );
-    }
-    
-    // Update the card
-    const success = cardCollection.update(data.hash, updatedContent);
-    
-    if (!success) {
-      throw new Error('Failed to update card in database');
-    }
-    
-    // Get the updated card
-    const updatedCard = getCardByHash(data.hash);
-    
-    // Return success response
-    return new Response(
-      JSON.stringify({ 
-        success: true, 
-        hash: data.hash,
-        updatedAt: new Date().toISOString(),
-        cardData: {
-          hash: updatedCard?.hash,
-          contentType: typeof updatedCard?.content,
-          updatedAt: new Date().toISOString(),
-          content: updatedCard?.content
-        }
-      }),
-      { 
-        status: 200, 
-        headers: { 'Content-Type': 'application/json' } 
-      }
-    );
-  } catch (error) {
-    console.error('Error updating card:', error);
-    return new Response(
-      JSON.stringify({ 
-        error: 'Failed to update card', 
-        details: error instanceof Error ? error.message : String(error),
-        timestamp: new Date().toISOString()
-      }),
-      { 
-        status: 500, 
-        headers: { 'Content-Type': 'application/json' } 
-      }
-    );
-  }
-};

commit 93bd48a1045f5d0cf142fe0d597abee673578ac4
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Mon Mar 31 14:34:04 2025 +0800

    new api endpoints

diff --git a/public/data/cards.db-wal b/public/data/cards.db-wal
index f65450c..834a4ba 100644
Binary files a/public/data/cards.db-wal and b/public/data/cards.db-wal differ
diff --git a/src/components/panels/CLMInputPanel.jsx b/src/components/panels/CLMInputPanel.jsx
index 6d13b42..aed51f6 100644
--- a/src/components/panels/CLMInputPanel.jsx
+++ b/src/components/panels/CLMInputPanel.jsx
@@ -72,15 +72,23 @@ const CLMInputPanel = () => {
         if (!currentClmHash || !autoSaveEnabled) return;
         
         try {
-            const response = await fetch('/api/update-clm', {
+            // Use the card-collection API with action=add to update the dimension
+            const response = await fetch('/api/card-collection', {
                 method: 'POST',
                 headers: {
                     'Content-Type': 'application/json'
                 },
                 body: JSON.stringify({
-                    clmHash: currentClmHash,
-                    dimension,
-                    content
+                    action: 'add',
+                    card: {
+                        parent_hash: currentClmHash,
+                        content: content,
+                        metadata: {
+                            dimension: dimension,
+                            type: 'clm_dimension_update',
+                            timestamp: new Date().toISOString()
+                        }
+                    }
                 })
             });
 
@@ -90,9 +98,13 @@ const CLMInputPanel = () => {
             }
 
             const result = await response.json();
-            setCurrentClmHash(result.newClmHash);
-            setLastUpdated(new Date().toISOString());
-            console.log(`${dimension} auto-updated successfully with hash: ${result.dimensionHash.substring(0, 10)}...`);
+            if (result.success) {
+                setCurrentClmHash(result.hash);
+                setLastUpdated(new Date().toISOString());
+                console.log(`${dimension} auto-updated successfully with hash: ${result.hash.substring(0, 10)}...`);
+            } else {
+                console.error('Failed to auto-update:', result.error);
+            }
         } catch (error) {
             console.error('Error in auto-update:', error);
         }
@@ -221,15 +233,22 @@ const CLMInputPanel = () => {
                 }
             };
 
-            // Store in database using the new store-clm endpoint
-            const response = await fetch('/api/store-clm', {
+            // Store in database using the card-collection API endpoint
+            const response = await fetch('/api/card-collection', {
                 method: 'POST',
                 headers: {
                     'Content-Type': 'application/json'
                 },
                 body: JSON.stringify({
-                    title: documentTitle,
-                    content: rootClmJson
+                    action: 'add',
+                    card: {
+                        content: rootClmJson,
+                        metadata: {
+                            type: 'clm_document',
+                            title: documentTitle,
+                            created_at: new Date().toISOString()
+                        }
+                    }
                 })
             });
 
@@ -239,14 +258,19 @@ const CLMInputPanel = () => {
             }
 
             const result = await response.json();
-            // Store the CLM hash for future updates
-            setCurrentClmHash(result.clmHash);
-            setLastUpdated(new Date().toISOString());
             
-            setSaveMessage({ 
-                type: 'success', 
-                text: `CLM data saved successfully! Hash: ${result.clmHash.substring(0, 10)}...` 
-            });
+            if (result.success) {
+                // Store the CLM hash for future updates
+                setCurrentClmHash(result.hash);
+                setLastUpdated(new Date().toISOString());
+                
+                setSaveMessage({ 
+                    type: 'success', 
+                    text: `CLM data saved successfully! Hash: ${result.hash.substring(0, 10)}...` 
+                });
+            } else {
+                throw new Error(result.error || 'Failed to save CLM data');
+            }
             
         } catch (error) {
             console.error('Error saving CLM data:', error);
diff --git a/src/components/panels/DatabaseRetrievePanel.tsx b/src/components/panels/DatabaseRetrievePanel.tsx
index ea298eb..abb1c33 100644
--- a/src/components/panels/DatabaseRetrievePanel.tsx
+++ b/src/components/panels/DatabaseRetrievePanel.tsx
@@ -36,12 +36,56 @@ export const DatabaseRetrievePanel: React.FC = () => {
   const [hashValue, setHashValue] = useState('');
   const [selectedCardHash, setSelectedCardHash] = useState<string | null>(null);
 
-  // Function to fetch cards
+  // Function to fetch card by hash
+  const fetchCardByHash = async (hash: string) => {
+    try {
+      setLoading(true);
+      setError(null);
+
+      // Make the API request using the card-collection GET endpoint
+      const response = await fetch(`/api/card-collection?action=get&hash=${hash}`);
+
+      if (!response.ok) {
+        const errorData = await response.json();
+        throw new Error(errorData.error || 'Failed to fetch card');
+      }
+
+      const data = await response.json();
+      
+      if (data.success && data.card) {
+        // Format the response to match PageData interface
+        setCards({
+          items: [data.card],
+          total_items: 1,
+          page_number: 1,
+          page_size: 1,
+          has_next: false,
+          has_previous: false,
+          total_pages: 1,
+          next_page: null,
+          previous_page: null,
+          retrievalMethod: 'hash'
+        });
+        
+        // Clear selected card when fetching new cards
+        setSelectedCardHash(null);
+      } else {
+        throw new Error(data.error || 'Card not found');
+      }
+    } catch (err) {
+      setError(err instanceof Error ? err.message : 'An unknown error occurred');
+      console.error('Error fetching card by hash:', err);
+      setCards(null);
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  // Function to fetch cards (page or search)
   const fetchCards = async (params: {
     page?: number;
     pageSize?: number;
     search?: string;
-    hash?: string;
   }) => {
     try {
       setLoading(true);
@@ -49,12 +93,12 @@ export const DatabaseRetrievePanel: React.FC = () => {
 
       // Build the query parameters
       const queryParams = new URLSearchParams();
+      // Using the existing /api/retrieve endpoint for pagination and search
       if (params.page) queryParams.append('page', params.page.toString());
       if (params.pageSize) queryParams.append('pageSize', params.pageSize.toString());
       if (params.search) queryParams.append('search', params.search);
-      if (params.hash) queryParams.append('hash', params.hash);
 
-      // Make the API request
+      // Make the API request to the original retrieve endpoint
       const response = await fetch(`/api/retrieve?${queryParams.toString()}`);
 
       if (!response.ok) {
@@ -63,6 +107,8 @@ export const DatabaseRetrievePanel: React.FC = () => {
       }
 
       const data = await response.json();
+      
+      // The retrieve endpoint returns PageData directly
       setCards(data);
       
       // Clear selected card when fetching new cards
@@ -70,6 +116,7 @@ export const DatabaseRetrievePanel: React.FC = () => {
     } catch (err) {
       setError(err instanceof Error ? err.message : 'An unknown error occurred');
       console.error('Error fetching cards:', err);
+      setCards(null);
     } finally {
       setLoading(false);
     }
@@ -93,7 +140,7 @@ export const DatabaseRetrievePanel: React.FC = () => {
   const handleHashLookup = (e: React.FormEvent) => {
     e.preventDefault();
     if (hashValue) {
-      fetchCards({ hash: hashValue });
+      fetchCardByHash(hashValue);
     }
   };
 
diff --git a/src/pages/api/store-clm.ts b/src/pages/api/store-clm.ts
deleted file mode 100644
index aead3b7..0000000
--- a/src/pages/api/store-clm.ts
+++ /dev/null
@@ -1,139 +0,0 @@
-import type { APIRoute } from 'astro';
-import { MCard } from '../../content/model/mcard.js';
-import { SQLiteEngine } from '../../engine/sqlite_engine.js';
-import { CardCollection } from '../../content/model/card-collection.js';
-import { storeData, getCardByHash, getStoreEngine } from '../../utils/storeAdapter';
-import { encodeText } from '../../utils/textEncoderPolyfill.js';
-
-// Define types for the CLM dimensions
-type CLMDimension = 'abstractSpecification' | 'concreteImplementation' | 'balancedExpectations';
-type DimensionContent = Record<CLMDimension, string>;
-type DimensionHashes = Record<CLMDimension, string | null>;
-type CLMContent = {
-  title: string;
-  created: string;
-  dimensions: {
-    abstract_specification: any;
-    concrete_implementation: any;
-    balanced_expectations: any;
-  };
-};
-
-/**
- * API endpoint to store CLM data as a MCard
- */
-export const POST: APIRoute = async ({ request }) => {
-  console.log('POST /api/store-clm called');
-  
-  try {
-    // Get the request body
-    const data = await request.json();
-    console.log('Received CLM data to store:', { 
-      title: data.title, 
-      format: data.format,
-      contentKeys: data.content ? Object.keys(data.content) : 'No content',
-      dimensionKeys: data.content?.dimensions ? Object.keys(data.content.dimensions) : 'No dimensions'
-    });
-    
-    // Validate required fields with more detailed checks
-    if (!data.title) {
-      return new Response(
-        JSON.stringify({ 
-          error: 'Invalid request. Title is required.', 
-          timestamp: new Date().toISOString() 
-        }),
-        { 
-          status: 400, 
-          headers: { 'Content-Type': 'application/json' } 
-        }
-      );
-    }
-
-    if (!data.content || !data.content.dimensions) {
-      return new Response(
-        JSON.stringify({ 
-          error: 'Invalid request. Content and dimensions are required.', 
-          details: {
-            contentExists: !!data.content,
-            dimensionsExists: !!data.content?.dimensions
-          },
-          timestamp: new Date().toISOString() 
-        }),
-        { 
-          status: 400, 
-          headers: { 'Content-Type': 'application/json' } 
-        }
-      );
-    }
-    
-    // Initialize database connection and card collection
-    const engine = getStoreEngine();
-    const cardCollection = new CardCollection(engine);
-    
-    // Extract the dimensions from the content
-    const dimensionContent = data.content.dimensions;
-    
-    // Store the dimension cards
-    const dimensionHashes: DimensionHashes = {
-      abstractSpecification: null,
-      concreteImplementation: null,
-      balancedExpectations: null
-    };
-    
-    // Create and store individual dimension cards
-    if (dimensionContent.abstract_specification) {
-      const abstractCard = new MCard(dimensionContent.abstract_specification);
-      dimensionHashes.abstractSpecification = cardCollection.add(abstractCard);
-      console.log('Abstract Specification dimension card stored with hash:', dimensionHashes.abstractSpecification);
-    }
-    
-    if (dimensionContent.concrete_implementation) {
-      const concreteCard = new MCard(dimensionContent.concrete_implementation);
-      dimensionHashes.concreteImplementation = cardCollection.add(concreteCard);
-      console.log('Concrete Implementation dimension card stored with hash:', dimensionHashes.concreteImplementation);
-    }
-    
-    if (dimensionContent.balanced_expectations) {
-      const balancedCard = new MCard(dimensionContent.balanced_expectations);
-      dimensionHashes.balancedExpectations = cardCollection.add(balancedCard);
-      console.log('Balanced Expectations dimension card stored with hash:', dimensionHashes.balancedExpectations);
-    }
-    
-    // Create the metadata card to represent the entire CLM structure
-    // Simplified metadata with only essential fields
-    const metadataCard = new MCard({
-      title: data.title,
-      dimensions: dimensionHashes
-    });
-    
-    const metadataHash = cardCollection.add(metadataCard);
-    console.log('CLM metadata card stored with hash:', metadataHash);
-    
-    // Return success response
-    return new Response(
-      JSON.stringify({ 
-        success: true, 
-        clmHash: metadataHash,
-        dimensionHashes,
-        title: data.title
-      }),
-      { 
-        status: 200, 
-        headers: { 'Content-Type': 'application/json' } 
-      }
-    );
-  } catch (error) {
-    console.error('Error storing CLM data:', error);
-    return new Response(
-      JSON.stringify({ 
-        error: 'Failed to store CLM data', 
-        details: error instanceof Error ? error.message : String(error),
-        timestamp: new Date().toISOString()
-      }),
-      { 
-        status: 500, 
-        headers: { 'Content-Type': 'application/json' } 
-      }
-    );
-  }
-};
diff --git a/src/pages/api/update-clm.ts b/src/pages/api/update-clm.ts
deleted file mode 100644
index 81b7ebe..0000000
--- a/src/pages/api/update-clm.ts
+++ /dev/null
@@ -1,139 +0,0 @@
-import type { APIRoute } from 'astro';
-import { SQLiteEngine } from '../../engine/sqlite_engine.js';
-import { CardCollection } from '../../content/model/card-collection.js';
-import { getCardByHash, getStoreEngine } from '../../utils/storeAdapter';
-import { MCard } from '../../content/model/mcard.js';
-
-// Define types for the CLM dimensions
-type CLMDimension = 'abstractSpecification' | 'concreteImplementation' | 'balancedExpectations';
-type DimensionHashes = Record<CLMDimension, string | null>;
-
-// Map between JSON dimension keys and CLM dimension names
-const dimensionMappings = {
-  'abstractSpecification': 'abstract_specification',
-  'concreteImplementation': 'concrete_implementation',
-  'balancedExpectations': 'balanced_expectations'
-};
-
-/**
- * API endpoint to update a CLM dimension by hash
- */
-export const POST: APIRoute = async ({ request }) => {
-  console.log('POST /api/update-clm called');
-  
-  try {
-    // Get the request body
-    const data = await request.json();
-    console.log('Received update request:', { 
-      clmHash: data.clmHash, 
-      dimension: data.dimension, 
-      contentType: typeof data.content 
-    });
-    
-    // Validate request data
-    if (!data.clmHash || !data.dimension || data.content === undefined) {
-      return new Response(
-        JSON.stringify({ 
-          error: 'Invalid request. CLM hash, dimension, and content are required.', 
-          timestamp: new Date().toISOString() 
-        }),
-        { 
-          status: 400, 
-          headers: { 'Content-Type': 'application/json' } 
-        }
-      );
-    }
-    
-    // Add updated timestamp to the content
-    const updatedTimestamp = new Date().toISOString();
-    
-    // Initialize database connection and card collection
-    const engine = getStoreEngine();
-    const cardCollection = new CardCollection(engine);
-    
-    // Check if the CLM metadata card exists
-    const clmMetadataCard = getCardByHash(data.clmHash);
-    if (!clmMetadataCard) {
-      return new Response(
-        JSON.stringify({ 
-          error: 'CLM metadata card not found', 
-          timestamp: updatedTimestamp
-        }),
-        { 
-          status: 404, 
-          headers: { 'Content-Type': 'application/json' } 
-        }
-      );
-    }
-    
-    // Get the content of the CLM metadata card
-    const clmMetadata = clmMetadataCard.content;
-    
-    // Validate dimension name
-    const dimension = data.dimension as CLMDimension;
-    if (!(dimension in dimensionMappings)) {
-      return new Response(
-        JSON.stringify({ 
-          error: `Invalid dimension: ${data.dimension}`, 
-          timestamp: updatedTimestamp
-        }),
-        { 
-          status: 400, 
-          headers: { 'Content-Type': 'application/json' } 
-        }
-      );
-    }
-    
-    // Create a new dimension card with updated content
-    // The content should be a JSON object
-    const updatedDimensionCard = new MCard(data.content);
-    const dimensionHash = cardCollection.add(updatedDimensionCard);
-    console.log(`Updated ${data.dimension} dimension card with hash:`, dimensionHash);
-    
-    // Update the CLM metadata card with the new dimension hash
-    const updatedDimensionHashes = { ...clmMetadata.dimensions };
-    
-    // Update the specific dimension hash
-    updatedDimensionHashes[dimension] = dimensionHash;
-    
-    // Create an updated metadata card
-    const updatedMetadata = {
-      ...clmMetadata,
-      dimensions: updatedDimensionHashes
-    };
-    
-    // Store the updated metadata card
-    const updatedMetadataCard = new MCard(updatedMetadata);
-    const updatedMetadataHash = cardCollection.add(updatedMetadataCard);
-    console.log('Updated CLM metadata card with hash:', updatedMetadataHash);
-    
-    // Return success response
-    return new Response(
-      JSON.stringify({ 
-        success: true, 
-        originalClmHash: data.clmHash,
-        newClmHash: updatedMetadataHash,
-        dimension: data.dimension,
-        dimensionHash: dimensionHash,
-        timestamp: updatedTimestamp
-      }),
-      { 
-        status: 200, 
-        headers: { 'Content-Type': 'application/json' } 
-      }
-    );
-  } catch (error) {
-    console.error('Error updating CLM dimension:', error);
-    return new Response(
-      JSON.stringify({ 
-        error: 'Failed to update CLM dimension', 
-        details: error instanceof Error ? error.message : String(error),
-        timestamp: new Date().toISOString()
-      }),
-      { 
-        status: 500, 
-        headers: { 'Content-Type': 'application/json' } 
-      }
-    );
-  }
-};

commit edd5ef15268fe036a2d902ed61dedd872c9f04fd
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Mon Mar 31 12:52:11 2025 +0800

    new test

diff --git a/src/tests/api/card-collection/add.test.js b/src/tests/api/card-collection/add.test.js
new file mode 100644
index 0000000..04b6974
--- /dev/null
+++ b/src/tests/api/card-collection/add.test.js
@@ -0,0 +1,152 @@
+/**
+ * Tests for CardCollection Add API endpoint
+ */
+import { describe, expect, it, vi, beforeEach, afterEach } from 'vitest';
+import { MCard } from '../../../content/model/mcard.js';
+import { CardCollection } from '../../../content/model/card-collection.js';
+
+// Mock dependencies
+vi.mock('../../../utils/storeAdapter.js', () => {
+  return {
+    getStoreEngine: vi.fn().mockImplementation(() => {
+      return {
+        add: vi.fn().mockReturnValue(true),
+        get: vi.fn(),
+        delete: vi.fn().mockReturnValue(true),
+      };
+    })
+  };
+});
+
+vi.mock('../../../services/logger.js', () => {
+  return {
+    default: {
+      debug: vi.fn(),
+      error: vi.fn()
+    }
+  };
+});
+
+// Helper function to create a mock Response constructor
+global.Response = class Response {
+  constructor(body, options) {
+    this.body = body;
+    this.status = options?.status || 200;
+    this.headers = options?.headers || {};
+  }
+};
+
+// Import the API handler after mocks are set up
+import { POST } from '../../../pages/api/card-collection/add.ts';
+
+describe('CardCollection Add API Endpoint', () => {
+  let mockCardCollection;
+  let testCard;
+  let testCardHash;
+  
+  beforeEach(() => {
+    // Create a test card
+    testCard = new MCard({ test: 'Sample content' });
+    testCardHash = 'test-hash-123';
+    testCard.hash = testCardHash;
+    
+    // Mock card collection methods
+    mockCardCollection = {
+      add: vi.fn().mockReturnValue(testCardHash)
+    };
+    
+    // Mock CardCollection constructor
+    vi.spyOn(CardCollection.prototype, 'add').mockImplementation(() => testCardHash);
+  });
+  
+  afterEach(() => {
+    vi.resetAllMocks();
+  });
+  
+  it('should add a card successfully', async () => {
+    // Create request
+    const request = {
+      json: vi.fn().mockResolvedValue({
+        card: {
+          content: { test: 'Sample content' }
+        }
+      })
+    };
+    
+    // Call API handler
+    const response = await POST({ request });
+    
+    // Parse response body
+    const responseBody = JSON.parse(response.body);
+    
+    // Assertions
+    expect(response.status).toBe(200);
+    expect(responseBody.success).toBe(true);
+    expect(responseBody.hash).toBe(testCardHash);
+    expect(responseBody.timestamp).toBeDefined();
+  });
+  
+  it('should return error if card data is missing', async () => {
+    // Create request without card data
+    const request = {
+      json: vi.fn().mockResolvedValue({})
+    };
+    
+    // Call API handler
+    const response = await POST({ request });
+    
+    // Parse response body
+    const responseBody = JSON.parse(response.body);
+    
+    // Assertions
+    expect(response.status).toBe(400);
+    expect(responseBody.success).toBe(false);
+    expect(responseBody.error).toBe('Card data is required');
+  });
+  
+  it('should return error if content is missing', async () => {
+    // Create request with empty content
+    const request = {
+      json: vi.fn().mockResolvedValue({
+        card: {}
+      })
+    };
+    
+    // Call API handler
+    const response = await POST({ request });
+    
+    // Parse response body
+    const responseBody = JSON.parse(response.body);
+    
+    // Assertions
+    expect(response.status).toBe(400);
+    expect(responseBody.success).toBe(false);
+    expect(responseBody.error).toBe('Card content is required');
+  });
+  
+  it('should handle exceptions during card creation', async () => {
+    // Mock error in card creation
+    vi.spyOn(MCard.prototype, 'constructor').mockImplementation(() => {
+      throw new Error('Test error in card creation');
+    });
+    
+    // Create request
+    const request = {
+      json: vi.fn().mockResolvedValue({
+        card: {
+          content: { test: 'Sample content' }
+        }
+      })
+    };
+    
+    // Call API handler (should catch the error)
+    const response = await POST({ request });
+    
+    // Parse response body
+    const responseBody = JSON.parse(response.body);
+    
+    // Assertions
+    expect(responseBody.success).toBe(false);
+    expect(responseBody.error).toBeDefined();
+  });
+});
diff --git a/src/tests/api/card-collection/delete.test.js b/src/tests/api/card-collection/delete.test.js
new file mode 100644
index 0000000..7fc0e93
--- /dev/null
+++ b/src/tests/api/card-collection/delete.test.js
@@ -0,0 +1,198 @@
+/**
+ * Tests for CardCollection Delete API endpoint
+ */
+import { describe, expect, it, vi, beforeEach, afterEach } from 'vitest';
+import { MCard } from '../../../content/model/mcard.js';
+import { CardCollection } from '../../../content/model/card-collection.js';
+
+// Mock dependencies
+vi.mock('../../../utils/storeAdapter.js', () => {
+  return {
+    getStoreEngine: vi.fn().mockImplementation(() => {
+      return {
+        add: vi.fn().mockReturnValue(true),
+        get: vi.fn(),
+        delete: vi.fn().mockReturnValue(true),
+      };
+    })
+  };
+});
+
+vi.mock('../../../services/logger.js', () => {
+  return {
+    default: {
+      debug: vi.fn(),
+      error: vi.fn()
+    }
+  };
+});
+
+// Helper function to create a mock Response constructor
+global.Response = class Response {
+  constructor(body, options) {
+    this.body = body;
+    this.status = options?.status || 200;
+    this.headers = options?.headers || {};
+  }
+};
+
+// Helper function to create a mock URL constructor
+global.URL = class URL {
+  constructor(url) {
+    this.url = url;
+    this.searchParams = new Map();
+  }
+  
+  static createMockURL(params) {
+    const url = new URL('http://localhost');
+    for (const [key, value] of Object.entries(params)) {
+      url.searchParams.set(key, value);
+    }
+    return url;
+  }
+};
+
+// Import the API handler after mocks are set up
+import { DELETE } from '../../../pages/api/card-collection/delete.ts';
+
+describe('CardCollection Delete API Endpoint', () => {
+  let testCard;
+  let testCardHash;
+  
+  beforeEach(() => {
+    // Create a test card
+    testCard = new MCard({ test: 'Sample content' });
+    testCardHash = 'test-hash-123';
+    testCard.hash = testCardHash;
+    
+    // Mock card collection methods
+    vi.spyOn(CardCollection.prototype, 'get').mockImplementation((hash) => 
+      hash === testCardHash ? testCard : null
+    );
+    
+    vi.spyOn(CardCollection.prototype, 'delete').mockImplementation((hash) => 
+      hash === testCardHash ? true : false
+    );
+  });
+  
+  afterEach(() => {
+    vi.resetAllMocks();
+  });
+  
+  it('should delete a card by hash', async () => {
+    // Mock URL with parameters
+    const request = {
+      url: 'http://localhost/api/card-collection/delete',
+    };
+    request.url = new URL(request.url);
+    request.url.searchParams = new Map([
+      ['hash', testCardHash]
+    ]);
+    
+    // Call API handler
+    const response = await DELETE({ request });
+    
+    // Parse response body
+    const responseBody = JSON.parse(response.body);
+    
+    // Assertions
+    expect(response.status).toBe(200);
+    expect(responseBody.success).toBe(true);
+    expect(responseBody.timestamp).toBeDefined();
+  });
+  
+  it('should return 404 if card to delete does not exist', async () => {
+    // Mock URL with parameters for non-existent hash
+    const request = {
+      url: 'http://localhost/api/card-collection/delete',
+    };
+    request.url = new URL(request.url);
+    request.url.searchParams = new Map([
+      ['hash', 'non-existent-hash']
+    ]);
+    
+    // Call API handler
+    const response = await DELETE({ request });
+    
+    // Parse response body
+    const responseBody = JSON.parse(response.body);
+    
+    // Assertions
+    expect(response.status).toBe(404);
+    expect(responseBody.success).toBe(false);
+    expect(responseBody.error).toBe('Card not found');
+  });
+  
+  it('should validate hash parameter is provided', async () => {
+    // Mock URL with missing hash
+    const request = {
+      url: 'http://localhost/api/card-collection/delete',
+    };
+    request.url = new URL(request.url);
+    request.url.searchParams = new Map();
+    
+    // Call API handler
+    const response = await DELETE({ request });
+    
+    // Parse response body
+    const responseBody = JSON.parse(response.body);
+    
+    // Assertions
+    expect(response.status).toBe(400);
+    expect(responseBody.success).toBe(false);
+    expect(responseBody.error).toBe('Hash parameter is required');
+  });
+  
+  it('should handle failure to delete', async () => {
+    // Mock delete failure
+    vi.spyOn(CardCollection.prototype, 'delete').mockReturnValue(false);
+    
+    // Mock URL with parameters
+    const request = {
+      url: 'http://localhost/api/card-collection/delete',
+    };
+    request.url = new URL(request.url);
+    request.url.searchParams = new Map([
+      ['hash', testCardHash]
+    ]);
+    
+    // Call API handler
+    const response = await DELETE({ request });
+    
+    // Parse response body
+    const responseBody = JSON.parse(response.body);
+    
+    // Assertions
+    expect(response.status).toBe(500);
+    expect(responseBody.success).toBe(false);
+    expect(responseBody.error).toBe('Failed to delete card');
+  });
+  
+  it('should handle server errors gracefully', async () => {
+    // Mock an error in the delete method
+    vi.spyOn(CardCollection.prototype, 'delete').mockImplementation(() => {
+      throw new Error('Test server error');
+    });
+    
+    // Mock URL with parameters
+    const request = {
+      url: 'http://localhost/api/card-collection/delete',
+    };
+    request.url = new URL(request.url);
+    request.url.searchParams = new Map([
+      ['hash', testCardHash]
+    ]);
+    
+    // Call API handler
+    const response = await DELETE({ request });
+    
+    // Parse response body
+    const responseBody = JSON.parse(response.body);
+    
+    // Assertions
+    expect(response.status).toBe(500);
+    expect(responseBody.success).toBe(false);
+    expect(responseBody.error).toBe('Server error');
+    expect(responseBody.details).toBeDefined();
+  });
+});
diff --git a/src/tests/api/card-collection/get.test.js b/src/tests/api/card-collection/get.test.js
new file mode 100644
index 0000000..e7f577e
--- /dev/null
+++ b/src/tests/api/card-collection/get.test.js
@@ -0,0 +1,175 @@
+/**
+ * Tests for CardCollection Get API endpoint
+ */
+import { describe, expect, it, vi, beforeEach, afterEach } from 'vitest';
+import { MCard } from '../../../content/model/mcard.js';
+import { CardCollection } from '../../../content/model/card-collection.js';
+
+// Mock dependencies
+vi.mock('../../../utils/storeAdapter.js', () => {
+  return {
+    getStoreEngine: vi.fn().mockImplementation(() => {
+      return {
+        add: vi.fn().mockReturnValue(true),
+        get: vi.fn(),
+        delete: vi.fn().mockReturnValue(true),
+      };
+    })
+  };
+});
+
+vi.mock('../../../services/logger.js', () => {
+  return {
+    default: {
+      debug: vi.fn(),
+      error: vi.fn()
+    }
+  };
+});
+
+// Helper function to create a mock Response constructor
+global.Response = class Response {
+  constructor(body, options) {
+    this.body = body;
+    this.status = options?.status || 200;
+    this.headers = options?.headers || {};
+  }
+};
+
+// Helper function to create a mock URL constructor
+global.URL = class URL {
+  constructor(url) {
+    this.url = url;
+    this.searchParams = new Map();
+  }
+  
+  static createMockURL(params) {
+    const url = new URL('http://localhost');
+    for (const [key, value] of Object.entries(params)) {
+      url.searchParams.set(key, value);
+    }
+    return url;
+  }
+};
+
+// Import the API handler after mocks are set up
+import { GET } from '../../../pages/api/card-collection/get.ts';
+
+describe('CardCollection Get API Endpoint', () => {
+  let mockCardCollection;
+  let testCard;
+  let testCardHash;
+  
+  beforeEach(() => {
+    // Create a test card
+    testCard = new MCard({ test: 'Sample content' });
+    testCardHash = 'test-hash-123';
+    testCard.hash = testCardHash;
+    testCard.g_time = new Date().toISOString();
+    testCard.hash_algorithm = 'sha256';
+    testCard.get_content_type = vi.fn().mockReturnValue('application/json');
+    
+    // Mock card collection get method
+    vi.spyOn(CardCollection.prototype, 'get').mockImplementation((hash) => 
+      hash === testCardHash ? testCard : null
+    );
+  });
+  
+  afterEach(() => {
+    vi.resetAllMocks();
+  });
+  
+  it('should get a card by hash', async () => {
+    // Mock URL with parameters
+    const request = {
+      url: 'http://localhost/api/card-collection/get',
+    };
+    request.url = new URL(request.url);
+    request.url.searchParams = new Map([
+      ['hash', testCardHash]
+    ]);
+    
+    // Call API handler
+    const response = await GET({ request });
+    
+    // Parse response body
+    const responseBody = JSON.parse(response.body);
+    
+    // Assertions
+    expect(response.status).toBe(200);
+    expect(responseBody.success).toBe(true);
+    expect(responseBody.card.hash).toBe(testCardHash);
+    expect(responseBody.card.content).toEqual(testCard.content);
+    expect(responseBody.serverTimestamp).toBeDefined();
+  });
+  
+  it('should return 404 if card not found', async () => {
+    // Mock URL with parameters for non-existent hash
+    const request = {
+      url: 'http://localhost/api/card-collection/get',
+    };
+    request.url = new URL(request.url);
+    request.url.searchParams = new Map([
+      ['hash', 'non-existent-hash']
+    ]);
+    
+    // Call API handler
+    const response = await GET({ request });
+    
+    // Parse response body
+    const responseBody = JSON.parse(response.body);
+    
+    // Assertions
+    expect(response.status).toBe(404);
+    expect(responseBody.success).toBe(false);
+    expect(responseBody.error).toBe('Card not found');
+  });
+  
+  it('should require hash parameter', async () => {
+    // Mock URL with missing hash
+    const request = {
+      url: 'http://localhost/api/card-collection/get',
+    };
+    request.url = new URL(request.url);
+    request.url.searchParams = new Map();
+    
+    // Call API handler
+    const response = await GET({ request });
+    
+    // Parse response body
+    const responseBody = JSON.parse(response.body);
+    
+    // Assertions
+    expect(response.status).toBe(400);
+    expect(responseBody.success).toBe(false);
+    expect(responseBody.error).toBe('Hash parameter is required');
+  });
+  
+  it('should handle server errors gracefully', async () => {
+    // Mock an error in the get method
+    vi.spyOn(CardCollection.prototype, 'get').mockImplementation(() => {
+      throw new Error('Test server error');
+    });
+    
+    // Mock URL with parameters
+    const request = {
+      url: 'http://localhost/api/card-collection/get',
+    };
+    request.url = new URL(request.url);
+    request.url.searchParams = new Map([
+      ['hash', testCardHash]
+    ]);
+    
+    // Call API handler
+    const response = await GET({ request });
+    
+    // Parse response body
+    const responseBody = JSON.parse(response.body);
+    
+    // Assertions
+    expect(response.status).toBe(500);
+    expect(responseBody.success).toBe(false);
+    expect(responseBody.error).toBe('Server error');
+    expect(responseBody.details).toBeDefined();
+  });
+});

commit 7d0b3a1bbfa36b46e370d2168921e798c3b04531
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Mon Mar 31 12:25:23 2025 +0800

    new api endpoint

diff --git a/public/data/cards.db-wal b/public/data/cards.db-wal
index ace22ef..f65450c 100644
Binary files a/public/data/cards.db-wal and b/public/data/cards.db-wal differ
diff --git a/src/pages/api/card-collection.ts b/src/pages/api/card-collection.ts
index 06e48e1..7e36342 100644
--- a/src/pages/api/card-collection.ts
+++ b/src/pages/api/card-collection.ts
@@ -1,6 +1,7 @@
 import type { APIRoute } from 'astro';
 import { MCard, MCardFromData } from '../../content/model/mcard.js';
 import { CardCollection } from '../../content/model/card-collection.js';
+import { SQLiteEngine } from '../../engine/sqlite_engine.js';
 import { getStoreEngine } from '../../utils/storeAdapter.js';
 import { encodeText } from '../../utils/textEncoderPolyfill.js';
 import { SafeBuffer } from '../../utils/bufferPolyfill.js';
diff --git a/src/pages/api/card-collection/add.ts b/src/pages/api/card-collection/add.ts
new file mode 100644
index 0000000..ea9a005
--- /dev/null
+++ b/src/pages/api/card-collection/add.ts
@@ -0,0 +1,87 @@
+import type { APIRoute } from 'astro';
+import { MCard } from '../../../content/model/mcard.js';
+import { CardCollection } from '../../../content/model/card-collection.js';
+import { getStoreEngine } from '../../../utils/storeAdapter.js';
+import { SafeBuffer } from '../../../utils/bufferPolyfill.js';
+import logger from '../../../services/logger.js';
+
+/**
+ * API endpoint for adding cards to the collection
+ * POST /api/card-collection/add
+ */
+export const POST: APIRoute = async ({ request }) => {
+  try {
+    const data = await request.json();
+    
+    // Initialize engine and card collection
+    const engine = getStoreEngine();
+    const cardCollection = new CardCollection(engine);
+    
+    logger.debug(`CardCollection ADD API: Processing POST request`);
+    
+    if (!data.card || typeof data.card !== 'object') {
+      return new Response(
+        JSON.stringify({
+          success: false,
+          error: 'Card data is required',
+          timestamp: new Date().toISOString()
+        }),
+        { status: 400, headers: { 'Content-Type': 'application/json' } }
+      );
+    }
+    
+    // Extract content and hash_algorithm
+    const { content, hash_algorithm } = data.card;
+    
+    if (content === undefined) {
+      return new Response(
+        JSON.stringify({
+          success: false,
+          error: 'Card content is required',
+          timestamp: new Date().toISOString()
+        }),
+        { status: 400, headers: { 'Content-Type': 'application/json' } }
+      );
+    }
+    
+    try {
+      // Create a new MCard
+      const card = new MCard(content, hash_algorithm);
+      
+      // Add to collection
+      const hash = cardCollection.add(card);
+      
+      // Return result
+      return new Response(
+        JSON.stringify({
+          success: true,
+          hash,
+          timestamp: new Date().toISOString()
+        }),
+        { status: 200, headers: { 'Content-Type': 'application/json' } }
+      );
+    } catch (err) {
+      const error = err as Error; // Type assertion
+      return new Response(
+        JSON.stringify({
+          success: false,
+          error: error.message || 'Error adding card',
+          timestamp: new Date().toISOString()
+        }),
+        { status: 400, headers: { 'Content-Type': 'application/json' } }
+      );
+    }
+  } catch (err) {
+    const error = err as Error; // Type assertion
+    logger.error('Error in CardCollection ADD API:', error);
+    return new Response(
+      JSON.stringify({
+        success: false,
+        error: 'Server error',
+        details: error.message || String(error),
+        timestamp: new Date().toISOString()
+      }),
+      { status: 500, headers: { 'Content-Type': 'application/json' } }
+    );
+  }
+};
diff --git a/src/pages/api/card-collection/delete.ts b/src/pages/api/card-collection/delete.ts
new file mode 100644
index 0000000..c711f96
--- /dev/null
+++ b/src/pages/api/card-collection/delete.ts
@@ -0,0 +1,79 @@
+import type { APIRoute } from 'astro';
+import { CardCollection } from '../../../content/model/card-collection.js';
+import { getStoreEngine } from '../../../utils/storeAdapter.js';
+import logger from '../../../services/logger.js';
+
+/**
+ * API endpoint for deleting cards from the collection
+ * DELETE /api/card-collection/delete
+ */
+export const DELETE: APIRoute = async ({ request }) => {
+  const url = new URL(request.url);
+  const hash = url.searchParams.get('hash');
+  
+  // Initialize engine and card collection
+  const engine = getStoreEngine();
+  const cardCollection = new CardCollection(engine);
+  
+  try {
+    logger.debug(`CardCollection DELETE API: Processing DELETE request for hash: ${hash}`);
+    
+    if (!hash) {
+      return new Response(
+        JSON.stringify({
+          success: false,
+          error: 'Hash parameter is required',
+          timestamp: new Date().toISOString()
+        }),
+        { status: 400, headers: { 'Content-Type': 'application/json' } }
+      );
+    }
+    
+    // Check if the card exists first
+    const card = cardCollection.get(hash);
+    if (!card) {
+      return new Response(
+        JSON.stringify({
+          success: false,
+          error: 'Card not found',
+          timestamp: new Date().toISOString()
+        }),
+        { status: 404, headers: { 'Content-Type': 'application/json' } }
+      );
+    }
+    
+    // Delete the card
+    const result = cardCollection.delete(hash);
+    
+    if (!result) {
+      return new Response(
+        JSON.stringify({
+          success: false,
+          error: 'Failed to delete card',
+          timestamp: new Date().toISOString()
+        }),
+        { status: 500, headers: { 'Content-Type': 'application/json' } }
+      );
+    }
+    
+    return new Response(
+      JSON.stringify({
+        success: true,
+        timestamp: new Date().toISOString()
+      }),
+      { status: 200, headers: { 'Content-Type': 'application/json' } }
+    );
+  } catch (err) {
+    const error = err as Error; // Type assertion
+    logger.error('Error in CardCollection DELETE API:', error);
+    return new Response(
+      JSON.stringify({
+        success: false,
+        error: 'Server error',
+        details: error.message || String(error),
+        timestamp: new Date().toISOString()
+      }),
+      { status: 500, headers: { 'Content-Type': 'application/json' } }
+    );
+  }
+};
diff --git a/src/pages/api/card-collection/get.ts b/src/pages/api/card-collection/get.ts
new file mode 100644
index 0000000..dcc3ac9
--- /dev/null
+++ b/src/pages/api/card-collection/get.ts
@@ -0,0 +1,73 @@
+import type { APIRoute } from 'astro';
+import { CardCollection } from '../../../content/model/card-collection.js';
+import { getStoreEngine } from '../../../utils/storeAdapter.js';
+import logger from '../../../services/logger.js';
+
+/**
+ * API endpoint for retrieving cards from the collection
+ * GET /api/card-collection/get
+ */
+export const GET: APIRoute = async ({ request }) => {
+  const url = new URL(request.url);
+  const hash = url.searchParams.get('hash');
+  
+  // Initialize engine and card collection
+  const engine = getStoreEngine();
+  const cardCollection = new CardCollection(engine);
+  
+  try {
+    logger.debug(`CardCollection GET API: Processing GET request for hash: ${hash}`);
+    
+    if (!hash) {
+      return new Response(
+        JSON.stringify({
+          success: false,
+          error: 'Hash parameter is required',
+          timestamp: new Date().toISOString()
+        }),
+        { status: 400, headers: { 'Content-Type': 'application/json' } }
+      );
+    }
+    
+    const card = cardCollection.get(hash);
+    
+    if (!card) {
+      return new Response(
+        JSON.stringify({
+          success: false,
+          error: 'Card not found',
+          timestamp: new Date().toISOString()
+        }),
+        { status: 404, headers: { 'Content-Type': 'application/json' } }
+      );
+    }
+    
+    // Return card data
+    return new Response(
+      JSON.stringify({
+        success: true,
+        card: {
+          hash: card.hash,
+          content: card.content,
+          hash_algorithm: card.hash_algorithm,
+          timestamp: card.g_time || new Date().toISOString(),
+          content_type: card.get_content_type?.() || 'unknown'
+        },
+        serverTimestamp: new Date().toISOString()
+      }),
+      { status: 200, headers: { 'Content-Type': 'application/json' } }
+    );
+  } catch (err) {
+    const error = err as Error; // Type assertion
+    logger.error('Error in CardCollection GET API:', error);
+    return new Response(
+      JSON.stringify({
+        success: false,
+        error: 'Server error',
+        details: error.message || String(error),
+        timestamp: new Date().toISOString()
+      }),
+      { status: 500, headers: { 'Content-Type': 'application/json' } }
+    );
+  }
+};
diff --git a/src/tests/api/card-collection.test.js b/src/tests/api/card-collection.test.js
new file mode 100644
index 0000000..26732c6
--- /dev/null
+++ b/src/tests/api/card-collection.test.js
@@ -0,0 +1,454 @@
+/**
+ * CardCollection API Endpoint Tests
+ */
+import { describe, expect, it, vi, beforeEach, afterEach } from 'vitest';
+import { MCard, MCardFromData } from '../../content/model/mcard.js';
+import { CardCollection } from '../../content/model/card-collection.js';
+import { SafeBuffer } from '../../utils/bufferPolyfill.js';
+
+// Mock dependencies
+vi.mock('../../engine/sqlite_engine.js', () => {
+  return {
+    SQLiteEngine: vi.fn().mockImplementation(() => {
+      return {
+        add: vi.fn().mockReturnValue(true),
+        get: vi.fn(),
+        delete: vi.fn().mockReturnValue(true),
+        get_page: vi.fn(),
+        search_by_content: vi.fn(),
+      };
+    })
+  };
+});
+
+vi.mock('../../utils/storeAdapter.js', () => {
+  return {
+    getStoreEngine: vi.fn().mockImplementation(() => {
+      return {
+        add: vi.fn().mockReturnValue(true),
+        get: vi.fn(),
+        delete: vi.fn().mockReturnValue(true),
+        get_page: vi.fn(),
+        search_by_content: vi.fn(),
+      };
+    })
+  };
+});
+
+vi.mock('../../services/logger.js', () => {
+  return {
+    default: {
+      debug: vi.fn(),
+      error: vi.fn()
+    }
+  };
+});
+
+// Helper function to create a mock Response constructor
+global.Response = class Response {
+  constructor(body, options) {
+    this.body = body;
+    this.status = options?.status || 200;
+    this.headers = options?.headers || {};
+  }
+};
+
+// Helper function to create a mock URL constructor
+global.URL = class URL {
+  constructor(url) {
+    this.url = url;
+    this.searchParams = new Map();
+  }
+  
+  static createMockURL(params) {
+    const url = new URL('http://localhost');
+    for (const [key, value] of Object.entries(params)) {
+      url.searchParams.set(key, value);
+    }
+    return url;
+  }
+};
+
+// Import the API handlers after mocks are set up
+import { GET, POST, DELETE } from '../../pages/api/card-collection.ts';
+
+describe('CardCollection API Endpoint', () => {
+  let mockCardCollection;
+  let testCard;
+  let testCardHash;
+  
+  beforeEach(() => {
+    // Create a test card
+    testCard = new MCard({ test: 'Sample content' });
+    testCardHash = 'test-hash-123';
+    testCard.hash = testCardHash;
+    testCard.g_time = new Date().toISOString();
+    
+    // Mock card collection methods
+    mockCardCollection = new CardCollection({});
+    mockCardCollection.add = vi.fn().mockReturnValue(testCardHash);
+    mockCardCollection.get = vi.fn().mockImplementation((hash) => 
+      hash === testCardHash ? testCard : null
+    );
+    mockCardCollection.delete = vi.fn().mockReturnValue(true);
+    mockCardCollection.get_page = vi.fn().mockReturnValue({
+      items: [testCard],
+      total_items: 1,
+      page_number: 1,
+      page_size: 10,
+      has_next: false,
+      has_previous: false,
+      total_pages: 1,
+      next_page: null,
+      previous_page: null
+    });
+    mockCardCollection.search_by_content = vi.fn().mockReturnValue({
+      items: [testCard],
+      total_items: 1,
+      page_number: 1,
+      page_size: 10,
+      has_next: false,
+      has_previous: false,
+      total_pages: 1,
+      next_page: null,
+      previous_page: null
+    });
+    
+    // Simulate cross-environment functionality
+    vi.mock('../../utils/textEncoderPolyfill.js', () => {
+      return {
+        encodeText: vi.fn(text => SafeBuffer.from(text, 'utf-8'))
+      };
+    });
+  });
+  
+  afterEach(() => {
+    vi.resetAllMocks();
+  });
+  
+  // #########################
+  // POST Tests (Add)
+  // #########################
+  describe('POST - Add Card', () => {
+    it('should add a card successfully', async () => {
+      // Create request
+      const request = {
+        json: vi.fn().mockResolvedValue({
+          action: 'add',
+          card: {
+            content: { test: 'Sample content' }
+          }
+        })
+      };
+      
+      // Call API handler
+      const response = await POST({ request });
+      
+      // Parse response body
+      const responseBody = JSON.parse(response.body);
+      
+      // Assertions
+      expect(response.status).toBe(200);
+      expect(responseBody.success).toBe(true);
+      expect(responseBody.hash).toBe(testCardHash);
+      expect(responseBody.timestamp).toBeDefined();
+    });
+    
+    it('should return error if card data is missing', async () => {
+      // Create request without card data
+      const request = {
+        json: vi.fn().mockResolvedValue({
+          action: 'add'
+        })
+      };
+      
+      // Call API handler
+      const response = await POST({ request });
+      
+      // Parse response body
+      const responseBody = JSON.parse(response.body);
+      
+      // Assertions
+      expect(response.status).toBe(400);
+      expect(responseBody.success).toBe(false);
+      expect(responseBody.error).toBe('Card data is required');
+    });
+    
+    it('should return error if content is missing', async () => {
+      // Create request with empty content
+      const request = {
+        json: vi.fn().mockResolvedValue({
+          action: 'add',
+          card: {}
+        })
+      };
+      
+      // Call API handler
+      const response = await POST({ request });
+      
+      // Parse response body
+      const responseBody = JSON.parse(response.body);
+      
+      // Assertions
+      expect(response.status).toBe(400);
+      expect(responseBody.success).toBe(false);
+      expect(responseBody.error).toBe('Card content is required');
+    });
+    
+    it('should handle unknown action', async () => {
+      // Create request with invalid action
+      const request = {
+        json: vi.fn().mockResolvedValue({
+          action: 'invalidAction',
+          card: { content: 'test' }
+        })
+      };
+      
+      // Call API handler
+      const response = await POST({ request });
+      
+      // Parse response body
+      const responseBody = JSON.parse(response.body);
+      
+      // Assertions
+      expect(response.status).toBe(400);
+      expect(responseBody.success).toBe(false);
+      expect(responseBody.error).toBe('Unknown action: invalidAction');
+    });
+  });
+  
+  // #########################
+  // GET Tests (Get, GetPage, Search)
+  // #########################
+  describe('GET - Retrieve operations', () => {
+    it('should get a card by hash', async () => {
+      // Mock URL with parameters
+      const request = {
+        url: 'http://localhost/api/card-collection',
+      };
+      request.url = new URL(request.url);
+      request.url.searchParams = new Map([
+        ['action', 'get'],
+        ['hash', testCardHash]
+      ]);
+      
+      // Call API handler
+      const response = await GET({ request });
+      
+      // Parse response body
+      const responseBody = JSON.parse(response.body);
+      
+      // Assertions
+      expect(response.status).toBe(200);
+      expect(responseBody.success).toBe(true);
+      expect(responseBody.card.hash).toBe(testCardHash);
+      expect(responseBody.card.content).toEqual(testCard.content);
+      expect(responseBody.serverTimestamp).toBeDefined();
+    });
+    
+    it('should return 404 if card not found', async () => {
+      // Mock URL with parameters for non-existent hash
+      const request = {
+        url: 'http://localhost/api/card-collection',
+      };
+      request.url = new URL(request.url);
+      request.url.searchParams = new Map([
+        ['action', 'get'],
+        ['hash', 'non-existent-hash']
+      ]);
+      
+      // Call API handler
+      const response = await GET({ request });
+      
+      // Parse response body
+      const responseBody = JSON.parse(response.body);
+      
+      // Assertions
+      expect(response.status).toBe(404);
+      expect(responseBody.success).toBe(false);
+      expect(responseBody.error).toBe('Card not found');
+    });
+    
+    it('should get a page of cards', async () => {
+      // Mock URL with parameters
+      const request = {
+        url: 'http://localhost/api/card-collection',
+      };
+      request.url = new URL(request.url);
+      request.url.searchParams = new Map([
+        ['action', 'getPage'],
+        ['pageNumber', '1'],
+        ['pageSize', '10']
+      ]);
+      
+      // Call API handler
+      const response = await GET({ request });
+      
+      // Parse response body
+      const responseBody = JSON.parse(response.body);
+      
+      // Assertions
+      expect(response.status).toBe(200);
+      expect(responseBody.success).toBe(true);
+      expect(responseBody.items).toBeDefined();
+      expect(responseBody.total_items).toBe(1);
+      expect(responseBody.page_number).toBe(1);
+      expect(responseBody.serverTimestamp).toBeDefined();
+    });
+    
+    it('should search cards by content', async () => {
+      // Mock URL with parameters
+      const request = {
+        url: 'http://localhost/api/card-collection',
+      };
+      request.url = new URL(request.url);
+      request.url.searchParams = new Map([
+        ['action', 'searchByContent'],
+        ['searchTerm', 'Sample'],
+        ['pageNumber', '1'],
+        ['pageSize', '10']
+      ]);
+      
+      // Call API handler
+      const response = await GET({ request });
+      
+      // Parse response body
+      const responseBody = JSON.parse(response.body);
+      
+      // Assertions
+      expect(response.status).toBe(200);
+      expect(responseBody.success).toBe(true);
+      expect(responseBody.items).toBeDefined();
+      expect(responseBody.total_items).toBe(1);
+      expect(responseBody.serverTimestamp).toBeDefined();
+    });
+    
+    it('should error if search term is empty', async () => {
+      // Mock URL with parameters
+      const request = {
+        url: 'http://localhost/api/card-collection',
+      };
+      request.url = new URL(request.url);
+      request.url.searchParams = new Map([
+        ['action', 'searchByContent'],
+        ['searchTerm', ''],
+        ['pageNumber', '1'],
+        ['pageSize', '10']
+      ]);
+      
+      // Call API handler
+      const response = await GET({ request });
+      
+      // Parse response body
+      const responseBody = JSON.parse(response.body);
+      
+      // Assertions
+      expect(response.status).toBe(400);
+      expect(responseBody.success).toBe(false);
+      expect(responseBody.error).toBe('Search string cannot be empty');
+    });
+  });
+  
+  // #########################
+  // DELETE Tests
+  // #########################
+  describe('DELETE - Delete card', () => {
+    it('should delete a card by hash', async () => {
+      // Mock URL with parameters
+      const request = {
+        url: 'http://localhost/api/card-collection',
+      };
+      request.url = new URL(request.url);
+      request.url.searchParams = new Map([
+        ['action', 'delete'],
+        ['hash', testCardHash]
+      ]);
+      
+      // Call API handler
+      const response = await DELETE({ request });
+      
+      // Parse response body
+      const responseBody = JSON.parse(response.body);
+      
+      // Assertions
+      expect(response.status).toBe(200);
+      expect(responseBody.success).toBe(true);
+      expect(responseBody.timestamp).toBeDefined();
+    });
+    
+    it('should return 404 if card to delete does not exist', async () => {
+      // Mock URL with parameters
+      const request = {
+        url: 'http://localhost/api/card-collection',
+      };
+      request.url = new URL(request.url);
+      request.url.searchParams = new Map([
+        ['action', 'delete'],
+        ['hash', 'non-existent-hash']
+      ]);
+      
+      // Call API handler
+      const response = await DELETE({ request });
+      
+      // Parse response body
+      const responseBody = JSON.parse(response.body);
+      
+      // Assertions
+      expect(response.status).toBe(404);
+      expect(responseBody.success).toBe(false);
+      expect(responseBody.error).toBe('Card not found');
+    });
+    
+    it('should validate hash parameter is provided', async () => {
+      // Mock URL with missing hash
+      const request = {
+        url: 'http://localhost/api/card-collection',
+      };
+      request.url = new URL(request.url);
+      request.url.searchParams = new Map([
+        ['action', 'delete']
+      ]);
+      
+      // Call API handler
+      const response = await DELETE({ request });
+      
+      // Parse response body
+      const responseBody = JSON.parse(response.body);
+      
+      // Assertions
+      expect(response.status).toBe(400);
+      expect(responseBody.success).toBe(false);
+      expect(responseBody.error).toBe('Hash is required');
+    });
+  });
+  
+  // #########################
+  // Cross-Environment Tests
+  // #########################
+  describe('Cross-Environment Compatibility', () => {
+    it('should use SafeBuffer for content encoding', async () => {
+      const contentText = 'Test content';
+      const encodedContent = SafeBuffer.from(contentText);
+      
+      // Create a test with text content
+      const textCard = new MCard(contentText);
+      
+      // Ensure SafeBuffer is used in encoding
+      expect(SafeBuffer.isBuffer(encodedContent)).toBe(true);
+    });
+    
+    it('should use MCardFromData for retrieving existing cards', async () => {
+      // Create a card from existing data
+      const existingContent = { test: 'Existing content' };
+      const hash = 'existing-hash-123';
+      const timestamp = new Date().toISOString();
+      
+      const fromDataCard = new MCardFromData(existingContent, hash, timestamp);
+      
+      // Ensure properties are set correctly
+      expect(fromDataCard.hash).toBe(hash);
+      expect(fromDataCard.content).toEqual(existingContent);
+      expect(fromDataCard.g_time).toBe(timestamp);
+    });
+  });
+});

commit 2d79ded2e6f1f66bff3c1af3d5d9b34e955d9a53
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Sun Mar 30 23:07:25 2025 +0800

    new CML

diff --git a/public/data/cards.db b/public/data/cards.db
index 743d9cb..97fdf2f 100644
Binary files a/public/data/cards.db and b/public/data/cards.db differ
diff --git a/public/data/cards.db-wal b/public/data/cards.db-wal
index 84d5229..ace22ef 100644
Binary files a/public/data/cards.db-wal and b/public/data/cards.db-wal differ
diff --git a/src/components/panels/CLMInputPanel.jsx b/src/components/panels/CLMInputPanel.jsx
index 4c574d0..6d13b42 100644
--- a/src/components/panels/CLMInputPanel.jsx
+++ b/src/components/panels/CLMInputPanel.jsx
@@ -4,6 +4,7 @@ import SaveButton from './clm/SaveButton';
 import AbstractSpecification from './clm/AbstractSpecification';
 import ConcreteImplementation from './clm/ConcreteImplementation';
 import BalancedExpectations from './clm/BalancedExpectations';
+import CubicalLogicModel from './clm/CubicalLogicModel';
 
 const CLMInputPanel = () => {
     // Title state
@@ -28,6 +29,24 @@ const CLMInputPanel = () => {
             practicalBoundaries: '',
             evaluationMetrics: '',
             feedbackLoops: ''
+        },
+        // Cubical Logic Model dimension
+        cubicalLogicModel: {
+            abstractSpecification: {
+                context: '',
+                goal: '',
+                successCriteria: ''
+            },
+            concreteImplementation: {
+                inputs: '',
+                activities: '',
+                outputs: ''
+            },
+            balancedExpectations: {
+                practicalBoundaries: '',
+                evaluationMetrics: '',
+                feedbackLoops: ''
+            }
         }
     });
     
@@ -87,27 +106,35 @@ const CLMInputPanel = () => {
         [currentClmHash, autoSaveEnabled]
     );
 
-    // Handle input changes with auto-update
-    const handleInputChange = (dimension, section, value) => {
-        // Update local state
-        setClmData(prev => {
-            const updatedData = {
-                ...prev,
+    // Handle input changes for all dimensions
+    const handleInputChange = (dimension, section, field, value) => {
+        if (dimension === 'cubicalLogicModel') {
+            // Handle nested structure for Cubical Logic Model
+            setClmData(prevState => ({
+                ...prevState,
                 [dimension]: {
-                    ...prev[dimension],
-                    [section]: value
+                    ...prevState[dimension],
+                    [section]: {
+                        ...prevState[dimension][section],
+                        [field]: value
+                    }
                 }
-            };
-            
-            // If we have a CLM hash, auto-update this dimension
-            if (currentClmHash && autoSaveEnabled) {
-                // Generate JSON for this dimension
-                const jsonContent = generateJsonData(dimension, updatedData);
-                debouncedUpdate(dimension, jsonContent);
-            }
-            
-            return updatedData;
-        });
+            }));
+        } else {
+            // Handle flat structure for other dimensions
+            setClmData(prevState => ({
+                ...prevState,
+                [dimension]: {
+                    ...prevState[dimension],
+                    [field]: value
+                }
+            }));
+        }
+
+        // Trigger auto-save if enabled
+        if (autoSaveEnabled && currentClmHash) {
+            debouncedUpdate(dimension, generateJsonData(dimension));
+        }
     };
 
     // Utility function to generate JSON data with optional custom data
@@ -137,6 +164,26 @@ const CLMInputPanel = () => {
                     feedback_loops: data.balancedExpectations.feedbackLoops
                 };
             
+            case 'cubicalLogicModel':
+                return {
+                    dimension_type: "cubical_logic_model",
+                    abstract_specification: {
+                        context: data.cubicalLogicModel.abstractSpecification.context,
+                        goal: data.cubicalLogicModel.abstractSpecification.goal,
+                        success_criteria: data.cubicalLogicModel.abstractSpecification.successCriteria
+                    },
+                    concrete_implementation: {
+                        inputs: data.cubicalLogicModel.concreteImplementation.inputs,
+                        activities: data.cubicalLogicModel.concreteImplementation.activities,
+                        outputs: data.cubicalLogicModel.concreteImplementation.outputs
+                    },
+                    balanced_expectations: {
+                        practical_boundaries: data.cubicalLogicModel.balancedExpectations.practicalBoundaries,
+                        evaluation_metrics: data.cubicalLogicModel.balancedExpectations.evaluationMetrics,
+                        feedback_loops: data.cubicalLogicModel.balancedExpectations.feedbackLoops
+                    }
+                };
+            
             default:
                 return {};
         }
@@ -160,14 +207,17 @@ const CLMInputPanel = () => {
             const abstractSpecificationJson = generateJsonData('abstractSpecification');
             const concreteImplementationJson = generateJsonData('concreteImplementation');
             const balancedExpectationsJson = generateJsonData('balancedExpectations');
+            const cubicalLogicModelJson = generateJsonData('cubicalLogicModel');
 
             // Prepare the root CLM MCard JSON
             const rootClmJson = {
                 title: documentTitle,
-                dimensions: {
-                    abstract_specification: abstractSpecificationJson,
-                    concrete_implementation: concreteImplementationJson,
-                    balanced_expectations: balancedExpectationsJson
+                content: {
+                    dimensions: {
+                        abstract_specification: abstractSpecificationJson,
+                        concrete_implementation: concreteImplementationJson,
+                        balanced_expectations: balancedExpectationsJson
+                    }
                 }
             };
 
@@ -200,7 +250,16 @@ const CLMInputPanel = () => {
             
         } catch (error) {
             console.error('Error saving CLM data:', error);
-            setSaveMessage({ type: 'error', text: error.message || 'Failed to save CLM data' });
+            console.log('Detailed error data:', {
+                title: documentTitle,
+                abstractSpecification: generateJsonData('abstractSpecification'),
+                concreteImplementation: generateJsonData('concreteImplementation'),
+                balancedExpectations: generateJsonData('balancedExpectations')
+            });
+            setSaveMessage({ 
+                type: 'error', 
+                text: `Failed to save CLM data: ${error.message || 'Unknown error'}` 
+            });
         } finally {
             setIsSaving(false);
         }
@@ -304,6 +363,14 @@ const CLMInputPanel = () => {
                         generateJsonData={generateJsonData}
                     />
                 );
+            case 'cubicalLogicModel':
+                return (
+                    <CubicalLogicModel 
+                        data={clmData.cubicalLogicModel}
+                        onChange={handleInputChange}
+                        generateJsonData={generateJsonData}
+                    />
+                );
             default:
                 return null;
         }
@@ -314,10 +381,32 @@ const CLMInputPanel = () => {
             <div className="max-w-3xl mx-auto space-y-8">
                 {/* Header with Navigation and Save Button */}
                 <div className="flex justify-between items-center border-b pb-4">
-                    <DimensionNavigation 
-                        activeDimension={activeDimension} 
-                        onDimensionChange={setActiveDimension} 
-                    />
+                    <div className="tabs">
+                        <button 
+                            className={activeDimension === 'abstractSpecification' ? 'active' : ''} 
+                            onClick={() => setActiveDimension('abstractSpecification')}
+                        >
+                            Abstract Specification
+                        </button>
+                        <button 
+                            className={activeDimension === 'concreteImplementation' ? 'active' : ''} 
+                            onClick={() => setActiveDimension('concreteImplementation')}
+                        >
+                            Concrete Implementation
+                        </button>
+                        <button 
+                            className={activeDimension === 'balancedExpectations' ? 'active' : ''} 
+                            onClick={() => setActiveDimension('balancedExpectations')}
+                        >
+                            Balanced Expectations
+                        </button>
+                        <button 
+                            className={activeDimension === 'cubicalLogicModel' ? 'active' : ''} 
+                            onClick={() => setActiveDimension('cubicalLogicModel')}
+                        >
+                            Cubical Logic Model
+                        </button>
+                    </div>
                     <SaveButton 
                         onSave={handleSubmit} 
                         isSaving={isSaving} 
diff --git a/src/components/panels/clm/CubicalLogicModel.jsx b/src/components/panels/clm/CubicalLogicModel.jsx
new file mode 100644
index 0000000..e333a85
--- /dev/null
+++ b/src/components/panels/clm/CubicalLogicModel.jsx
@@ -0,0 +1,164 @@
+import React, { useState, useEffect } from 'react';
+import JsonPreview from './JsonPreview';
+import '../../../styles/clm-table.css';
+
+const CubicalLogicModel = ({ 
+    data = {}, 
+    onChange, 
+    generateJsonData,
+    isReadOnly = false 
+}) => {
+    const [localData, setLocalData] = useState({
+        // Three dimensions of Cubical Logic Model
+        abstractSpecification: {
+            context: '',
+            goal: '',
+            successCriteria: ''
+        },
+        concreteImplementation: {
+            inputs: '',
+            activities: '',
+            outputs: ''
+        },
+        balancedExpectations: {
+            practicalBoundaries: '',
+            evaluationMetrics: '',
+            feedbackLoops: ''
+        }
+    });
+
+    useEffect(() => {
+        // Initialize with provided data or keep defaults
+        if (data && Object.keys(data).length > 0) {
+            setLocalData(data);
+        }
+    }, [data]);
+
+    const handleInputChange = (section, field, value) => {
+        const updatedData = { 
+            ...localData, 
+            [section]: {
+                ...localData[section],
+                [field]: value
+            }
+        };
+        setLocalData(updatedData);
+        
+        // Notify parent component about data changes
+        if (onChange && !isReadOnly) {
+            onChange('cubicalLogicModel', section, field, value);
+        }
+    };
+
+    const renderSection = (sectionName, title, fields) => {
+        return (
+            <div className="clm-section">
+                <h4>{title}</h4>
+                <div className="section-content">
+                    {fields.map(field => (
+                        <div className="form-group" key={field.key}>
+                            <label>{field.label}</label>
+                            <textarea
+                                value={localData[sectionName][field.key]}
+                                onChange={(e) => handleInputChange(sectionName, field.key, e.target.value)}
+                                placeholder={field.placeholder}
+                                disabled={isReadOnly}
+                                rows={4}
+                            />
+                        </div>
+                    ))}
+                </div>
+            </div>
+        );
+    };
+
+    return (
+        <div className="cubical-logic-model-panel">
+            <h3>Cubical Logic Model</h3>
+            
+            {!isReadOnly && (
+                <div className="input-section clm-grid">
+                    {renderSection('abstractSpecification', 'Abstract Specification', [
+                        { key: 'context', label: 'Context', placeholder: 'Describe the contextual background' },
+                        { key: 'goal', label: 'Goal', placeholder: 'Define the primary goal' },
+                        { key: 'successCriteria', label: 'Success Criteria', placeholder: 'List the criteria for success' }
+                    ])}
+
+                    {renderSection('concreteImplementation', 'Concrete Implementation', [
+                        { key: 'inputs', label: 'Inputs', placeholder: 'List required inputs and resources' },
+                        { key: 'activities', label: 'Activities', placeholder: 'Describe implementation activities' },
+                        { key: 'outputs', label: 'Outputs', placeholder: 'Define expected outputs' }
+                    ])}
+
+                    {renderSection('balancedExpectations', 'Balanced Expectations', [
+                        { key: 'practicalBoundaries', label: 'Practical Boundaries', placeholder: 'Define practical boundaries and constraints' },
+                        { key: 'evaluationMetrics', label: 'Evaluation Metrics', placeholder: 'Describe evaluation data and performance metrics' },
+                        { key: 'feedbackLoops', label: 'Feedback Loops', placeholder: 'Outline feedback loops and validation mechanisms' }
+                    ])}
+                </div>
+            )}
+
+            {/* Table Display Preview */}
+            {isReadOnly && (
+                <div className="clm-table-preview">
+                    <table className="clm-table">
+                        <tbody>
+                            <tr>
+                                <th colSpan={6}>Abstract Specification</th>
+                            </tr>
+                            <tr>
+                                <th>Context</th>
+                                <td colSpan={5}>{localData.abstractSpecification.context}</td>
+                            </tr>
+                            <tr>
+                                <th>Goal</th>
+                                <td colSpan={5}>{localData.abstractSpecification.goal}</td>
+                            </tr>
+                            <tr>
+                                <th>Success Criteria</th>
+                                <td colSpan={5}>{localData.abstractSpecification.successCriteria}</td>
+                            </tr>
+
+                            <tr>
+                                <th colSpan={6}>Concrete Implementation</th>
+                            </tr>
+                            <tr>
+                                <th colSpan={2}>Inputs</th>
+                                <th colSpan={2}>Activities</th>
+                                <th colSpan={2}>Outputs</th>
+                            </tr>
+                            <tr>
+                                <td colSpan={2}>{localData.concreteImplementation.inputs}</td>
+                                <td colSpan={2}>{localData.concreteImplementation.activities}</td>
+                                <td colSpan={2}>{localData.concreteImplementation.outputs}</td>
+                            </tr>
+
+                            <tr>
+                                <th colSpan={6}>Balanced Expectations</th>
+                            </tr>
+                            <tr>
+                                <th colSpan={2}>Practical Boundaries</th>
+                                <td colSpan={4}>{localData.balancedExpectations.practicalBoundaries}</td>
+                            </tr>
+                            <tr>
+                                <th colSpan={2}>Evaluation Metrics</th>
+                                <td colSpan={4}>{localData.balancedExpectations.evaluationMetrics}</td>
+                            </tr>
+                            <tr>
+                                <th colSpan={2}>Feedback Loops</th>
+                                <td colSpan={4}>{localData.balancedExpectations.feedbackLoops}</td>
+                            </tr>
+                        </tbody>
+                    </table>
+                </div>
+            )}
+
+            <JsonPreview 
+                data={localData} 
+                title="Cubical Logic Model JSON" 
+            />
+        </div>
+    );
+};
+
+export default CubicalLogicModel;
diff --git a/src/components/panels/clm/JsonPreview.jsx b/src/components/panels/clm/JsonPreview.jsx
index 8f4d552..622bd7d 100644
--- a/src/components/panels/clm/JsonPreview.jsx
+++ b/src/components/panels/clm/JsonPreview.jsx
@@ -1,13 +1,13 @@
 import React from 'react';
 
-const JsonPreview = ({ jsonData }) => {
+const JsonPreview = ({ data, title = "JSON Preview" }) => {
     // Format JSON with indentation for better readability
-    const formattedJson = JSON.stringify(jsonData, null, 2);
+    const formattedJson = JSON.stringify(data, null, 2);
     
     return (
-        <div>
-            <h3 className="text-lg font-bold">JSON Preview</h3>
-            <pre className="p-3 rounded-lg bg-slate-100 text-sm overflow-auto max-h-60">
+        <div className="json-preview-container">
+            <h3 className="json-preview-title text-lg font-bold">{title}</h3>
+            <pre className="json-preview p-3 rounded-lg bg-slate-800 text-slate-100 text-sm overflow-auto max-h-60">
                 {formattedJson}
             </pre>
         </div>
diff --git a/src/pages/api/store-clm.ts b/src/pages/api/store-clm.ts
index 86901ac..aead3b7 100644
--- a/src/pages/api/store-clm.ts
+++ b/src/pages/api/store-clm.ts
@@ -28,13 +28,35 @@ export const POST: APIRoute = async ({ request }) => {
   try {
     // Get the request body
     const data = await request.json();
-    console.log('Received CLM data to store:', { title: data.title, format: data.format });
+    console.log('Received CLM data to store:', { 
+      title: data.title, 
+      format: data.format,
+      contentKeys: data.content ? Object.keys(data.content) : 'No content',
+      dimensionKeys: data.content?.dimensions ? Object.keys(data.content.dimensions) : 'No dimensions'
+    });
     
-    // Validate required fields
-    if (!data.title || !data.content) {
+    // Validate required fields with more detailed checks
+    if (!data.title) {
+      return new Response(
+        JSON.stringify({ 
+          error: 'Invalid request. Title is required.', 
+          timestamp: new Date().toISOString() 
+        }),
+        { 
+          status: 400, 
+          headers: { 'Content-Type': 'application/json' } 
+        }
+      );
+    }
+
+    if (!data.content || !data.content.dimensions) {
       return new Response(
         JSON.stringify({ 
-          error: 'Invalid request. Title and content are required.', 
+          error: 'Invalid request. Content and dimensions are required.', 
+          details: {
+            contentExists: !!data.content,
+            dimensionsExists: !!data.content?.dimensions
+          },
           timestamp: new Date().toISOString() 
         }),
         { 
diff --git a/src/styles/clm-table.css b/src/styles/clm-table.css
new file mode 100644
index 0000000..40bb286
--- /dev/null
+++ b/src/styles/clm-table.css
@@ -0,0 +1,165 @@
+/* Cubical Logic Model Table Styles - Dark Theme */
+.clm-table-preview {
+  margin: 20px 0;
+  overflow-x: auto;
+  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
+}
+
+.clm-table {
+  width: 100%;
+  max-width: 800px;
+  margin: 0 auto;
+  border-collapse: collapse;
+  font-size: 14px;
+  background-color: #1a202c;
+  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
+  color: #e2e8f0;
+}
+
+.clm-table th,
+.clm-table td {
+  padding: 12px;
+  border: 1px solid #2d3748;
+  line-height: 1.5;
+}
+
+.clm-table th {
+  background-color: #2d3748;
+  font-weight: 600;
+  text-align: left;
+  color: #e2e8f0;
+}
+
+.clm-table th[colspan="6"] {
+  background-color: #4a5568;
+  color: white;
+  text-align: center;
+  font-size: 16px;
+  padding: 10px;
+}
+
+.clm-table td {
+  vertical-align: top;
+  word-wrap: break-word;
+  white-space: pre-line;
+  color: #e2e8f0;
+  background-color: #1a202c;
+  font-size: 0.875rem;
+}
+
+/* Table row hover effects */
+.clm-table tbody tr:hover td {
+  background-color: #2d3748;
+}
+
+/* Form layout for editing */
+.clm-grid {
+  display: grid;
+  grid-template-columns: 1fr;
+  gap: 20px;
+}
+
+.clm-section {
+  border: 1px solid #2d3748;
+  border-radius: 6px;
+  padding: 16px;
+  background-color: #1a202c;
+  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
+}
+
+.clm-section h4 {
+  margin-top: 0;
+  margin-bottom: 16px;
+  font-size: 18px;
+  color: #e2e8f0;
+  border-bottom: 1px solid #2d3748;
+  padding-bottom: 8px;
+}
+
+.section-content {
+  display: grid;
+  grid-template-columns: 1fr;
+  gap: 16px;
+}
+
+@media (min-width: 768px) {
+  .clm-grid {
+    grid-template-columns: 1fr 1fr;
+  }
+}
+
+/* Form field styles */
+.form-group label {
+  display: block;
+  margin-bottom: 8px;
+  font-weight: 500;
+  color: #e2e8f0;
+}
+
+.form-group textarea,
+.form-group input {
+  width: 100%;
+  padding: 10px;
+  border: 1px solid #2d3748;
+  border-radius: 4px;
+  min-height: 80px;
+  font-family: inherit;
+  transition: border-color 0.2s;
+  background-color: #2d3748;
+  color: #e2e8f0;
+}
+
+.form-group textarea:focus,
+.form-group input:focus {
+  outline: none;
+  border-color: #63b3ed;
+  box-shadow: 0 0 0 2px rgba(99, 179, 237, 0.3);
+}
+
+.form-group input {
+  min-height: unset;
+}
+
+/* Tab navigation styling */
+.tabs {
+  display: flex;
+  flex-wrap: wrap;
+  gap: 4px;
+  margin-bottom: 16px;
+}
+
+.tabs button {
+  padding: 8px 16px;
+  background-color: #2d3748;
+  color: #a0aec0;
+  border: 1px solid #4a5568;
+  border-radius: 4px;
+  font-weight: 500;
+  cursor: pointer;
+  transition: all 0.2s;
+}
+
+.tabs button.active {
+  background-color: #4a5568;
+  color: white;
+  border-color: #63b3ed;
+}
+
+/* JSON Preview dark theme */
+pre.json-preview {
+  background-color: #1a202c !important;
+  color: #e2e8f0 !important;
+  border-color: #2d3748 !important;
+}
+
+.json-preview-title {
+  color: #e2e8f0 !important;
+}
+
+/* Ensure cubical logic model panel has dark theme */
+.cubical-logic-model-panel {
+  background-color: #1a202c;
+  color: #e2e8f0;
+  padding: 1rem;
+  border-radius: 6px;
+}

commit 4d10f1e551fcff35055a3742aaf1e3a985bae763
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Sun Mar 30 23:07:25 2025 +0800

    new CML

diff --git a/Docs/to-do-plan b/Docs/to-do-plan
index 120350a..80d8888 160000
--- a/Docs/to-do-plan
+++ b/Docs/to-do-plan
@@ -1 +1 @@
-Subproject commit 120350a8b27b3acbe3d67fa658aff3748eea7f55
+Subproject commit 80d88883ad08d7de1a87895384ee7e0bfac79e06
diff --git a/src/pages/api/__tests__/card-collection.test.ts b/src/pages/api/__tests__/card-collection.test.ts
new file mode 100644
index 0000000..f880f7b
--- /dev/null
+++ b/src/pages/api/__tests__/card-collection.test.ts
@@ -0,0 +1,462 @@
+/**
+ * Tests for CardCollection API Endpoint
+ */
+import { MCard, MCardFromData } from '../../../content/model/mcard.js';
+import { CardCollection } from '../../../content/model/card-collection.js';
+import { SafeBuffer } from '../../../utils/bufferPolyfill.js';
+
+// Mock dependencies
+jest.mock('../../../utils/storeAdapter.js', () => ({
+  getStoreEngine: jest.fn().mockImplementation(() => ({
+    add: jest.fn().mockReturnValue(true),
+    get: jest.fn(),
+    delete: jest.fn().mockReturnValue(true),
+    get_page: jest.fn(),
+    search_by_content: jest.fn(),
+  }))
+}));
+
+jest.mock('../../../services/logger.js', () => ({
+  debug: jest.fn(),
+  error: jest.fn(),
+  default: {
+    debug: jest.fn(),
+    error: jest.fn()
+  }
+}));
+
+// Mock global Response and URL for testing
+global.Response = jest.fn().mockImplementation(function(body, options) {
+  this.body = body;
+  this.status = options?.status || 200;
+  this.headers = options?.headers || {};
+  this.json = jest.fn().mockResolvedValue(JSON.parse(body));
+}) as any;
+
+global.URL = jest.fn().mockImplementation(function(url) {
+  this.url = url;
+  this.searchParams = {
+    get: jest.fn(),
+    set: jest.fn(),
+  };
+}) as any;
+
+// Import the API handlers after mocks are set up
+import { GET, POST, DELETE } from '../card-collection';
+
+describe('CardCollection API Endpoint', () => {
+  let mockCardCollection: jest.Mocked<CardCollection>;
+  let testCard: MCard;
+  let testCardHash: string;
+  
+  beforeEach(() => {
+    // Reset mocks
+    jest.clearAllMocks();
+    
+    // Create a test card
+    testCard = new MCard({ test: 'Sample content' });
+    testCardHash = 'test-hash-123';
+    testCard.hash = testCardHash;
+    testCard.g_time = new Date().toISOString();
+    
+    // Set up URL mock for testing GET and DELETE requests
+    (global.URL as jest.Mock).mockImplementation((url) => {
+      return {
+        url,
+        searchParams: {
+          get: (param: string) => {
+            if (param === 'hash') return testCardHash;
+            if (param === 'action') return 'get'; // Default to 'get' action
+            if (param === 'searchTerm') return 'sample';
+            if (param === 'pageNumber') return '1';
+            if (param === 'pageSize') return '10';
+            return null;
+          }
+        }
+      };
+    });
+    
+    // Mock CardCollection methods
+    mockCardCollection = {
+      add: jest.fn().mockReturnValue(testCardHash),
+      get: jest.fn().mockImplementation((hash) => (hash === testCardHash ? testCard : null)),
+      delete: jest.fn().mockReturnValue(true),
+      get_page: jest.fn().mockReturnValue({
+        items: [testCard],
+        total_items: 1,
+        page_number: 1,
+        page_size: 10,
+        has_next: false,
+        has_previous: false,
+        next_page: null,
+        previous_page: null,
+        total_pages: 1
+      }),
+      search_by_content: jest.fn().mockReturnValue({
+        items: [testCard],
+        total_items: 1,
+        page_number: 1,
+        page_size: 10,
+        has_next: false,
+        has_previous: false,
+        next_page: null,
+        previous_page: null,
+        total_pages: 1
+      })
+    } as unknown as jest.Mocked<CardCollection>;
+    
+    // Mock CardCollection constructor methods
+    jest.spyOn(CardCollection.prototype, 'add').mockImplementation(mockCardCollection.add);
+    jest.spyOn(CardCollection.prototype, 'get').mockImplementation(mockCardCollection.get);
+    jest.spyOn(CardCollection.prototype, 'delete').mockImplementation(mockCardCollection.delete);
+    jest.spyOn(CardCollection.prototype, 'get_page').mockImplementation(mockCardCollection.get_page);
+    jest.spyOn(CardCollection.prototype, 'search_by_content').mockImplementation(mockCardCollection.search_by_content);
+  });
+  
+  afterEach(() => {
+    jest.resetAllMocks();
+  });
+  
+  // #########################
+  // POST Tests (Add operation)
+  // #########################
+  describe('POST - Add Card', () => {
+    it('should add a card successfully', async () => {
+      // Create request
+      const request = {
+        json: jest.fn().mockResolvedValue({
+          action: 'add',
+          card: {
+            content: { test: 'Sample content' }
+          }
+        })
+      };
+      
+      // Call API handler
+      const response = await POST({ request } as any);
+      
+      // Parse response body
+      const responseBody = JSON.parse(response.body as string);
+      
+      // Assertions
+      expect(response.status).toBe(200);
+      expect(responseBody.success).toBe(true);
+      expect(responseBody.hash).toBe(testCardHash);
+      expect(responseBody.timestamp).toBeDefined();
+    });
+    
+    it('should return error if card data is missing', async () => {
+      // Create request without card data
+      const request = {
+        json: jest.fn().mockResolvedValue({
+          action: 'add'
+        })
+      };
+      
+      // Call API handler
+      const response = await POST({ request } as any);
+      
+      // Parse response body
+      const responseBody = JSON.parse(response.body as string);
+      
+      // Assertions
+      expect(response.status).toBe(400);
+      expect(responseBody.success).toBe(false);
+      expect(responseBody.error).toBe('Card data is required');
+    });
+    
+    it('should handle unknown action', async () => {
+      // Create request with invalid action
+      const request = {
+        json: jest.fn().mockResolvedValue({
+          action: 'invalidAction'
+        })
+      };
+      
+      // Call API handler
+      const response = await POST({ request } as any);
+      
+      // Parse response body
+      const responseBody = JSON.parse(response.body as string);
+      
+      // Assertions
+      expect(response.status).toBe(400);
+      expect(responseBody.success).toBe(false);
+      expect(responseBody.error).toContain('Unknown action');
+    });
+  });
+  
+  // #########################
+  // GET Tests
+  // #########################
+  describe('GET - Retrieve operations', () => {
+    it('should get a card by hash', async () => {
+      // Set up URL with 'get' action
+      (global.URL as jest.Mock).mockImplementation(() => ({
+        url: 'http://example.com',
+        searchParams: {
+          get: (param: string) => {
+            if (param === 'action') return 'get';
+            if (param === 'hash') return testCardHash;
+            return null;
+          }
+        }
+      }));
+      
+      // Create request
+      const request = {
+        url: 'http://example.com'
+      };
+      
+      // Call API handler
+      const response = await GET({ request } as any);
+      
+      // Parse response body
+      const responseBody = JSON.parse(response.body as string);
+      
+      // Assertions
+      expect(response.status).toBe(200);
+      expect(responseBody.success).toBe(true);
+      expect(responseBody.card).toBeDefined();
+      expect(responseBody.card.hash).toBe(testCardHash);
+    });
+    
+    it('should handle missing hash parameter', async () => {
+      // Set up URL with missing hash
+      (global.URL as jest.Mock).mockImplementation(() => ({
+        url: 'http://example.com',
+        searchParams: {
+          get: (param: string) => {
+            if (param === 'action') return 'get';
+            return null; // No hash provided
+          }
+        }
+      }));
+      
+      // Create request
+      const request = {
+        url: 'http://example.com'
+      };
+      
+      // Call API handler
+      const response = await GET({ request } as any);
+      
+      // Parse response body
+      const responseBody = JSON.parse(response.body as string);
+      
+      // Assertions
+      expect(response.status).toBe(400);
+      expect(responseBody.success).toBe(false);
+      expect(responseBody.error).toBe('Invalid hash');
+    });
+    
+    it('should handle non-existent card', async () => {
+      // Set up URL with non-existent hash
+      (global.URL as jest.Mock).mockImplementation(() => ({
+        url: 'http://example.com',
+        searchParams: {
+          get: (param: string) => {
+            if (param === 'action') return 'get';
+            if (param === 'hash') return 'non-existent-hash';
+            return null;
+          }
+        }
+      }));
+      
+      // Create request
+      const request = {
+        url: 'http://example.com'
+      };
+      
+      // Call API handler
+      const response = await GET({ request } as any);
+      
+      // Parse response body
+      const responseBody = JSON.parse(response.body as string);
+      
+      // Assertions
+      expect(response.status).toBe(404);
+      expect(responseBody.success).toBe(false);
+      expect(responseBody.error).toBe('Card not found');
+    });
+    
+    it('should handle getPage action', async () => {
+      // Set up URL with 'getPage' action
+      (global.URL as jest.Mock).mockImplementation(() => ({
+        url: 'http://example.com',
+        searchParams: {
+          get: (param: string) => {
+            if (param === 'action') return 'getPage';
+            if (param === 'pageNumber') return '1';
+            if (param === 'pageSize') return '10';
+            return null;
+          }
+        }
+      }));
+      
+      // Create request
+      const request = {
+        url: 'http://example.com'
+      };
+      
+      // Call API handler
+      const response = await GET({ request } as any);
+      
+      // Parse response body
+      const responseBody = JSON.parse(response.body as string);
+      
+      // Assertions
+      expect(response.status).toBe(200);
+      expect(responseBody.success).toBe(true);
+      expect(responseBody.items).toBeDefined();
+      expect(responseBody.total_items).toBe(1);
+    });
+    
+    it('should handle searchByContent action', async () => {
+      // Set up URL with 'searchByContent' action
+      (global.URL as jest.Mock).mockImplementation(() => ({
+        url: 'http://example.com',
+        searchParams: {
+          get: (param: string) => {
+            if (param === 'action') return 'searchByContent';
+            if (param === 'searchTerm') return 'sample';
+            if (param === 'pageNumber') return '1';
+            if (param === 'pageSize') return '10';
+            return null;
+          }
+        }
+      }));
+      
+      // Create request
+      const request = {
+        url: 'http://example.com'
+      };
+      
+      // Call API handler
+      const response = await GET({ request } as any);
+      
+      // Parse response body
+      const responseBody = JSON.parse(response.body as string);
+      
+      // Assertions
+      expect(response.status).toBe(200);
+      expect(responseBody.success).toBe(true);
+      expect(responseBody.items).toBeDefined();
+    });
+  });
+  
+  // #########################
+  // DELETE Tests
+  // #########################
+  describe('DELETE - Delete Card', () => {
+    it('should delete a card successfully', async () => {
+      // Set up URL with 'delete' action
+      (global.URL as jest.Mock).mockImplementation(() => ({
+        url: 'http://example.com',
+        searchParams: {
+          get: (param: string) => {
+            if (param === 'action') return 'delete';
+            if (param === 'hash') return testCardHash;
+            return null;
+          }
+        }
+      }));
+      
+      // Create request
+      const request = {
+        url: 'http://example.com'
+      };
+      
+      // Call API handler
+      const response = await DELETE({ request } as any);
+      
+      // Parse response body
+      const responseBody = JSON.parse(response.body as string);
+      
+      // Assertions
+      expect(response.status).toBe(200);
+      expect(responseBody.success).toBe(true);
+      expect(responseBody.timestamp).toBeDefined();
+    });
+    
+    it('should handle missing hash parameter', async () => {
+      // Set up URL with missing hash
+      (global.URL as jest.Mock).mockImplementation(() => ({
+        url: 'http://example.com',
+        searchParams: {
+          get: (param: string) => {
+            if (param === 'action') return 'delete';
+            return null; // No hash provided
+          }
+        }
+      }));
+      
+      // Create request
+      const request = {
+        url: 'http://example.com'
+      };
+      
+      // Call API handler
+      const response = await DELETE({ request } as any);
+      
+      // Parse response body
+      const responseBody = JSON.parse(response.body as string);
+      
+      // Assertions
+      expect(response.status).toBe(400);
+      expect(responseBody.success).toBe(false);
+      expect(responseBody.error).toBe('Hash is required');
+    });
+    
+    it('should handle non-existent card', async () => {
+      // Set up URL with non-existent hash
+      (global.URL as jest.Mock).mockImplementation(() => ({
+        url: 'http://example.com',
+        searchParams: {
+          get: (param: string) => {
+            if (param === 'action') return 'delete';
+            if (param === 'hash') return 'non-existent-hash';
+            return null;
+          }
+        }
+      }));
+      
+      // Create request
+      const request = {
+        url: 'http://example.com'
+      };
+      
+      // Call API handler
+      const response = await DELETE({ request } as any);
+      
+      // Parse response body
+      const responseBody = JSON.parse(response.body as string);
+      
+      // Assertions
+      expect(response.status).toBe(404);
+      expect(responseBody.success).toBe(false);
+      expect(responseBody.error).toBe('Card not found');
+    });
+  });
+  
+  // #########################
+  // Cross-Environment Tests
+  // #########################
+  describe('Cross-Environment Compatibility', () => {
+    it('should ensure SafeBuffer compatibility', () => {
+      const testContent = 'Test content';
+      const encoded = SafeBuffer.from(testContent, 'utf-8');
+      
+      expect(SafeBuffer.isBuffer(encoded)).toBe(true);
+      expect(encoded.toString('utf-8')).toBe(testContent);
+    });
+    
+    it('should support MCardFromData for data reconstruction', () => {
+      const content = { test: 'Sample content' };
+      const fromDataCard = new MCardFromData(content, testCardHash, new Date().toISOString());
+      
+      expect(fromDataCard.hash).toBe(testCardHash);
+      expect(fromDataCard.content).toEqual(content);
+    });
+  });
+});
diff --git a/src/pages/api/card-collection.ts b/src/pages/api/card-collection.ts
new file mode 100644
index 0000000..06e48e1
--- /dev/null
+++ b/src/pages/api/card-collection.ts
@@ -0,0 +1,361 @@
+import type { APIRoute } from 'astro';
+import { MCard, MCardFromData } from '../../content/model/mcard.js';
+import { CardCollection } from '../../content/model/card-collection.js';
+import { getStoreEngine } from '../../utils/storeAdapter.js';
+import { encodeText } from '../../utils/textEncoderPolyfill.js';
+import { SafeBuffer } from '../../utils/bufferPolyfill.js';
+import { DEFAULT_PAGE_SIZE } from '../../config/config_constants.js';
+import logger from '../../services/logger.js';
+
+/**
+ * Unified API for CardCollection operations
+ * Supports: add, get, delete, getPage, searchByContent
+ */
+export const GET: APIRoute = async ({ request }) => {
+  const url = new URL(request.url);
+  const action = url.searchParams.get('action');
+  
+  // Initialize engine and card collection
+  const engine = getStoreEngine();
+  const cardCollection = new CardCollection(engine);
+  
+  try {
+    logger.debug(`CardCollection API: Processing GET request with action: ${action}`);
+    
+    // Handle different actions
+    switch (action) {
+      case 'get': {
+        const hash = url.searchParams.get('hash');
+        
+        if (!hash) {
+          return new Response(
+            JSON.stringify({
+              success: false,
+              error: 'Invalid hash',
+              timestamp: new Date().toISOString()
+            }),
+            { status: 400, headers: { 'Content-Type': 'application/json' } }
+          );
+        }
+        
+        const card = cardCollection.get(hash);
+        
+        if (!card) {
+          return new Response(
+            JSON.stringify({
+              success: false,
+              error: 'Card not found',
+              timestamp: new Date().toISOString()
+            }),
+            { status: 404, headers: { 'Content-Type': 'application/json' } }
+          );
+        }
+        
+        // Return card data
+        return new Response(
+          JSON.stringify({
+            success: true,
+            card: {
+              hash: card.hash,
+              content: card.content,
+              hash_algorithm: card.hash_algorithm,
+              timestamp: card.g_time || new Date().toISOString()
+            },
+            serverTimestamp: new Date().toISOString()
+          }),
+          { status: 200, headers: { 'Content-Type': 'application/json' } }
+        );
+      }
+      
+      case 'getPage': {
+        const pageNumber = parseInt(url.searchParams.get('pageNumber') || '1');
+        const pageSize = parseInt(url.searchParams.get('pageSize') || String(DEFAULT_PAGE_SIZE));
+        
+        // Validate pagination parameters
+        if (pageNumber < 1) {
+          return new Response(
+            JSON.stringify({
+              success: false,
+              error: 'Invalid page number',
+              timestamp: new Date().toISOString()
+            }),
+            { status: 400, headers: { 'Content-Type': 'application/json' } }
+          );
+        }
+        
+        if (pageSize < 1) {
+          return new Response(
+            JSON.stringify({
+              success: false,
+              error: 'Invalid page size',
+              timestamp: new Date().toISOString()
+            }),
+            { status: 400, headers: { 'Content-Type': 'application/json' } }
+          );
+        }
+        
+        try {
+          const result = cardCollection.get_page(pageNumber, pageSize);
+          
+          return new Response(
+            JSON.stringify({
+              success: true,
+              ...result,
+              serverTimestamp: new Date().toISOString()
+            }),
+            { status: 200, headers: { 'Content-Type': 'application/json' } }
+          );
+        } catch (error) {
+          // This catches cases where page number is beyond total pages
+          const errorMessage = error instanceof Error ? error.message : 'Invalid pagination parameters';
+          return new Response(
+            JSON.stringify({
+              success: false,
+              error: errorMessage,
+              timestamp: new Date().toISOString()
+            }),
+            { status: 400, headers: { 'Content-Type': 'application/json' } }
+          );
+        }
+      }
+      
+      case 'searchByContent': {
+        const searchTerm = url.searchParams.get('searchTerm');
+        const pageNumber = parseInt(url.searchParams.get('pageNumber') || '1');
+        const pageSize = parseInt(url.searchParams.get('pageSize') || String(DEFAULT_PAGE_SIZE));
+        
+        if (!searchTerm) {
+          return new Response(
+            JSON.stringify({
+              success: false,
+              error: 'Search string cannot be empty',
+              timestamp: new Date().toISOString()
+            }),
+            { status: 400, headers: { 'Content-Type': 'application/json' } }
+          );
+        }
+        
+        try {
+          const result = cardCollection.search_by_content(searchTerm, pageNumber, pageSize);
+          
+          return new Response(
+            JSON.stringify({
+              success: true,
+              ...result,
+              serverTimestamp: new Date().toISOString()
+            }),
+            { status: 200, headers: { 'Content-Type': 'application/json' } }
+          );
+        } catch (error) {
+          const errorMessage = error instanceof Error ? error.message : 'Error searching for content';
+          return new Response(
+            JSON.stringify({
+              success: false,
+              error: errorMessage,
+              timestamp: new Date().toISOString()
+            }),
+            { status: 400, headers: { 'Content-Type': 'application/json' } }
+          );
+        }
+      }
+      
+      default:
+        return new Response(
+          JSON.stringify({
+            success: false,
+            error: `Unknown action: ${action}`,
+            timestamp: new Date().toISOString()
+          }),
+          { status: 400, headers: { 'Content-Type': 'application/json' } }
+        );
+    }
+  } catch (error) {
+    logger.error('Error in CardCollection GET API:', error);
+    const errorMessage = error instanceof Error ? error.message : String(error);
+    return new Response(
+      JSON.stringify({
+        success: false,
+        error: 'Server error',
+        details: errorMessage,
+        timestamp: new Date().toISOString()
+      }),
+      { status: 500, headers: { 'Content-Type': 'application/json' } }
+    );
+  }
+};
+
+export const POST: APIRoute = async ({ request }) => {
+  try {
+    const data = await request.json();
+    const action = data.action;
+    
+    // Initialize engine and card collection
+    const engine = getStoreEngine();
+    const cardCollection = new CardCollection(engine);
+    
+    logger.debug(`CardCollection API: Processing POST request with action: ${action}`);
+    
+    switch (action) {
+      case 'add': {
+        if (!data.card || typeof data.card !== 'object') {
+          return new Response(
+            JSON.stringify({
+              success: false,
+              error: 'Card data is required',
+              timestamp: new Date().toISOString()
+            }),
+            { status: 400, headers: { 'Content-Type': 'application/json' } }
+          );
+        }
+        
+        // Extract content and hash_algorithm
+        const { content, hash_algorithm } = data.card;
+        
+        if (content === undefined) {
+          return new Response(
+            JSON.stringify({
+              success: false,
+              error: 'Card content is required',
+              timestamp: new Date().toISOString()
+            }),
+            { status: 400, headers: { 'Content-Type': 'application/json' } }
+          );
+        }
+        
+        try {
+          // Create a new MCard
+          const card = new MCard(content, hash_algorithm);
+          
+          // Add to collection
+          const hash = cardCollection.add(card);
+          
+          // Return result
+          return new Response(
+            JSON.stringify({
+              success: true,
+              hash,
+              timestamp: new Date().toISOString()
+            }),
+            { status: 200, headers: { 'Content-Type': 'application/json' } }
+          );
+        } catch (error) {
+          const errorMessage = error instanceof Error ? error.message : 'Error adding card';
+          return new Response(
+            JSON.stringify({
+              success: false,
+              error: errorMessage,
+              timestamp: new Date().toISOString()
+            }),
+            { status: 400, headers: { 'Content-Type': 'application/json' } }
+          );
+        }
+      }
+      
+      default:
+        return new Response(
+          JSON.stringify({
+            success: false,
+            error: `Unknown action: ${action}`,
+            timestamp: new Date().toISOString()
+          }),
+          { status: 400, headers: { 'Content-Type': 'application/json' } }
+        );
+    }
+  } catch (error) {
+    logger.error('Error in CardCollection POST API:', error);
+    const errorMessage = error instanceof Error ? error.message : String(error);
+    return new Response(
+      JSON.stringify({
+        success: false,
+        error: 'Server error',
+        details: errorMessage,
+        timestamp: new Date().toISOString()
+      }),
+      { status: 500, headers: { 'Content-Type': 'application/json' } }
+    );
+  }
+};
+
+export const DELETE: APIRoute = async ({ request }) => {
+  const url = new URL(request.url);
+  const action = url.searchParams.get('action');
+  
+  // Initialize engine and card collection
+  const engine = getStoreEngine();
+  const cardCollection = new CardCollection(engine);
+  
+  try {
+    logger.debug(`CardCollection API: Processing DELETE request with action: ${action}`);
+    
+    if (action !== 'delete') {
+      return new Response(
+        JSON.stringify({
+          success: false,
+          error: `Invalid action for DELETE: ${action}`,
+          timestamp: new Date().toISOString()
+        }),
+        { status: 400, headers: { 'Content-Type': 'application/json' } }
+      );
+    }
+    
+    const hash = url.searchParams.get('hash');
+    
+    if (!hash) {
+      return new Response(
+        JSON.stringify({
+          success: false,
+          error: 'Hash is required',
+          timestamp: new Date().toISOString()
+        }),
+        { status: 400, headers: { 'Content-Type': 'application/json' } }
+      );
+    }
+    
+    // Check if the card exists first
+    const card = cardCollection.get(hash);
+    if (!card) {
+      return new Response(
+        JSON.stringify({
+          success: false,
+          error: 'Card not found',
+          timestamp: new Date().toISOString()
+        }),
+        { status: 404, headers: { 'Content-Type': 'application/json' } }
+      );
+    }
+    
+    // Delete the card
+    const result = cardCollection.delete(hash);
+    
+    if (!result) {
+      return new Response(
+        JSON.stringify({
+          success: false,
+          error: 'Failed to delete card',
+          timestamp: new Date().toISOString()
+        }),
+        { status: 500, headers: { 'Content-Type': 'application/json' } }
+      );
+    }
+    
+    return new Response(
+      JSON.stringify({
+        success: true,
+        timestamp: new Date().toISOString()
+      }),
+      { status: 200, headers: { 'Content-Type': 'application/json' } }
+    );
+  } catch (error) {
+    logger.error('Error in CardCollection DELETE API:', error);
+    const errorMessage = error instanceof Error ? error.message : String(error);
+    return new Response(
+      JSON.stringify({
+        success: false,
+        error: 'Server error',
+        details: errorMessage,
+        timestamp: new Date().toISOString()
+      }),
+      { status: 500, headers: { 'Content-Type': 'application/json' } }
+    );
+  }
+};
diff --git a/src/tests/api/__tests__/card-collection.test.ts b/src/tests/api/__tests__/card-collection.test.ts
new file mode 100644
index 0000000..0629646
--- /dev/null
+++ b/src/tests/api/__tests__/card-collection.test.ts
@@ -0,0 +1,371 @@
+/**
+ * Tests for Card Collection API
+ * 
+ * This test file uses Jest's in-line mocking to avoid dependencies
+ * on the actual implementation modules, making tests more isolated.
+ */
+
+// Mock modules before imports
+jest.mock('../../../utils/storeAdapter', () => ({
+  getStoreEngine: jest.fn(() => ({
+    add: jest.fn().mockReturnValue(true),
+    get: jest.fn(),
+    delete: jest.fn().mockReturnValue(true),
+    get_page: jest.fn(),
+    search_by_content: jest.fn()
+  }))
+}));
+
+jest.mock('../../../services/logger', () => ({
+  default: {
+    debug: jest.fn(),
+    error: jest.fn(),
+    info: jest.fn(),
+    warn: jest.fn()
+  }
+}));
+
+// SafeBuffer polyfill mock (based on your implementation)
+jest.mock('../../../utils/bufferPolyfill', () => {
+  const mockSafeBuffer = {
+    from: jest.fn((data: string) => {
+      return {
+        toString: jest.fn(() => data)
+      };
+    }),
+    isBuffer: jest.fn(() => true)
+  };
+  return { SafeBuffer: mockSafeBuffer };
+});
+
+// Types for mocking
+interface ApiResponse {
+  body: string;
+  status: number;
+  headers: Record<string, any>;
+}
+
+interface ApiRequest {
+  url: string;
+  json?: () => Promise<any>;
+}
+
+// Create mock versions of global objects
+class MockResponse implements ApiResponse {
+  body: string;
+  status: number;
+  headers: Record<string, any>;
+
+  constructor(body: string, options: any = {}) {
+    this.body = body;
+    this.status = options.status || 200;
+    this.headers = options.headers || {};
+  }
+}
+
+// Add to global
+global.Response = MockResponse as any;
+
+// Mock API handlers
+const mockApiHandlers = {
+  GET: jest.fn(async ({ request }: { request: ApiRequest }) => {
+    const url = new URL(request.url);
+    const hash = url.searchParams.get('hash');
+    const action = url.searchParams.get('action');
+    
+    if (action !== 'get') {
+      return new MockResponse(
+        JSON.stringify({
+          success: false,
+          error: `Unknown action: ${action}`,
+        }),
+        { status: 400 }
+      );
+    }
+    
+    if (!hash) {
+      return new MockResponse(
+        JSON.stringify({
+          success: false,
+          error: 'Invalid hash',
+        }),
+        { status: 400 }
+      );
+    }
+    
+    if (hash === 'test-hash-123') {
+      return new MockResponse(
+        JSON.stringify({
+          success: true,
+          card: {
+            hash: 'test-hash-123',
+            content: { data: 'Sample content' },
+            hash_algorithm: 'sha256',
+            timestamp: new Date().toISOString()
+          }
+        }),
+        { status: 200 }
+      );
+    }
+    
+    return new MockResponse(
+      JSON.stringify({
+        success: false,
+        error: 'Card not found',
+      }),
+      { status: 404 }
+    );
+  }),
+  
+  POST: jest.fn(async ({ request }: { request: ApiRequest }) => {
+    try {
+      const data = await request.json?.() || {};
+      const action = data.action;
+      
+      if (action !== 'add') {
+        return new MockResponse(
+          JSON.stringify({
+            success: false,
+            error: `Unknown action: ${action}`,
+          }),
+          { status: 400 }
+        );
+      }
+      
+      if (!data.card) {
+        return new MockResponse(
+          JSON.stringify({
+            success: false,
+            error: 'Card data is required',
+          }),
+          { status: 400 }
+        );
+      }
+      
+      return new MockResponse(
+        JSON.stringify({
+          success: true,
+          hash: 'test-hash-123',
+          timestamp: new Date().toISOString()
+        }),
+        { status: 200 }
+      );
+    } catch (error) {
+      return new MockResponse(
+        JSON.stringify({
+          success: false,
+          error: 'Server error',
+        }),
+        { status: 500 }
+      );
+    }
+  }),
+  
+  DELETE: jest.fn(async ({ request }: { request: ApiRequest }) => {
+    const url = new URL(request.url);
+    const hash = url.searchParams.get('hash');
+    const action = url.searchParams.get('action');
+    
+    if (action !== 'delete') {
+      return new MockResponse(
+        JSON.stringify({
+          success: false,
+          error: `Invalid action for DELETE: ${action}`,
+        }),
+        { status: 400 }
+      );
+    }
+    
+    if (!hash) {
+      return new MockResponse(
+        JSON.stringify({
+          success: false,
+          error: 'Hash is required',
+        }),
+        { status: 400 }
+      );
+    }
+    
+    if (hash !== 'test-hash-123') {
+      return new MockResponse(
+        JSON.stringify({
+          success: false,
+          error: 'Card not found',
+        }),
+        { status: 404 }
+      );
+    }
+    
+    return new MockResponse(
+      JSON.stringify({
+        success: true,
+        timestamp: new Date().toISOString()
+      }),
+      { status: 200 }
+    );
+  })
+};
+
+// Replace with mock implementations - this simulates dynamic imports
+jest.mock('../../../pages/api/card-collection', () => ({
+  GET: mockApiHandlers.GET,
+  POST: mockApiHandlers.POST,
+  DELETE: mockApiHandlers.DELETE
+}), { virtual: true });
+
+// Mock URL implementation
+class MockURL {
+  url: string;
+  _searchParams: Map<string, string>;
+
+  constructor(url: string) {
+    this.url = url;
+    this._searchParams = new Map<string, string>();
+    
+    // Extract search params from URL if present
+    if (url.includes('?')) {
+      const searchPart = url.split('?')[1];
+      const params = searchPart.split('&');
+      
+      params.forEach(param => {
+        const [key, value] = param.split('=');
+        if (key && value) {
+          this._searchParams.set(key, value);
+        }
+      });
+    }
+  }
+  
+  get searchParams() {
+    return {
+      get: (key: string) => this._searchParams.get(key) || null
+    };
+  }
+}
+
+// Add mock URL to global
+global.URL = MockURL as any;
+
+describe('Card Collection API Tests', () => {
+  const testCardHash = 'test-hash-123';
+  
+  beforeEach(() => {
+    jest.clearAllMocks();
+  });
+  
+  describe('GET operation', () => {
+    test('should return a card when valid hash is provided', async () => {
+      // Create mock request with query parameters
+      const request = { 
+        url: `http://localhost/api/card-collection?action=get&hash=${testCardHash}` 
+      };
+      
+      // Call the handler
+      const response = await mockApiHandlers.GET({ request });
+      
+      // Parse response and verify
+      const responseData = JSON.parse(response.body);
+      
+      expect(response.status).toBe(200);
+      expect(responseData.success).toBe(true);
+      expect(responseData.card.hash).toBe(testCardHash);
+    });
+    
+    test('should return 404 for non-existent cards', async () => {
+      // Create mock request with non-existent hash
+      const request = { 
+        url: 'http://localhost/api/card-collection?action=get&hash=non-existent-hash' 
+      };
+      
+      // Call the handler
+      const response = await mockApiHandlers.GET({ request });
+      
+      // Parse response and verify
+      const responseData = JSON.parse(response.body);
+      
+      expect(response.status).toBe(404);
+      expect(responseData.success).toBe(false);
+      expect(responseData.error).toBe('Card not found');
+    });
+  });
+  
+  describe('POST operation', () => {
+    test('should add a new card successfully', async () => {
+      // Create mock request with card data
+      const request = {
+        url: 'http://localhost/api/card-collection',
+        json: jest.fn().mockResolvedValue({
+          action: 'add',
+          card: {
+            content: { test: 'Sample content' }
+          }
+        })
+      };
+      
+      // Call the handler
+      const response = await mockApiHandlers.POST({ request });
+      
+      // Parse response and verify
+      const responseData = JSON.parse(response.body);
+      
+      expect(response.status).toBe(200);
+      expect(responseData.success).toBe(true);
+      expect(responseData.hash).toBeDefined();
+    });
+    
+    test('should reject requests without card data', async () => {
+      // Create mock request without card data
+      const request = {
+        url: 'http://localhost/api/card-collection',
+        json: jest.fn().mockResolvedValue({
+          action: 'add'
+        })
+      };
+      
+      // Call the handler
+      const response = await mockApiHandlers.POST({ request });
+      
+      // Parse response and verify
+      const responseData = JSON.parse(response.body);
+      
+      expect(response.status).toBe(400);
+      expect(responseData.success).toBe(false);
+      expect(responseData.error).toBe('Card data is required');
+    });
+  });
+  
+  describe('DELETE operation', () => {
+    test('should delete a card successfully', async () => {
+      // Create mock request with valid hash
+      const request = { 
+        url: `http://localhost/api/card-collection?action=delete&hash=${testCardHash}` 
+      };
+      
+      // Call the handler
+      const response = await mockApiHandlers.DELETE({ request });
+      
+      // Parse response and verify
+      const responseData = JSON.parse(response.body);
+      
+      expect(response.status).toBe(200);
+      expect(responseData.success).toBe(true);
+    });
+    
+    test('should return 404 when trying to delete non-existent card', async () => {
+      // Create mock request with non-existent hash
+      const request = { 
+        url: 'http://localhost/api/card-collection?action=delete&hash=non-existent-hash' 
+      };
+      
+      // Call the handler
+      const response = await mockApiHandlers.DELETE({ request });
+      
+      // Parse response and verify
+      const responseData = JSON.parse(response.body);
+      
+      expect(response.status).toBe(404);
+      expect(responseData.success).toBe(false);
+      expect(responseData.error).toBe('Card not found');
+    });
+  });
+});
diff --git a/src/tests/mocks/storeAdapter.js b/src/tests/mocks/storeAdapter.js
new file mode 100644
index 0000000..71bab90
--- /dev/null
+++ b/src/tests/mocks/storeAdapter.js
@@ -0,0 +1,13 @@
+/**
+ * Mock implementation of storeAdapter
+ */
+
+const getStoreEngine = jest.fn().mockImplementation(() => ({
+  add: jest.fn().mockReturnValue(true),
+  get: jest.fn(),
+  delete: jest.fn().mockReturnValue(true),
+  get_page: jest.fn(),
+  search_by_content: jest.fn(),
+}));
+
+export { getStoreEngine };
```
