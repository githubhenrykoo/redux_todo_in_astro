# Git Activity Log - Henry Koo
Generated at: Wed Apr  9 00:43:07 UTC 2025
## Changes by Henry Koo
```diff
commit 654ab41a06f0c2c499e17b786d662c3389f929a4
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Wed Apr 9 05:47:27 2025 +0800

    video downloader

diff --git a/src/components/panels/catalog/DetailView.jsx b/src/components/panels/catalog/DetailView.jsx
index 0e5355a..ce7f4e2 100644
--- a/src/components/panels/catalog/DetailView.jsx
+++ b/src/components/panels/catalog/DetailView.jsx
@@ -2,6 +2,8 @@ import React, { useState, useEffect, useRef } from 'react';
 import { getSimpleContentType, getContentTypeDisplay } from './utils';
 import { ContentService } from '../../../services/content-service';
 import { processContent, isImageType } from '../../../utils/content-utils';
+import VideoPlayer from '../../viewers/VideoPlayer';
+import '../../viewers/video-player.css';
 import './detail-view.css';
 
 /**
@@ -290,16 +292,15 @@ const DetailView = ({
           </audio>
         </ContentWrapper>
       );
-    } else if (contentType.mimeType?.startsWith('video/')) {
+    } else if (contentType.mimeType.startsWith('video/') || contentType.mimeType === 'video/quicktime') {
+      // Use our new VideoPlayer component for video content
       return (
         <ContentWrapper className="video-wrapper">
-          <video controls className="content-video">
-            <source 
-              src={`/api/card-collection?action=get&hash=${selectedItem.hash}`} 
-              type={contentType.mimeType} 
-            />
-            Your browser does not support the video element.
-          </video>
+          <VideoPlayer 
+            hash={selectedItem.hash} 
+            contentType={contentType.mimeType} 
+            content={selectedItem.content}
+          />
         </ContentWrapper>
       );
     } else if (contentType.mimeType === 'text/html') {
diff --git a/src/components/viewers/VideoPlayer.jsx b/src/components/viewers/VideoPlayer.jsx
new file mode 100644
index 0000000..57a2488
--- /dev/null
+++ b/src/components/viewers/VideoPlayer.jsx
@@ -0,0 +1,199 @@
+import React, { useState, useEffect, useRef } from 'react';
+import { ContentService } from '../../services/content-service';
+
+/**
+ * VideoPlayer component for handling various video formats including QuickTime
+ * Uses our content service to properly process binary video data
+ */
+const VideoPlayer = ({ content, contentType, hash }) => {
+  const [videoUrl, setVideoUrl] = useState(null);
+  const [loading, setLoading] = useState(true);
+  const [error, setError] = useState(null);
+  const [retry, setRetry] = useState(0);
+  const [downloadUrl, setDownloadUrl] = useState(null);
+  const [isQuickTime, setIsQuickTime] = useState(false);
+  const videoRef = useRef(null);
+  
+  useEffect(() => {
+    setLoading(true);
+    setError(null);
+    setDownloadUrl(null);
+    
+    if (!content && !hash) {
+      setError('No video content or hash provided');
+      setLoading(false);
+      return;
+    }
+    
+    const loadVideo = async () => {
+      try {
+        // If we already have content, process it directly
+        if (content) {
+          processVideoContent(content);
+        } 
+        // Otherwise, fetch content using the hash
+        else if (hash) {
+          const result = await ContentService.fetchContent(hash);
+          if (result.error) {
+            throw new Error(result.error);
+          }
+          
+          if (result.raw?.content) {
+            processVideoContent(result.raw.content, result.raw.contentType || contentType);
+          } else {
+            throw new Error('No video content found in response');
+          }
+        }
+      } catch (err) {
+        console.error('Error loading video:', err);
+        setError(`Failed to load video: ${err.message}`);
+        setLoading(false);
+      }
+    };
+    
+    const processVideoContent = (videoContent, vidContentType = contentType) => {
+      // Check if this is a QuickTime video
+      const isQuickTimeVideo = 
+        (vidContentType?.mimeType?.includes('quicktime') || 
+         vidContentType?.extension?.toLowerCase() === 'mov' ||
+         (typeof vidContentType === 'string' && (
+           vidContentType.includes('quicktime') || 
+           vidContentType.includes('mov')
+         )));
+      
+      setIsQuickTime(isQuickTimeVideo);
+      
+      // For Buffer JSON content
+      if (videoContent && videoContent.type === 'Buffer' && Array.isArray(videoContent.data)) {
+        try {
+          const array = new Uint8Array(videoContent.data);
+          
+          // Always create download URL for QuickTime videos as a fallback
+          if (isQuickTimeVideo) {
+            const blob = new Blob([array], { type: 'video/quicktime' });
+            const downloadUrl = URL.createObjectURL(blob);
+            setDownloadUrl(downloadUrl);
+          }
+          
+          const url = ContentService.getDataUrl({ 
+            content: videoContent, 
+            contentType: vidContentType 
+          });
+          
+          if (url) {
+            setVideoUrl(url);
+            setLoading(false);
+          } else {
+            throw new Error('Failed to create data URL for video');
+          }
+        } catch (err) {
+          console.error('Error processing video buffer:', err);
+          setError('Unable to process video data');
+          setLoading(false);
+        }
+      }
+      // For already processed content
+      else if (videoContent && typeof videoContent === 'string' && 
+              (videoContent.startsWith('data:') || videoContent.startsWith('blob:'))) {
+        setVideoUrl(videoContent);
+        setDownloadUrl(videoContent);
+        setLoading(false);
+      } 
+      // For unknown content format
+      else {
+        console.error('Unsupported video content format:', typeof videoContent);
+        setError('Unsupported video format');
+        setLoading(false);
+      }
+    };
+    
+    loadVideo();
+    
+    // Cleanup function
+    return () => {
+      if (videoUrl && videoUrl.startsWith('blob:')) {
+        URL.revokeObjectURL(videoUrl);
+      }
+      if (downloadUrl && downloadUrl.startsWith('blob:')) {
+        URL.revokeObjectURL(downloadUrl);
+      }
+    };
+  }, [content, contentType, hash, retry]);
+  
+  // Handle video playback errors
+  const handleVideoError = (e) => {
+    console.error('Video playback error:', e);
+    
+    if (isQuickTime) {
+      setError('This QuickTime video could not be played in the browser. The format may not be supported by your browser.');
+    } else {
+      setError('Error playing video. The format may not be supported by your browser.');
+    }
+  };
+  
+  if (loading) {
+    return (
+      <div className="video-loading">
+        <div className="spinner"></div>
+        <p>Loading video...</p>
+      </div>
+    );
+  }
+  
+  if (error) {
+    return (
+      <div className="video-error">
+        <p>{error}</p>
+        {isQuickTime && downloadUrl && (
+          <div className="mt-4">
+            <p className="text-sm mt-2">QuickTime videos require specific codecs which may not be available in all browsers.</p>
+            <a 
+              href={downloadUrl} 
+              download={`video-${Date.now()}.mov`}
+              className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 inline-block mt-2"
+            >
+              Download Video File
+            </a>
+            <p className="text-xs mt-2">You can download the file and play it in a media player that supports QuickTime format.</p>
+          </div>
+        )}
+        <button 
+          className="btn btn-small mt-3" 
+          onClick={() => setRetry(prev => prev + 1)}
+        >
+          Retry
+        </button>
+      </div>
+    );
+  }
+  
+  return (
+    <div className="video-container">
+      <video 
+        ref={videoRef}
+        src={videoUrl}
+        controls
+        autoPlay={false}
+        className="video-player"
+        onError={handleVideoError}
+      >
+        Your browser does not support the video tag.
+      </video>
+      
+      {isQuickTime && downloadUrl && (
+        <div className="download-button-container mt-2">
+          <a 
+            href={downloadUrl} 
+            download={`video-${Date.now()}.mov`}
+            className="download-button"
+            title="Download video file"
+          >
+            ‚¨áÔ∏è Download
+          </a>
+        </div>
+      )}
+    </div>
+  );
+};
+
+export default VideoPlayer;
diff --git a/src/components/viewers/video-player.css b/src/components/viewers/video-player.css
new file mode 100644
index 0000000..6b0d8f0
--- /dev/null
+++ b/src/components/viewers/video-player.css
@@ -0,0 +1,93 @@
+/* Video Player Component Styles */
+
+.video-container {
+  width: 100%;
+  position: relative;
+  background-color: #000;
+  border-radius: 4px;
+  overflow: hidden;
+  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
+  margin-bottom: 16px;
+}
+
+.video-player {
+  width: 100%;
+  max-height: 70vh;
+  display: block;
+  background-color: #000;
+}
+
+.video-loading,
+.video-error {
+  display: flex;
+  flex-direction: column;
+  align-items: center;
+  justify-content: center;
+  min-height: 300px;
+  background-color: #1a1a1a;
+  color: #fff;
+  border-radius: 4px;
+  padding: 20px;
+  text-align: center;
+}
+
+.video-error {
+  background-color: rgba(220, 53, 69, 0.1);
+  color: #dc3545;
+  border: 1px solid rgba(220, 53, 69, 0.3);
+}
+
+.video-error button {
+  margin-top: 15px;
+  padding: 8px 16px;
+  background-color: #007bff;
+  color: white;
+  border: none;
+  border-radius: 4px;
+  cursor: pointer;
+  font-weight: 500;
+}
+
+.video-error button:hover {
+  background-color: #0069d9;
+}
+
+.spinner {
+  border: 4px solid rgba(255, 255, 255, 0.3);
+  border-radius: 50%;
+  border-top: 4px solid #fff;
+  width: 40px;
+  height: 40px;
+  animation: spin 1s linear infinite;
+  margin-bottom: 15px;
+}
+
+@keyframes spin {
+  0% { transform: rotate(0deg); }
+  100% { transform: rotate(360deg); }
+}
+
+/* Video controls customization */
+video::-webkit-media-controls {
+  background-color: rgba(0, 0, 0, 0.5);
+}
+
+video::-webkit-media-controls-play-button {
+  color: white;
+}
+
+.video-info {
+  background-color: rgba(0, 0, 0, 0.8);
+  color: white;
+  padding: 8px 12px;
+  font-size: 12px;
+  position: absolute;
+  bottom: 40px;
+  right: 0;
+  border-radius: 4px 0 0 0;
+}
+
+.video-type {
+  font-weight: bold;
+  margin-right: 8px;
+}

commit 3d96114889afcc1210cfc5192c4c595f6a9934cc
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Wed Apr 9 05:08:03 2025 +0800

    better layout design

diff --git a/src/components/panels/catalog/GridView.jsx b/src/components/panels/catalog/GridView.jsx
index 49745b6..389aa68 100644
--- a/src/components/panels/catalog/GridView.jsx
+++ b/src/components/panels/catalog/GridView.jsx
@@ -207,16 +207,25 @@ const GridView = ({
                   <GridItemPreview item={displayItem} />
                 </div>
                 <div className="grid-item-info">
-                  <h3 className="grid-item-title">{item.name}</h3>
+                  <h3 className="grid-item-title" style={{ color: '#000000', fontWeight: 'bold' }}>
+                    {item.id.substring(0, 8)}
+                  </h3>
                   <div className="grid-item-meta">
-                    <span className="grid-item-type">
+                    <span className="grid-item-type" style={{ 
+                      color: '#000000', 
+                      fontWeight: 'bold',
+                      backgroundColor: '#ffffff',
+                      border: '1px solid #000000'
+                    }}>
                       {getFormattedContentType(displayItem)}
                     </span>
-                    <span className="grid-item-date">
+                    <span className="grid-item-date" style={{ color: '#000000', fontWeight: 'bold' }}>
                       {new Date(item.timestamp).toLocaleDateString()}
                     </span>
                   </div>
-                  <p className="grid-item-description">{item.description}</p>
+                  <p className="grid-item-description" style={{ color: '#000000', fontWeight: 'medium' }}>
+                    {item.description || "No description available"}
+                  </p>
                 </div>
                 <div className={`grid-item-actions ${hoveredItem === item.id ? 'visible' : ''}`}>
                   <button 

commit 24c2dbcaebd269c13235094f36fd497351512af3
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Wed Apr 9 05:06:19 2025 +0800

    better image viewer

diff --git a/src/components/panels/catalog/GridItemPreview.jsx b/src/components/panels/catalog/GridItemPreview.jsx
index 9891bf0..90931f9 100644
--- a/src/components/panels/catalog/GridItemPreview.jsx
+++ b/src/components/panels/catalog/GridItemPreview.jsx
@@ -153,7 +153,7 @@ const GridItemPreview = ({ item }) => {
           </div>
         ) : (
           <>
-            <div className="text-preview-content">
+            <div className="high-contrast-text">
               <pre>{textPreview}</pre>
             </div>
             <div className="text-type-label">
diff --git a/src/components/panels/catalog/grid-item-preview.css b/src/components/panels/catalog/grid-item-preview.css
index 697e5a8..ae809cc 100644
--- a/src/components/panels/catalog/grid-item-preview.css
+++ b/src/components/panels/catalog/grid-item-preview.css
@@ -27,6 +27,8 @@
   transition: all 0.3s ease;
   height: 100%;
   border: 1px solid #e0e0e0;
+  color: #000000 !important;
+  font-weight: 500 !important;
 }
 
 .grid-item-card.hovered {
@@ -49,6 +51,8 @@
   flex-grow: 1;
   display: flex;
   flex-direction: column;
+  color: #000000 !important;
+  font-weight: 500 !important;
 }
 
 .grid-item-title {
@@ -73,10 +77,18 @@
   padding: 2px 6px;
   border-radius: 4px;
   font-weight: 500;
+  color: #000000 !important;
+  font-weight: bold !important;
+  background-color: rgba(255, 255, 255, 0.9) !important;
+  padding: 2px 6px !important;
+  border: 1px solid #000000 !important;
+  border-radius: 4px !important;
 }
 
 .grid-item-date {
   color: #888;
+  color: #000000 !important;
+  font-weight: 500 !important;
 }
 
 .grid-item-description {
@@ -89,6 +101,8 @@
   line-clamp: 2;
   -webkit-box-orient: vertical;
   flex-grow: 1;
+  color: #000000 !important;
+  font-weight: 500 !important;
 }
 
 .grid-item-actions {
@@ -254,22 +268,23 @@
   flex-direction: column;
   height: 100%;
   width: 100%;
-  background-color: #f8f9fa;
+  background-color: #ffffff;
   border-radius: 4px;
   overflow: hidden;
   position: relative;
+  border: 1px solid #cccccc;
 }
 
 .text-preview-content {
   padding: 12px;
   overflow: hidden;
   flex-grow: 1;
-  background-color: #fff;
-  border: 1px solid #e0e0e0;
+  background-color: #ffffff;
+  border: 1px solid #cccccc;
   border-radius: 4px;
   font-family: 'Courier New', monospace;
-  font-size: 12px;
-  line-height: 1.4;
+  font-size: 13px;
+  line-height: 1.5;
   max-height: 140px;
 }
 
@@ -282,14 +297,15 @@
   -webkit-line-clamp: 6;
   line-clamp: 6;
   -webkit-box-orient: vertical;
-  color: #333;
+  color: #000000;
+  font-weight: 500;
 }
 
 .text-type-label {
-  padding: 4px 8px;
-  font-size: 10px;
-  background-color: #e9ecef;
-  color: #495057;
+  padding: 6px 8px;
+  font-size: 11px;
+  background-color: #007bff;
+  color: #ffffff;
   text-align: center;
   border-top: 1px solid #dee2e6;
   position: absolute;
@@ -298,6 +314,36 @@
   font-weight: 500;
 }
 
+/* High contrast text styling for previews */
+.high-contrast-text {
+  background-color: #FFFFFF !important;
+  color: #000000 !important;
+  font-weight: bold !important;
+  font-size: 15px !important;
+  line-height: 1.6 !important;
+  text-shadow: none !important;
+  border: 2px solid #000000 !important;
+  padding: 10px !important;
+  font-family: 'Courier New', monospace !important;
+  box-shadow: none !important;
+  border-radius: 0 !important;
+}
+
+.high-contrast-text pre {
+  color: #000000 !important;
+  white-space: pre-wrap !important;
+  word-break: break-word !important;
+  font-weight: 600 !important;
+  margin: 0 !important;
+}
+
+.text-preview-content {
+  padding: 0 !important;
+  border: none !important;
+  margin: 0 !important;
+  background-color: #FFFFFF !important;
+}
+
 /* Loading indicator */
 .loading-indicator {
   display: flex;

commit 4daf872c2a5159409b7daa047f26f52898798cb0
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Wed Apr 9 05:02:11 2025 +0800

    breview

diff --git a/Docs/to-do-plan b/Docs/to-do-plan
index 261858e..b7b5cfa 160000
--- a/Docs/to-do-plan
+++ b/Docs/to-do-plan
@@ -1 +1 @@
-Subproject commit 261858e11e6d1f9258f2fdd4ed37fd9591946075
+Subproject commit b7b5cfa2a5144b55f7a6452695d06d676d019cbb
diff --git a/src/components/panels/catalog/GridItemPreview.jsx b/src/components/panels/catalog/GridItemPreview.jsx
index 1812bb2..9891bf0 100644
--- a/src/components/panels/catalog/GridItemPreview.jsx
+++ b/src/components/panels/catalog/GridItemPreview.jsx
@@ -11,17 +11,23 @@ const GridItemPreview = ({ item }) => {
   const [imageLoaded, setImageLoaded] = useState(false);
   const [imageError, setImageError] = useState(false);
   const [dataUrl, setDataUrl] = useState(null);
+  const [textPreview, setTextPreview] = useState(null);
+  const [loading, setLoading] = useState(false);
   const contentType = item.contentType?.mimeType || 'unknown';
   
-  // Preload image for image content types
+  // Process content based on type
   useEffect(() => {
+    setLoading(true);
+    
     if (isImageType(item.contentType)) {
+      // Handle image content
       setImageLoaded(false);
       setImageError(false);
       
       // Use ContentService to fetch and process content
       ContentService.fetchContent(item.hash, { maxRetries: 1 })
         .then(result => {
+          setLoading(false);
           if (result.error) {
             console.error(`Error loading preview for ${item.hash}:`, result.error);
             setImageError(true);
@@ -46,10 +52,63 @@ const GridItemPreview = ({ item }) => {
         .catch(error => {
           console.error("Error loading preview image:", error);
           setImageError(true);
+          setLoading(false);
+        });
+    } else if (contentType.startsWith('text/') || 
+               contentType === 'application/json' || 
+               contentType === 'application/xml') {
+      // Handle text content (including CSV)
+      ContentService.fetchContent(item.hash, { maxRetries: 1 })
+        .then(result => {
+          setLoading(false);
+          if (result.error) {
+            console.error(`Error loading text preview for ${item.hash}:`, result.error);
+            return;
+          }
+          
+          // For text content, extract a preview
+          if (result.processed && result.processed.type === 'text') {
+            // Get first few lines for preview
+            const previewText = extractTextPreview(result.processed.data);
+            setTextPreview(previewText);
+          } else if (result.raw?.content) {
+            // Try to extract text from raw content
+            let textContent = '';
+            
+            if (typeof result.raw.content === 'string') {
+              textContent = result.raw.content;
+            } else if (result.raw.content.type === 'Buffer') {
+              // Convert buffer to text
+              try {
+                const decoder = new TextDecoder('utf-8');
+                textContent = decoder.decode(new Uint8Array(result.raw.content.data));
+              } catch (err) {
+                console.error('Error decoding buffer:', err);
+              }
+            }
+            
+            const previewText = extractTextPreview(textContent);
+            setTextPreview(previewText);
+          }
+        })
+        .catch(error => {
+          console.error("Error loading text preview:", error);
+          setLoading(false);
         });
+    } else {
+      setLoading(false);
     }
   }, [item.hash, contentType, item.contentType]);
   
+  // Extract a short preview from text content
+  const extractTextPreview = (text) => {
+    if (!text) return '';
+    
+    // Get up to 3 lines, limited to 100 chars per line
+    const lines = text.split('\n').slice(0, 3);
+    return lines.map(line => line.trim().substring(0, 100)).join('\n');
+  };
+  
   // Image previews
   if (contentType.startsWith('image/')) {
     if (imageError) {
@@ -64,7 +123,7 @@ const GridItemPreview = ({ item }) => {
     
     return (
       <div className="grid-item-preview image-preview">
-        {!imageLoaded && (
+        {loading && (
           <div className="loading-indicator">
             <i className="fa fa-spinner fa-spin" />
           </div>
@@ -81,90 +140,50 @@ const GridItemPreview = ({ item }) => {
     );
   }
   
-  // Video previews with thumbnail
-  if (contentType.startsWith('video/')) {
-    return (
-      <div className="grid-item-preview video-preview">
-        <div className="video-thumbnail">
-          <span className="play-icon">‚ñ∂</span>
-          <img 
-            src={`/api/card-collection?action=getThumbnail&hash=${item.id}`} 
-            alt={`${item.name} (video)`}
-            onError={(e) => {
-              e.target.onerror = null;
-              e.target.src = "https://placehold.co/300x300?text=Video";
-            }}
-          />
-        </div>
-      </div>
-    );
-  }
-  
-  // Audio previews with waveform visualization or icon
-  if (contentType.startsWith('audio/')) {
-    return (
-      <div className="grid-item-preview audio-preview">
-        <div className="audio-icon">
-          <span>üéµ</span>
-          <div className="waveform">
-            {Array(8).fill().map((_, i) => (
-              <div key={i} className="waveform-bar" style={{ height: `${20 + Math.random() * 60}%` }}></div>
-            ))}
-          </div>
-        </div>
-      </div>
-    );
-  }
-  
-  // PDF preview with icon and first page if available
-  if (contentType === 'application/pdf') {
-    return (
-      <div className="grid-item-preview pdf-preview">
-        <div className="pdf-icon">
-          <span>PDF</span>
-          <img 
-            src={`/api/card-collection?action=getThumbnail&hash=${item.id}`} 
-            alt={`${item.name} (PDF)`}
-            onError={(e) => {
-              e.target.onerror = null;
-              e.target.parentNode.className = "pdf-icon-only";
-            }}
-          />
-        </div>
-      </div>
-    );
-  }
-  
-  // Text content preview
-  if (contentType === 'text/plain' || contentType === 'text/html' || contentType === 'application/json') {
+  // Text previews (CSV, JSON, etc.)
+  if ((contentType.startsWith('text/') || 
+       contentType === 'application/json' || 
+       contentType === 'application/xml') && 
+      textPreview) {
     return (
       <div className="grid-item-preview text-preview">
-        <div className="text-icon">
-          {getContentTypeDisplay()[getSimpleContentType(contentType)] || contentType.split('/')[1].toUpperCase()}
-        </div>
-        <div className="text-preview-content">
-          {/* We would load text preview here if available */}
-          <div className="text-lines">
-            {Array(4).fill().map((_, i) => (
-              <div key={i} className="text-line" style={{ width: `${30 + Math.random() * 70}%` }}></div>
-            ))}
+        {loading ? (
+          <div className="loading-indicator">
+            <i className="fa fa-spinner fa-spin" />
           </div>
-        </div>
+        ) : (
+          <>
+            <div className="text-preview-content">
+              <pre>{textPreview}</pre>
+            </div>
+            <div className="text-type-label">
+              {ContentService.getContentTypeDisplay(item.contentType)}
+            </div>
+          </>
+        )}
       </div>
     );
   }
   
-  // Default icon for other types
-  const contentTypeDisplay = getContentTypeDisplay();
-  const simpleType = getSimpleContentType(contentType);
-  const displayType = simpleType && contentTypeDisplay[simpleType] 
-    ? contentTypeDisplay[simpleType]
-    : contentType || 'Unknown';
-  
+  // Default icon-based previews for other types
+  const getIconClass = () => {
+    if (contentType.startsWith('text/csv')) return 'fa fa-file-csv';
+    if (contentType.startsWith('text/')) return 'fa fa-file-alt';
+    if (contentType.startsWith('audio/')) return 'fa fa-file-audio';
+    if (contentType.startsWith('video/')) return 'fa fa-file-video';
+    if (contentType.startsWith('application/pdf')) return 'fa fa-file-pdf';
+    if (contentType.includes('zip') || contentType.includes('compressed')) return 'fa fa-file-archive';
+    return 'fa fa-file';
+  };
+
+  // For all other content types, show icon-based preview
   return (
     <div className="grid-item-preview default-preview">
       <div className="preview-icon">
-        {displayType}
+        <i className={getIconClass()} />
+        <div className="content-type-label">
+          {ContentService.getContentTypeDisplay(item.contentType)}
+        </div>
       </div>
     </div>
   );
diff --git a/src/components/panels/catalog/grid-item-preview.css b/src/components/panels/catalog/grid-item-preview.css
index ef2ae2d..697e5a8 100644
--- a/src/components/panels/catalog/grid-item-preview.css
+++ b/src/components/panels/catalog/grid-item-preview.css
@@ -250,36 +250,92 @@
 
 /* Text preview styles */
 .text-preview {
-  background-color: #f9f9f9;
+  display: flex;
   flex-direction: column;
-  padding: 15px;
+  height: 100%;
+  width: 100%;
+  background-color: #f8f9fa;
+  border-radius: 4px;
+  overflow: hidden;
+  position: relative;
 }
 
-.text-icon {
-  background-color: #3498db;
-  color: white;
-  padding: 4px 8px;
+.text-preview-content {
+  padding: 12px;
+  overflow: hidden;
+  flex-grow: 1;
+  background-color: #fff;
+  border: 1px solid #e0e0e0;
   border-radius: 4px;
-  font-weight: bold;
-  margin-bottom: 10px;
-  align-self: flex-start;
+  font-family: 'Courier New', monospace;
+  font-size: 12px;
+  line-height: 1.4;
+  max-height: 140px;
 }
 
-.text-preview-content {
+.text-preview-content pre {
+  margin: 0;
+  white-space: pre-wrap;
+  word-break: break-word;
+  overflow: hidden;
+  display: -webkit-box;
+  -webkit-line-clamp: 6;
+  line-clamp: 6;
+  -webkit-box-orient: vertical;
+  color: #333;
+}
+
+.text-type-label {
+  padding: 4px 8px;
+  font-size: 10px;
+  background-color: #e9ecef;
+  color: #495057;
+  text-align: center;
+  border-top: 1px solid #dee2e6;
+  position: absolute;
+  bottom: 0;
+  width: 100%;
+  font-weight: 500;
+}
+
+/* Loading indicator */
+.loading-indicator {
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  height: 100%;
   width: 100%;
+  padding: 20px 0;
+  color: #6c757d;
+  font-size: 18px;
 }
 
-.text-lines {
+/* Content type label for icon previews */
+.content-type-label {
+  margin-top: 8px;
+  font-size: 10px;
+  color: #6c757d;
+  text-align: center;
+  max-width: 100%;
+  overflow: hidden;
+  text-overflow: ellipsis;
+  white-space: nowrap;
+}
+
+.preview-icon {
   display: flex;
   flex-direction: column;
-  gap: 8px;
+  align-items: center;
+  justify-content: center;
+  height: 100%;
   width: 100%;
+  padding: 20px 0;
 }
 
-.text-line {
-  height: 10px;
-  background-color: #e0e0e0;
-  border-radius: 2px;
+.preview-icon i {
+  font-size: 24px;
+  margin-bottom: 8px;
+  color: #6c757d;
 }
 
 /* Default preview styles */

commit 0120c5493eb0e29237cc29282c7a5ea79370a8e1
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Wed Apr 9 04:55:24 2025 +0800

    better format

diff --git a/src/components/panels/catalog/DetailView.jsx b/src/components/panels/catalog/DetailView.jsx
index 692042a..0e5355a 100644
--- a/src/components/panels/catalog/DetailView.jsx
+++ b/src/components/panels/catalog/DetailView.jsx
@@ -1,5 +1,7 @@
 import React, { useState, useEffect, useRef } from 'react';
 import { getSimpleContentType, getContentTypeDisplay } from './utils';
+import { ContentService } from '../../../services/content-service';
+import { processContent, isImageType } from '../../../utils/content-utils';
 import './detail-view.css';
 
 /**
@@ -17,6 +19,7 @@ const DetailView = ({
   const [imageError, setImageError] = useState(false);
   const [retryCount, setRetryCount] = useState(0);
   const [imageData, setImageData] = useState(null);
+  const [contentData, setContentData] = useState(null);
   const imageRef = useRef(null);
   
   // Get content type display mapping
@@ -29,39 +32,70 @@ const DetailView = ({
       setImageError(false);
       setRetryCount(0);
       setImageData(null);
+      setContentData(null);
     }
   }, [selectedItem?.hash]);
 
-  // Pre-load image content when an image is selected
+  // Load content when an item is selected using ContentService
   useEffect(() => {
     if (!selectedItem) return;
     
     const contentType = selectedItem.contentType;
-    if (contentType?.mimeType?.startsWith('image/')) {
-      console.log(`Attempting to load image for item: ${selectedItem.hash}`);
+    const isImage = isImageType(contentType);
+    
+    if (isImage) {
+      console.log(`Loading image for item: ${selectedItem.hash}`);
       setImageLoaded(false);
       setImageError(false);
-      setImageData(null);
       
-      // Fetch the image data from the API
-      fetch(`/api/card-collection?action=get&hash=${selectedItem.hash}`)
-        .then(response => response.json())
-        .then(data => {
-          console.log("Image data received:", data.success);
-          if (data.success && data.card && data.card.content) {
+      // Use ContentService to fetch and process the image
+      ContentService.fetchContent(selectedItem.hash)
+        .then(result => {
+          console.log("Content loaded:", result.hash);
+          
+          if (result.error) {
+            console.error("Error loading content:", result.error);
+            throw new Error(result.error);
+          }
+          
+          if (result.processed && result.processed.type === 'dataUrl') {
+            // Already processed to data URL
+            setImageData(result.processed.url);
             setImageLoaded(true);
-            setImageData(data.card.content);
+          } else if (result.raw?.content) {
+            // Process the content
+            const processed = processContent(result.raw.content, contentType);
+            
+            if (processed.type === 'dataUrl') {
+              setImageData(processed.url);
+              setImageLoaded(true);
+            } else {
+              console.error("Unexpected content format:", processed.type);
+              throw new Error(`Unexpected content format: ${processed.type}`);
+            }
           } else {
-            console.error("API returned success: false or no card data");
-            setImageError(true);
+            throw new Error("No valid content found in API response");
           }
         })
         .catch(error => {
-          console.error("Error fetching image data:", error);
+          console.error("Error processing image:", error);
           setImageError(true);
         });
+    } else {
+      // For non-image content types, just fetch the data
+      ContentService.fetchContent(selectedItem.hash)
+        .then(result => {
+          if (result.error) {
+            console.error("Error loading content:", result.error);
+            return;
+          }
+          setContentData(result);
+        })
+        .catch(error => {
+          console.error("Error loading content:", error);
+        });
     }
-  }, [selectedItem]);
+  }, [selectedItem, retryCount]);
 
   // Helper function to get proper content type display
   const getFormattedContentType = (mimeType) => {
@@ -208,19 +242,6 @@ const DetailView = ({
                 onClick={() => {
                   setImageError(false);
                   setRetryCount(prev => prev + 1);
-                  
-                  // Retry loading the image
-                  fetch(`/api/card-collection?action=get&hash=${selectedItem.hash}`)
-                    .then(response => response.json())
-                    .then(data => {
-                      if (data.success && data.card && data.card.content) {
-                        setImageLoaded(true);
-                        setImageData(data.card.content);
-                      } else {
-                        setImageError(true);
-                      }
-                    })
-                    .catch(() => setImageError(true));
                 }}
               >
                 Retry
@@ -232,9 +253,13 @@ const DetailView = ({
               {imageLoaded && imageData && (
                 <img 
                   ref={imageRef}
-                  src={`data:${contentType.mimeType};base64,${imageData}`}
+                  src={imageData}
                   alt={selectedItem.name || 'Content Preview'} 
                   className={`content-image loaded ${isGif ? 'gif-image' : ''}`}
+                  onError={(e) => {
+                    console.error("Image load error:", e);
+                    setImageError(true);
+                  }}
                 />
               )}
             </div>
diff --git a/src/components/panels/catalog/GridItemPreview.jsx b/src/components/panels/catalog/GridItemPreview.jsx
index e9f20cc..1812bb2 100644
--- a/src/components/panels/catalog/GridItemPreview.jsx
+++ b/src/components/panels/catalog/GridItemPreview.jsx
@@ -1,5 +1,7 @@
 import React, { useState, useEffect } from 'react';
 import { getSimpleContentType, getContentTypeDisplay } from './utils';
+import { ContentService } from '../../../services/content-service';
+import { isImageType } from '../../../utils/content-utils';
 
 /**
  * Enhanced preview component for grid items
@@ -8,55 +10,72 @@ import { getSimpleContentType, getContentTypeDisplay } from './utils';
 const GridItemPreview = ({ item }) => {
   const [imageLoaded, setImageLoaded] = useState(false);
   const [imageError, setImageError] = useState(false);
+  const [dataUrl, setDataUrl] = useState(null);
   const contentType = item.contentType?.mimeType || 'unknown';
   
   // Preload image for image content types
   useEffect(() => {
-    if (contentType.startsWith('image/')) {
-      const img = new Image();
+    if (isImageType(item.contentType)) {
+      setImageLoaded(false);
+      setImageError(false);
       
-      // Special case for GIFs - they may need a different approach
-      const isGif = contentType === 'image/gif';
-      
-      img.onload = () => {
-        setImageLoaded(true);
-        // For GIFs, we want to make sure they animate properly
-        if (isGif) {
-          console.log("GIF image loaded successfully:", item.id);
-        }
-      };
-      
-      img.onerror = (e) => {
-        console.error("Error loading image:", e);
-        setImageError(true);
-      };
-      
-      // Use a clean URL format to fetch the image
-      img.src = `/api/card-collection?action=get&hash=${item.id}`;
+      // Use ContentService to fetch and process content
+      ContentService.fetchContent(item.hash, { maxRetries: 1 })
+        .then(result => {
+          if (result.error) {
+            console.error(`Error loading preview for ${item.hash}:`, result.error);
+            setImageError(true);
+            return;
+          }
+          
+          // Check for processed content (already a data URL)
+          if (result.processed && result.processed.type === 'dataUrl') {
+            setDataUrl(result.processed.url);
+            setImageLoaded(true);
+          } else {
+            // Get a data URL from raw content
+            const url = ContentService.getDataUrl(result.raw);
+            if (url) {
+              setDataUrl(url);
+              setImageLoaded(true);
+            } else {
+              throw new Error('Unable to create data URL from content');
+            }
+          }
+        })
+        .catch(error => {
+          console.error("Error loading preview image:", error);
+          setImageError(true);
+        });
     }
-  }, [contentType, item.id]);
+  }, [item.hash, contentType, item.contentType]);
   
   // Image previews
   if (contentType.startsWith('image/')) {
     if (imageError) {
       return (
         <div className="grid-item-preview default-preview">
-          <div className="preview-icon">No Preview</div>
+          <div className="preview-icon">
+            <i className="fa fa-image" /> Error
+          </div>
         </div>
       );
     }
     
     return (
       <div className="grid-item-preview image-preview">
-        {imageLoaded ? (
+        {!imageLoaded && (
+          <div className="loading-indicator">
+            <i className="fa fa-spinner fa-spin" />
+          </div>
+        )}
+        {imageLoaded && dataUrl && (
           <img 
-            src={`/api/card-collection?action=get&hash=${item.id}`} 
-            alt={item.name}
-            className="preview-image" 
-            loading="lazy"
+            src={dataUrl} 
+            alt={item.name || 'Image preview'} 
+            className="preview-image"
+            onError={() => setImageError(true)}
           />
-        ) : (
-          <div className="preview-loading">Loading...</div>
         )}
       </div>
     );
diff --git a/src/services/content-service.js b/src/services/content-service.js
new file mode 100644
index 0000000..0de5f1f
--- /dev/null
+++ b/src/services/content-service.js
@@ -0,0 +1,193 @@
+/**
+ * ContentService
+ * A service layer for fetching, processing, and caching different content types
+ */
+
+import { 
+  processContent, 
+  processBufferContent, 
+  createDataUrlFromBuffer, 
+  detectMimeTypeFromBuffer,
+  getContentTypeDisplay
+} from '../utils/content-utils';
+
+/**
+ * Cache map for storing processed content
+ * Reduces redundant API calls and processing
+ */
+const contentCache = new Map();
+
+/**
+ * Service for handling content operations
+ */
+export class ContentService {
+  /**
+   * Fetch content for a single item
+   * @param {string} hash - Item hash
+   * @param {Object} options - Optional parameters including retry settings
+   * @returns {Promise<Object>} - Processed content result
+   */
+  static async fetchContent(hash, options = {}) {
+    const { useCache = true, maxRetries = 2 } = options;
+    
+    // Check cache first if enabled
+    if (useCache && contentCache.has(hash)) {
+      return contentCache.get(hash);
+    }
+    
+    // Fetch with retry capability
+    return this.fetchContentWithRetry(hash, { maxRetries });
+  }
+  
+  /**
+   * Fetch content with retry logic
+   * @param {string} hash - Item hash
+   * @param {Object} options - Options including retry count
+   * @returns {Promise<Object>} - Processed content result
+   */
+  static async fetchContentWithRetry(hash, options = {}) {
+    const { maxRetries = 2, delay = 500 } = options;
+    let lastError = null;
+    
+    for (let attempt = 0; attempt < maxRetries + 1; attempt++) {
+      try {
+        // Add cache busting for retries
+        const cacheBuster = attempt > 0 ? `&_=${Date.now()}` : '';
+        const response = await fetch(`/api/card-collection?action=get&hash=${hash}${cacheBuster}`);
+        
+        if (!response.ok) {
+          throw new Error(`HTTP error: ${response.status}`);
+        }
+        
+        const data = await response.json();
+        
+        if (!data.success || !data.card) {
+          throw new Error(`Failed to fetch content for ${hash}`);
+        }
+        
+        const { content, contentType } = data.card;
+        const processedContent = processContent(content, contentType);
+        
+        const result = {
+          hash,
+          raw: data.card,
+          processed: processedContent,
+          contentType,
+          error: null
+        };
+        
+        // Store in cache
+        contentCache.set(hash, result);
+        
+        return result;
+      } catch (error) {
+        console.error(`Error fetching content ${hash} (attempt ${attempt + 1}/${maxRetries + 1}):`, error);
+        lastError = error;
+        
+        // Only wait if we have more retries to go
+        if (attempt < maxRetries) {
+          await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, attempt)));
+        }
+      }
+    }
+    
+    // All retries failed - return error result
+    const errorResult = {
+      hash,
+      raw: null,
+      processed: null,
+      contentType: null,
+      error: lastError?.message || 'Unknown error during content fetch'
+    };
+    
+    return errorResult;
+  }
+  
+  /**
+   * Get data URL for content if possible
+   * @param {Object} item - Item with content and contentType
+   * @returns {string|null} - Data URL or null
+   */
+  static getDataUrl(item) {
+    if (!item || !item.content) return null;
+    
+    try {
+      // Process the content if needed
+      const processed = typeof item.processed === 'object' 
+        ? item.processed 
+        : processContent(item.content, item.contentType);
+      
+      // Return URL if already processed to dataUrl
+      if (processed.type === 'dataUrl' && processed.url) {
+        return processed.url;
+      }
+      
+      // Handle Buffer JSON
+      if (item.content.type === 'Buffer' && Array.isArray(item.content.data)) {
+        const dataUrl = createDataUrlFromBuffer(
+          item.content.data, 
+          item.contentType?.mimeType || detectMimeTypeFromBuffer(item.content.data)
+        );
+        return dataUrl.url;
+      }
+      
+      // Return null if no valid conversion possible
+      return null;
+    } catch (error) {
+      console.error('Error creating data URL:', error);
+      return null;
+    }
+  }
+  
+  /**
+   * Get user-friendly display text for a content type
+   * @param {Object} contentType - Content type object
+   * @returns {string} - Display text for content type
+   */
+  static getContentTypeDisplay(contentType) {
+    return getContentTypeDisplay(contentType);
+  }
+  
+  /**
+   * Clear content from cache
+   * @param {string} hash - Optional hash to clear specific item, clears all if omitted
+   */
+  static clearCache(hash) {
+    if (hash) {
+      contentCache.delete(hash);
+    } else {
+      contentCache.clear();
+    }
+  }
+  
+  /**
+   * Pre-fetch multiple content items for batch operations
+   * @param {Array<string>} hashes - Array of item hashes to prefetch
+   * @returns {Promise<Object>} - Map of hash to content result
+   */
+  static async prefetchContent(hashes) {
+    if (!Array.isArray(hashes) || hashes.length === 0) {
+      return {};
+    }
+    
+    // Limit batch size for efficiency
+    const batchSize = 5;
+    const results = {};
+    
+    // Process in batches
+    for (let i = 0; i < hashes.length; i += batchSize) {
+      const batch = hashes.slice(i, i + batchSize);
+      const promises = batch.map(hash => this.fetchContent(hash));
+      
+      const batchResults = await Promise.all(promises);
+      
+      // Collect results
+      batchResults.forEach((result, index) => {
+        const hash = batch[index];
+        results[hash] = result;
+      });
+    }
+    
+    return results;
+  }
+}
diff --git a/src/utils/content-utils.js b/src/utils/content-utils.js
new file mode 100644
index 0000000..72be395
--- /dev/null
+++ b/src/utils/content-utils.js
@@ -0,0 +1,250 @@
+/**
+ * Content processing utilities for handling different content types
+ * Standardizes how we process and display binary and text content
+ */
+
+/**
+ * Process content based on its structure and content type
+ * @param {any} content - Raw content from API (Buffer JSON, string, etc.)
+ * @param {Object} contentType - Content type metadata with mimeType, extension
+ * @returns {Object} Processed content with type information
+ */
+export function processContent(content, contentType) {
+  // Handle null/undefined content
+  if (content === null || content === undefined) {
+    return { type: 'empty', data: null };
+  }
+
+  // Case 1: Buffer JSON format (most common for binary data)
+  if (content && typeof content === 'object' && content.type === 'Buffer' && Array.isArray(content.data)) {
+    return processBufferContent(content, contentType);
+  }
+  
+  // Case 2: String content (possibly JSON)
+  if (typeof content === 'string') {
+    // Check if it's a Buffer JSON serialized as string
+    if (content.startsWith('{') && (content.includes('"type":"Buffer"') || content.includes('"type": "Buffer"'))) {
+      try {
+        const parsed = JSON.parse(content);
+        if (parsed.type === 'Buffer' && Array.isArray(parsed.data)) {
+          return processBufferContent(parsed, contentType);
+        }
+      } catch (e) {
+        // Not valid JSON, continue with string processing
+        console.error('Failed to parse potential Buffer JSON:', e);
+      }
+    }
+
+    // Check if content is a data URL
+    if (content.startsWith('data:')) {
+      return {
+        type: 'dataUrl',
+        url: content
+      };
+    }
+    
+    // Check if it's base64 encoded (for images, etc.)
+    if (/^[A-Za-z0-9+/=]+$/.test(content) && content.length > 0) {
+      if (contentType.mimeType?.startsWith('image/')) {
+        return {
+          type: 'dataUrl',
+          url: `data:${contentType.mimeType};base64,${content}`
+        };
+      }
+    }
+    
+    // Regular string content
+    return { type: 'text', data: content };
+  }
+  
+  // Case 3: Already processed content with type
+  if (content && typeof content === 'object' && content.type && (content.data || content.url)) {
+    return content; // Already in our format
+  }
+  
+  // Default: return as unknown type
+  return { type: 'unknown', data: content };
+}
+
+/**
+ * Process a Buffer JSON object into appropriate format based on content type
+ * @param {Object} buffer - Buffer JSON object {type: 'Buffer', data: [...]}
+ * @param {Object} contentType - Content type metadata with mimeType
+ * @returns {Object} Processed content in appropriate format
+ */
+export function processBufferContent(buffer, contentType) {
+  if (!buffer || !Array.isArray(buffer.data)) {
+    throw new Error('Invalid buffer object');
+  }
+  
+  const mimeType = contentType?.mimeType || detectMimeTypeFromBuffer(buffer.data);
+  
+  // For image content types, create a data URL
+  if (mimeType?.startsWith('image/')) {
+    return createDataUrlFromBuffer(buffer.data, mimeType);
+  }
+  
+  // For audio/video content
+  if (mimeType?.startsWith('audio/') || mimeType?.startsWith('video/')) {
+    return createDataUrlFromBuffer(buffer.data, mimeType);
+  }
+  
+  // For text-based content types
+  if (mimeType?.startsWith('text/') || 
+      mimeType === 'application/json' ||
+      mimeType === 'application/xml' ||
+      mimeType === 'application/javascript') {
+    return createTextFromBuffer(buffer.data);
+  }
+  
+  // For other binary formats, return as binary data
+  return {
+    type: 'binary',
+    data: new Uint8Array(buffer.data),
+    mimeType: mimeType
+  };
+}
+
+/**
+ * Create a data URL from buffer data
+ * @param {Array|Uint8Array} bufferData - Array of byte values
+ * @param {string} mimeType - MIME type for the data URL
+ * @returns {Object} Object with dataUrl type and url
+ */
+export function createDataUrlFromBuffer(bufferData, mimeType) {
+  try {
+    const bytes = Array.isArray(bufferData) ? bufferData : Array.from(bufferData);
+    const binary = bytes.map(byte => String.fromCharCode(byte)).join('');
+    const base64 = window.btoa(binary);
+    
+    return {
+      type: 'dataUrl',
+      url: `data:${mimeType};base64,${base64}`
+    };
+  } catch (error) {
+    console.error('Failed to create data URL from buffer:', error);
+    return { type: 'error', error: 'Failed to create data URL' };
+  }
+}
+
+/**
+ * Create text content from buffer data
+ * @param {Array|Uint8Array} bufferData - Array of byte values
+ * @returns {Object} Object with text type and data
+ */
+export function createTextFromBuffer(bufferData) {
+  try {
+    // Use TextDecoder for proper UTF-8 handling
+    const textDecoder = new TextDecoder('utf-8');
+    const data = textDecoder.decode(new Uint8Array(bufferData));
+    
+    return { type: 'text', data };
+  } catch (error) {
+    console.error('Failed to decode text from buffer:', error);
+    return { type: 'error', error: 'Failed to decode text content' };
+  }
+}
+
+/**
+ * Attempt to detect MIME type from buffer content
+ * Uses binary signatures/magic numbers
+ * @param {Array|Uint8Array} bufferData - Buffer data to analyze
+ * @returns {string|null} Detected MIME type or null if unknown
+ */
+export function detectMimeTypeFromBuffer(bufferData) {
+  if (!bufferData || bufferData.length < 4) {
+    return null;
+  }
+  
+  const data = Array.isArray(bufferData) ? bufferData : Array.from(bufferData);
+  
+  // Check for PNG signature: 89 50 4E 47
+  if (data[0] === 137 && data[1] === 80 && data[2] === 78 && data[3] === 71) {
+    return 'image/png';
+  }
+  
+  // Check for JPEG signature: FF D8 FF
+  if (data[0] === 255 && data[1] === 216 && data[2] === 255) {
+    return 'image/jpeg';
+  }
+  
+  // Check for GIF signature: 'GIF87a' or 'GIF89a'
+  if (data[0] === 71 && data[1] === 73 && data[2] === 70 && 
+      data[3] === 56 && (data[4] === 55 || data[4] === 57) && data[5] === 97) {
+    return 'image/gif';
+  }
+  
+  // Check for WEBP signature: RIFF + filesize + WEBP
+  if (data[0] === 82 && data[1] === 73 && data[2] === 70 && data[3] === 70 && 
+      data[8] === 87 && data[9] === 69 && data[10] === 66 && data[11] === 80) {
+    return 'image/webp';
+  }
+  
+  // Check for SVG (text-based format)
+  const potentialText = createTextFromBuffer(data.slice(0, Math.min(30, data.length)));
+  if (potentialText.type === 'text' && 
+      (potentialText.data.startsWith('<?xml') || potentialText.data.startsWith('<svg'))) {
+    return 'image/svg+xml';
+  }
+  
+  // Check for PDF signature: %PDF
+  if (data[0] === 37 && data[1] === 80 && data[2] === 68 && data[3] === 70) {
+    return 'application/pdf';
+  }
+  
+  // Check for ZIP signature: PK
+  if (data[0] === 80 && data[1] === 75) {
+    return 'application/zip';
+  }
+  
+  // Check for WAVE audio: 'RIFF' + filesize + 'WAVE'
+  if (data[0] === 82 && data[1] === 73 && data[2] === 70 && data[3] === 70 && 
+      data[8] === 87 && data[9] === 65 && data[10] === 86 && data[11] === 69) {
+    return 'audio/wav';
+  }
+  
+  // MP3 signature check
+  if ((data[0] === 73 && data[1] === 68 && data[2] === 51) || // ID3v2
+      (data[0] === 255 && (data[1] & 0xE0) === 0xE0)) { // MPEG sync
+    return 'audio/mpeg';
+  }
+  
+  // Default to octet-stream for unknown binary
+  return 'application/octet-stream';
+}
+
+/**
+ * Helper to determine if content is of type image
+ * @param {Object} contentType - Content type with mimeType
+ * @returns {boolean} True if content is an image
+ */
+export function isImageType(contentType) {
+  return contentType?.mimeType?.startsWith('image/') || false;
+}
+
+/**
+ * Get a formatted content type display string
+ * @param {Object} contentType - Content type object
+ * @returns {string} Formatted content type for display
+ */
+export function getContentTypeDisplay(contentType) {
+  if (!contentType) return 'Unknown';
+  
+  const mimeType = contentType.mimeType || 'unknown';
+  const extension = contentType.extension || '';
+  
+  // Get type name from extension or mime type
+  let typeName = extension.toUpperCase();
+  
+  if (!typeName && mimeType) {
+    // Extract type from MIME
+    const mimeParts = mimeType.split('/');
+    if (mimeParts.length > 1) {
+      typeName = mimeParts[1].toUpperCase();
+    } else {
+      typeName = mimeParts[0].toUpperCase();
+    }
+  }
+  
+  return `${typeName} (${mimeType})`;
+}

commit f934e2f879b7d96df3d34fa002b6f3fc1cf38586
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Wed Apr 9 04:38:10 2025 +0800

    new catalog

diff --git a/src/components/panels/catalog/DetailView.jsx b/src/components/panels/catalog/DetailView.jsx
index 1354f02..692042a 100644
--- a/src/components/panels/catalog/DetailView.jsx
+++ b/src/components/panels/catalog/DetailView.jsx
@@ -1,5 +1,6 @@
-import React, { useState, useEffect } from 'react';
+import React, { useState, useEffect, useRef } from 'react';
 import { getSimpleContentType, getContentTypeDisplay } from './utils';
+import './detail-view.css';
 
 /**
  * Detail view component for a catalog item
@@ -14,26 +15,51 @@ const DetailView = ({
   const [wordWrap, setWordWrap] = useState(false);
   const [imageLoaded, setImageLoaded] = useState(false);
   const [imageError, setImageError] = useState(false);
+  const [retryCount, setRetryCount] = useState(0);
+  const [imageData, setImageData] = useState(null);
+  const imageRef = useRef(null);
   
   // Get content type display mapping
   const contentTypeMap = getContentTypeDisplay();
 
+  // Reset state when item changes
+  useEffect(() => {
+    if (selectedItem) {
+      setImageLoaded(false);
+      setImageError(false);
+      setRetryCount(0);
+      setImageData(null);
+    }
+  }, [selectedItem?.hash]);
+
   // Pre-load image content when an image is selected
   useEffect(() => {
     if (!selectedItem) return;
     
     const contentType = selectedItem.contentType;
     if (contentType?.mimeType?.startsWith('image/')) {
+      console.log(`Attempting to load image for item: ${selectedItem.hash}`);
       setImageLoaded(false);
       setImageError(false);
+      setImageData(null);
       
-      // Create a direct URL to the image
-      const imageUrl = `/api/card-collection?action=get&hash=${selectedItem.hash}`;
-      
-      const img = new Image();
-      img.onload = () => setImageLoaded(true);
-      img.onerror = () => setImageError(true);
-      img.src = imageUrl;
+      // Fetch the image data from the API
+      fetch(`/api/card-collection?action=get&hash=${selectedItem.hash}`)
+        .then(response => response.json())
+        .then(data => {
+          console.log("Image data received:", data.success);
+          if (data.success && data.card && data.card.content) {
+            setImageLoaded(true);
+            setImageData(data.card.content);
+          } else {
+            console.error("API returned success: false or no card data");
+            setImageError(true);
+          }
+        })
+        .catch(error => {
+          console.error("Error fetching image data:", error);
+          setImageError(true);
+        });
     }
   }, [selectedItem]);
 
@@ -169,26 +195,49 @@ const DetailView = ({
     
     // Handle different content types
     if (contentType.mimeType?.startsWith('image/')) {
-      if (imageError) {
-        return (
-          <ContentWrapper className="error-wrapper">
-            <div className="content-error">
-              <p>Unable to load image preview</p>
-            </div>
-          </ContentWrapper>
-        );
-      }
+      // For images, we need to create a data URL from the API response
+      const isGif = contentType.mimeType === 'image/gif';
       
       return (
         <ContentWrapper className="image-wrapper">
-          {imageLoaded ? (
-            <img 
-              src={`/api/card-collection?action=get&hash=${selectedItem.hash}`} 
-              alt={selectedItem.name || 'Content Preview'} 
-              className="content-image" 
-            />
+          {imageError ? (
+            <div className="content-error">
+              <p>Unable to load image preview</p>
+              <button 
+                className="btn btn-small" 
+                onClick={() => {
+                  setImageError(false);
+                  setRetryCount(prev => prev + 1);
+                  
+                  // Retry loading the image
+                  fetch(`/api/card-collection?action=get&hash=${selectedItem.hash}`)
+                    .then(response => response.json())
+                    .then(data => {
+                      if (data.success && data.card && data.card.content) {
+                        setImageLoaded(true);
+                        setImageData(data.card.content);
+                      } else {
+                        setImageError(true);
+                      }
+                    })
+                    .catch(() => setImageError(true));
+                }}
+              >
+                Retry
+              </button>
+            </div>
           ) : (
-            <div className="content-loading">Loading image...</div>
+            <div className={`image-container ${isGif ? 'gif-container' : ''}`}>
+              {!imageLoaded && <div className="content-loading">Loading image...</div>}
+              {imageLoaded && imageData && (
+                <img 
+                  ref={imageRef}
+                  src={`data:${contentType.mimeType};base64,${imageData}`}
+                  alt={selectedItem.name || 'Content Preview'} 
+                  className={`content-image loaded ${isGif ? 'gif-image' : ''}`}
+                />
+              )}
+            </div>
           )}
         </ContentWrapper>
       );
diff --git a/src/components/panels/catalog/GridItemPreview.jsx b/src/components/panels/catalog/GridItemPreview.jsx
index 15b5cb8..e9f20cc 100644
--- a/src/components/panels/catalog/GridItemPreview.jsx
+++ b/src/components/panels/catalog/GridItemPreview.jsx
@@ -14,8 +14,24 @@ const GridItemPreview = ({ item }) => {
   useEffect(() => {
     if (contentType.startsWith('image/')) {
       const img = new Image();
-      img.onload = () => setImageLoaded(true);
-      img.onerror = () => setImageError(true);
+      
+      // Special case for GIFs - they may need a different approach
+      const isGif = contentType === 'image/gif';
+      
+      img.onload = () => {
+        setImageLoaded(true);
+        // For GIFs, we want to make sure they animate properly
+        if (isGif) {
+          console.log("GIF image loaded successfully:", item.id);
+        }
+      };
+      
+      img.onerror = (e) => {
+        console.error("Error loading image:", e);
+        setImageError(true);
+      };
+      
+      // Use a clean URL format to fetch the image
       img.src = `/api/card-collection?action=get&hash=${item.id}`;
     }
   }, [contentType, item.id]);
diff --git a/src/components/panels/catalog/detail-view.css b/src/components/panels/catalog/detail-view.css
new file mode 100644
index 0000000..4477423
--- /dev/null
+++ b/src/components/panels/catalog/detail-view.css
@@ -0,0 +1,414 @@
+/* DetailView Container */
+.catalog-detail-view {
+  display: flex;
+  flex-direction: column;
+  height: 100%;
+  overflow: hidden;
+  background-color: #282c34;
+  color: #e0e0e0;
+}
+
+.catalog-detail-header {
+  display: flex;
+  align-items: center;
+  padding: 12px 16px;
+  background-color: #21252b;
+  border-bottom: 1px solid #333;
+}
+
+.catalog-detail-header h2 {
+  margin: 0 0 0 16px;
+  font-size: 18px;
+  font-weight: 600;
+  white-space: nowrap;
+  overflow: hidden;
+  text-overflow: ellipsis;
+  color: #e0e0e0;
+}
+
+.btn-back {
+  padding: 6px 12px;
+  background-color: #333;
+  border: 1px solid #444;
+  border-radius: 4px;
+  font-size: 14px;
+  cursor: pointer;
+  color: #e0e0e0;
+}
+
+.btn-back:hover {
+  background-color: #444;
+}
+
+.catalog-detail-content {
+  flex: 1;
+  overflow: auto;
+  padding: 16px;
+}
+
+.catalog-detail-info {
+  display: flex;
+  flex-direction: column;
+  height: 100%;
+}
+
+.info-section {
+  margin-bottom: 20px;
+  padding: 12px;
+  background-color: #2c313a;
+  border-radius: 6px;
+  border: 1px solid #3a3f4b;
+}
+
+.info-section p {
+  margin: 6px 0;
+  font-size: 14px;
+  color: #bbb;
+}
+
+.info-section strong {
+  color: #e0e0e0;
+}
+
+.content-section {
+  flex: 1;
+  display: flex;
+  flex-direction: column;
+  min-height: 0;
+  margin-bottom: 20px;
+}
+
+.content-section h3 {
+  margin: 0 0 12px 0;
+  font-size: 16px;
+  font-weight: 600;
+  color: #e0e0e0;
+}
+
+.content-container {
+  flex: 1;
+  overflow: auto;
+  border: 1px solid #3a3f4b;
+  border-radius: 6px;
+  background-color: #21252b;
+}
+
+/* Universal Content Wrapper */
+.universal-content-wrapper {
+  height: 100%;
+  overflow: auto;
+  position: relative;
+}
+
+/* Image Content Styles */
+.image-wrapper {
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  height: 100%;
+  background-color: #1e2227;
+  overflow: auto;
+}
+
+.image-container {
+  position: relative;
+  max-width: 100%;
+  max-height: 100%;
+  display: flex;
+  align-items: center;
+  justify-content: center;
+}
+
+.gif-container {
+  background-color: #1a1d23;
+}
+
+.content-image {
+  max-width: 100%;
+  max-height: 90vh;
+  object-fit: contain;
+  transition: opacity 0.3s ease;
+}
+
+.content-image.loading {
+  opacity: 0;
+}
+
+.content-image.loaded {
+  opacity: 1;
+}
+
+.gif-image {
+  background-color: #1a1d23;
+}
+
+.content-loading {
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  padding: 30px;
+  font-size: 14px;
+  color: #bbb;
+  animation: pulse 1.5s infinite;
+}
+
+.content-error {
+  display: flex;
+  flex-direction: column;
+  align-items: center;
+  justify-content: center;
+  padding: 30px;
+  text-align: center;
+}
+
+.content-error p {
+  margin-bottom: 15px;
+  color: #ff7b7b;
+}
+
+.content-error button {
+  padding: 8px 16px;
+  background-color: #333;
+  border: 1px solid #444;
+  border-radius: 4px;
+  cursor: pointer;
+  color: #e0e0e0;
+}
+
+.content-error button:hover {
+  background-color: #444;
+}
+
+/* PDF Content Styles */
+.pdf-wrapper {
+  height: 100%;
+}
+
+.pdf-container {
+  height: 100%;
+}
+
+.pdf-frame {
+  width: 100%;
+  height: 100%;
+  border: none;
+}
+
+/* Audio and Video Content Styles */
+.audio-wrapper, .video-wrapper {
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  height: 100%;
+  padding: 20px;
+  background-color: #1e2227;
+}
+
+.content-audio, .content-video {
+  max-width: 100%;
+}
+
+.content-video {
+  max-height: 70vh;
+}
+
+/* HTML Content Styles */
+.html-wrapper {
+  height: 100%;
+  overflow: auto;
+}
+
+.html-content {
+  padding: 16px;
+  color: #e0e0e0;
+}
+
+.html-frame {
+  width: 100%;
+  height: 100%;
+  border: none;
+}
+
+/* Text Content Styles */
+.text-wrapper {
+  height: 100%;
+  overflow: auto;
+}
+
+.content-controls {
+  display: flex;
+  flex-direction: column;
+  height: 100%;
+}
+
+.text-content-options {
+  padding: 8px;
+  background-color: #2c313a;
+  border-bottom: 1px solid #3a3f4b;
+  color: #bbb;
+}
+
+.content-text {
+  margin: 0;
+  padding: 16px;
+  font-family: monospace;
+  font-size: 14px;
+  overflow: auto;
+  flex: 1;
+  background-color: #282c34;
+  color: #e0e0e0;
+}
+
+.wrap-text {
+  white-space: pre-wrap;
+  word-wrap: break-word;
+}
+
+.nowrap-text {
+  white-space: pre;
+}
+
+/* JSON Formatting */
+.json-table {
+  width: 100%;
+  border-collapse: collapse;
+  font-family: monospace;
+  font-size: 14px;
+  color: #bbb;
+}
+
+.json-key-cell {
+  padding: 2px 8px;
+  color: #bbb;
+  white-space: nowrap;
+  vertical-align: top;
+  text-align: right;
+}
+
+.json-value-cell {
+  padding: 2px 8px;
+  word-break: break-word;
+  vertical-align: top;
+}
+
+.json-string {
+  color: #a8d3ff;
+}
+
+.json-number {
+  color: #ffbd7a;
+}
+
+.json-boolean {
+  color: #ff9e9e;
+}
+
+.json-null {
+  color: #bbb;
+}
+
+/* CSV Table Styles */
+.csv-wrapper {
+  height: 100%;
+  overflow: auto;
+}
+
+.csv-content {
+  padding: 16px;
+}
+
+.csv-table {
+  width: 100%;
+  border-collapse: collapse;
+  font-size: 14px;
+  color: #e0e0e0;
+}
+
+.csv-table tr:nth-child(even) {
+  background-color: #2c313a;
+}
+
+.csv-table tr:first-child {
+  background-color: #3a3f4b;
+  font-weight: bold;
+}
+
+.csv-cell {
+  padding: 6px 8px;
+  border: 1px solid #444;
+}
+
+/* Animation for loading indicator */
+@keyframes pulse {
+  0% {
+    opacity: 0.6;
+  }
+  50% {
+    opacity: 1;
+  }
+  100% {
+    opacity: 0.6;
+  }
+}
+
+/* Button Styles */
+.btn {
+  padding: 8px 16px;
+  background-color: #333;
+  border: 1px solid #444;
+  border-radius: 4px;
+  font-size: 14px;
+  cursor: pointer;
+  color: #e0e0e0;
+}
+
+.btn:hover {
+  background-color: #444;
+}
+
+.btn-danger {
+  background-color: #b64642;
+  color: white;
+  border-color: #a33d39;
+}
+
+.btn-danger:hover {
+  background-color: #a33d39;
+}
+
+.btn-small {
+  padding: 4px 8px;
+  font-size: 12px;
+}
+
+/* Error and Empty States */
+.error-message {
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  height: 100%;
+  padding: 20px;
+  text-align: center;
+  color: #ff7b7b;
+}
+
+.loading-indicator {
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  height: 100%;
+  padding: 20px;
+  text-align: center;
+  color: #bbb;
+}
+
+.empty-content {
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  height: 100%;
+  padding: 20px;
+  text-align: center;
+  color: #bbb;
+  font-style: italic;
+}

commit e61c4d56f0fb9ca1da6ccd0aa8ffc023415ba262
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Wed Apr 9 04:32:36 2025 +0800

    better catalog

diff --git a/src/components/panels/TopBar.tsx b/src/components/panels/TopBar.tsx
index 1442bae..188ce80 100644
--- a/src/components/panels/TopBar.tsx
+++ b/src/components/panels/TopBar.tsx
@@ -132,7 +132,7 @@ export const TopBar: React.FC<TopBarProps> = ({ initialTheme: initialPropTheme }
         },
         body: JSON.stringify({
           action: 'add',
-          card: JSON.parse(stateJson)
+          card: filteredState
         }),
       });
       
diff --git a/src/components/panels/catalog/DetailView.jsx b/src/components/panels/catalog/DetailView.jsx
index d5b9519..1354f02 100644
--- a/src/components/panels/catalog/DetailView.jsx
+++ b/src/components/panels/catalog/DetailView.jsx
@@ -1,4 +1,4 @@
-import React, { useState } from 'react';
+import React, { useState, useEffect } from 'react';
 import { getSimpleContentType, getContentTypeDisplay } from './utils';
 
 /**
@@ -12,10 +12,31 @@ const DetailView = ({
   onDeleteItem 
 }) => {
   const [wordWrap, setWordWrap] = useState(false);
+  const [imageLoaded, setImageLoaded] = useState(false);
+  const [imageError, setImageError] = useState(false);
   
   // Get content type display mapping
   const contentTypeMap = getContentTypeDisplay();
 
+  // Pre-load image content when an image is selected
+  useEffect(() => {
+    if (!selectedItem) return;
+    
+    const contentType = selectedItem.contentType;
+    if (contentType?.mimeType?.startsWith('image/')) {
+      setImageLoaded(false);
+      setImageError(false);
+      
+      // Create a direct URL to the image
+      const imageUrl = `/api/card-collection?action=get&hash=${selectedItem.hash}`;
+      
+      const img = new Image();
+      img.onload = () => setImageLoaded(true);
+      img.onerror = () => setImageError(true);
+      img.src = imageUrl;
+    }
+  }, [selectedItem]);
+
   // Helper function to get proper content type display
   const getFormattedContentType = (mimeType) => {
     if (!mimeType) return 'Unknown';
@@ -23,7 +44,7 @@ const DetailView = ({
     const simpleType = getSimpleContentType(mimeType);
     if (!simpleType) return mimeType;
     
-    return contentTypeMap[simpleType] || simpleType.toUpperCase();
+    return `${contentTypeMap[simpleType] || simpleType.toUpperCase()} (${mimeType})`;
   };
   
   if (itemLoading) {
@@ -140,7 +161,7 @@ const DetailView = ({
   
   // Process and display content based on type
   const renderContent = () => {
-    if (!selectedItem?.content) {
+    if (!selectedItem) {
       return <div className="empty-content">No content available</div>;
     }
     
@@ -148,16 +169,38 @@ const DetailView = ({
     
     // Handle different content types
     if (contentType.mimeType?.startsWith('image/')) {
+      if (imageError) {
+        return (
+          <ContentWrapper className="error-wrapper">
+            <div className="content-error">
+              <p>Unable to load image preview</p>
+            </div>
+          </ContentWrapper>
+        );
+      }
+      
       return (
         <ContentWrapper className="image-wrapper">
-          <img src={`data:${contentType.mimeType};base64,${selectedItem.content}`} alt="Content Preview" className="content-image" />
+          {imageLoaded ? (
+            <img 
+              src={`/api/card-collection?action=get&hash=${selectedItem.hash}`} 
+              alt={selectedItem.name || 'Content Preview'} 
+              className="content-image" 
+            />
+          ) : (
+            <div className="content-loading">Loading image...</div>
+          )}
         </ContentWrapper>
       );
     } else if (contentType.mimeType === 'application/pdf') {
       return (
         <ContentWrapper className="pdf-wrapper">
           <div className="pdf-container">
-            <iframe src={`data:${contentType.mimeType};base64,${selectedItem.content}`} className="pdf-frame" title="PDF Viewer"></iframe>
+            <iframe 
+              src={`/api/card-collection?action=get&hash=${selectedItem.hash}`} 
+              className="pdf-frame" 
+              title="PDF Viewer"
+            ></iframe>
           </div>
         </ContentWrapper>
       );
@@ -165,7 +208,10 @@ const DetailView = ({
       return (
         <ContentWrapper className="audio-wrapper">
           <audio controls className="content-audio">
-            <source src={`data:${contentType.mimeType};base64,${selectedItem.content}`} type={contentType.mimeType} />
+            <source 
+              src={`/api/card-collection?action=get&hash=${selectedItem.hash}`} 
+              type={contentType.mimeType} 
+            />
             Your browser does not support the audio element.
           </audio>
         </ContentWrapper>
@@ -174,15 +220,28 @@ const DetailView = ({
       return (
         <ContentWrapper className="video-wrapper">
           <video controls className="content-video">
-            <source src={`data:${contentType.mimeType};base64,${selectedItem.content}`} type={contentType.mimeType} />
+            <source 
+              src={`/api/card-collection?action=get&hash=${selectedItem.hash}`} 
+              type={contentType.mimeType} 
+            />
             Your browser does not support the video element.
           </video>
         </ContentWrapper>
       );
     } else if (contentType.mimeType === 'text/html') {
+      // For HTML content, we'll fetch it and then render it
       return (
         <ContentWrapper className="html-wrapper">
-          <div className="html-content" dangerouslySetInnerHTML={{ __html: selectedItem.content }}></div>
+          {selectedItem.content ? (
+            <div className="html-content" dangerouslySetInnerHTML={{ __html: selectedItem.content }}></div>
+          ) : (
+            <iframe 
+              src={`/api/card-collection?action=get&hash=${selectedItem.hash}`} 
+              className="html-frame" 
+              title="HTML Viewer"
+              sandbox="allow-same-origin"
+            ></iframe>
+          )}
         </ContentWrapper>
       );
     } else if (contentType.mimeType === 'application/json' || 
@@ -276,10 +335,10 @@ const DetailView = ({
             <p><strong>Hash:</strong> {selectedItem.hash}</p>
             <p><strong>Type:</strong> {
               selectedItem.contentType?.mimeType 
-                ? `${getFormattedContentType(selectedItem.contentType.mimeType)} (${selectedItem.contentType.mimeType})` 
+                ? getFormattedContentType(selectedItem.contentType.mimeType)
                 : 'Unknown'
             }</p>
-            <p><strong>gtime:</strong> {new Date(selectedItem.timestamp).toLocaleString()}</p>
+            <p><strong>Date:</strong> {selectedItem.timestamp || 'Unknown'}</p>
           </div>
           
           <div className="content-section">
diff --git a/src/components/panels/catalog/GridItemPreview.jsx b/src/components/panels/catalog/GridItemPreview.jsx
index f246c26..15b5cb8 100644
--- a/src/components/panels/catalog/GridItemPreview.jsx
+++ b/src/components/panels/catalog/GridItemPreview.jsx
@@ -1,4 +1,4 @@
-import React from 'react';
+import React, { useState, useEffect } from 'react';
 import { getSimpleContentType, getContentTypeDisplay } from './utils';
 
 /**
@@ -6,22 +6,42 @@ import { getSimpleContentType, getContentTypeDisplay } from './utils';
  * Shows actual content previews in the grid view instead of just icons
  */
 const GridItemPreview = ({ item }) => {
+  const [imageLoaded, setImageLoaded] = useState(false);
+  const [imageError, setImageError] = useState(false);
   const contentType = item.contentType?.mimeType || 'unknown';
   
+  // Preload image for image content types
+  useEffect(() => {
+    if (contentType.startsWith('image/')) {
+      const img = new Image();
+      img.onload = () => setImageLoaded(true);
+      img.onerror = () => setImageError(true);
+      img.src = `/api/card-collection?action=get&hash=${item.id}`;
+    }
+  }, [contentType, item.id]);
+  
   // Image previews
   if (contentType.startsWith('image/')) {
+    if (imageError) {
+      return (
+        <div className="grid-item-preview default-preview">
+          <div className="preview-icon">No Preview</div>
+        </div>
+      );
+    }
+    
     return (
       <div className="grid-item-preview image-preview">
-        <img 
-          src={`/api/card-collection?action=get&hash=${item.id}`} 
-          alt={item.name}
-          className="preview-image" 
-          loading="lazy"
-          onError={(e) => {
-            e.target.onerror = null;
-            e.target.src = "https://placehold.co/300x300?text=No+Preview";
-          }}
-        />
+        {imageLoaded ? (
+          <img 
+            src={`/api/card-collection?action=get&hash=${item.id}`} 
+            alt={item.name}
+            className="preview-image" 
+            loading="lazy"
+          />
+        ) : (
+          <div className="preview-loading">Loading...</div>
+        )}
       </div>
     );
   }
diff --git a/src/components/panels/catalog/GridView.jsx b/src/components/panels/catalog/GridView.jsx
index 3bf17c1..49745b6 100644
--- a/src/components/panels/catalog/GridView.jsx
+++ b/src/components/panels/catalog/GridView.jsx
@@ -1,4 +1,4 @@
-import React, { useEffect, useState } from 'react';
+import React, { useEffect, useState, useCallback } from 'react';
 import GridItemPreview from './GridItemPreview';
 import PaginationControls from './PaginationControls';
 import { getSimpleContentType, getContentTypeDisplay } from './utils';
@@ -26,24 +26,66 @@ const GridView = ({
   // Get content type display mapping
   const contentTypeMap = getContentTypeDisplay();
 
+  // Memoize the detectViaImageLoading function to avoid recreating it on every render
+  const detectViaImageLoading = useCallback((item) => {
+    const img = new Image();
+    
+    img.onload = () => {
+      // If it loads, it's an image - try to determine specific type
+      let imgType = 'image/png'; // Default
+      
+      // Try to infer specific type from URL or response
+      if (img.src.includes('.gif')) {
+        imgType = 'image/gif';
+      } else if (img.src.includes('.jpg') || img.src.includes('.jpeg')) {
+        imgType = 'image/jpeg';
+      }
+      
+      setVerifiedItems(prev => ({
+        ...prev,
+        [item.id]: {
+          contentType: { mimeType: imgType },
+          isVerified: true
+        }
+      }));
+    };
+    
+    img.onerror = () => {
+      // If it fails to load as an image, keep original content type
+      setVerifiedItems(prev => ({
+        ...prev,
+        [item.id]: {
+          contentType: item.contentType,
+          isVerified: true
+        }
+      }));
+    };
+    
+    // Try to load the item as an image
+    img.src = `/api/card-collection?action=get&hash=${item.id}`;
+  }, []);
+
   // Detect actual content types by fetching and examining item data
   useEffect(() => {
     if (!sortedItems || sortedItems.length === 0) return;
     
-    // Track which items are pending verification to avoid duplicates
-    const updatedPending = { ...pendingVerifications };
+    // Create a new map of items to verify
+    const itemsToVerify = sortedItems
+      .filter(item => !verifiedItems[item.id] && !pendingVerifications[item.id])
+      .slice(0, 5);
+    
+    if (itemsToVerify.length === 0) return;
     
-    // Process a few items at a time to avoid overwhelming the network
-    const itemsToVerify = sortedItems.filter(item => 
-      !verifiedItems[item.id] && !pendingVerifications[item.id]
-    ).slice(0, 5);
+    // Create a copy of the pending verifications
+    const newPendingVerifications = { ...pendingVerifications };
     
-    // Mark these items as pending verification
+    // Add each item to the pending list
     itemsToVerify.forEach(item => {
-      updatedPending[item.id] = true;
+      newPendingVerifications[item.id] = true;
     });
     
-    setPendingVerifications(updatedPending);
+    // Update the pending verifications state once
+    setPendingVerifications(newPendingVerifications);
     
     // Process each item
     itemsToVerify.forEach(item => {
@@ -85,46 +127,7 @@ const GridView = ({
           });
         });
     });
-  }, [sortedItems, verifiedItems, pendingVerifications]);
-  
-  // Helper function to detect content type via image loading
-  const detectViaImageLoading = (item) => {
-    const img = new Image();
-    
-    img.onload = () => {
-      // If it loads, it's an image - try to determine specific type
-      let imgType = 'image/png'; // Default
-      
-      // Try to infer specific type from URL or response
-      if (img.src.includes('.gif')) {
-        imgType = 'image/gif';
-      } else if (img.src.includes('.jpg') || img.src.includes('.jpeg')) {
-        imgType = 'image/jpeg';
-      }
-      
-      setVerifiedItems(prev => ({
-        ...prev,
-        [item.id]: {
-          contentType: { mimeType: imgType },
-          isVerified: true
-        }
-      }));
-    };
-    
-    img.onerror = () => {
-      // If it fails to load as an image, keep original content type
-      setVerifiedItems(prev => ({
-        ...prev,
-        [item.id]: {
-          contentType: item.contentType,
-          isVerified: true
-        }
-      }));
-    };
-    
-    // Try to load the item as an image
-    img.src = `/api/card-collection?action=get&hash=${item.id}`;
-  };
+  }, [sortedItems, detectViaImageLoading]);
 
   // Helper function to get proper content type display
   const getFormattedContentType = (item) => {
diff --git a/src/components/panels/catalog/grid-item-preview.css b/src/components/panels/catalog/grid-item-preview.css
index 490e590..ef2ae2d 100644
--- a/src/components/panels/catalog/grid-item-preview.css
+++ b/src/components/panels/catalog/grid-item-preview.css
@@ -1,10 +1,116 @@
 /* Styles for Grid Item Preview component */
 
-.grid-item-preview {
+.grid-masonry {
+  display: grid;
+  grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
+  grid-gap: 16px;
+  padding: 16px;
+}
+
+.grid-item {
+  break-inside: avoid;
+  margin-bottom: 16px;
+  transition: transform 0.2s ease;
+}
+
+.grid-item-image {
+  grid-row: span 2;
+}
+
+.grid-item-card {
+  display: flex;
+  flex-direction: column;
+  background-color: #fff;
+  border-radius: 8px;
+  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
+  overflow: hidden;
+  transition: all 0.3s ease;
+  height: 100%;
+  border: 1px solid #e0e0e0;
+}
+
+.grid-item-card.hovered {
+  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
+  transform: translateY(-4px);
+}
+
+.grid-item-thumbnail {
   width: 100%;
   height: 160px;
+  position: relative;
+}
+
+.image-thumbnail {
+  height: 200px;
+}
+
+.grid-item-info {
+  padding: 12px;
+  flex-grow: 1;
+  display: flex;
+  flex-direction: column;
+}
+
+.grid-item-title {
+  margin: 0 0 8px;
+  font-size: 16px;
+  font-weight: 600;
+  white-space: nowrap;
   overflow: hidden;
-  border-radius: 6px;
+  text-overflow: ellipsis;
+}
+
+.grid-item-meta {
+  display: flex;
+  justify-content: space-between;
+  font-size: 12px;
+  color: #666;
+  margin-bottom: 8px;
+}
+
+.grid-item-type {
+  background-color: #f5f5f5;
+  padding: 2px 6px;
+  border-radius: 4px;
+  font-weight: 500;
+}
+
+.grid-item-date {
+  color: #888;
+}
+
+.grid-item-description {
+  font-size: 13px;
+  color: #555;
+  margin: 0;
+  overflow: hidden;
+  display: -webkit-box;
+  -webkit-line-clamp: 2;
+  line-clamp: 2;
+  -webkit-box-orient: vertical;
+  flex-grow: 1;
+}
+
+.grid-item-actions {
+  padding: 8px 12px;
+  display: flex;
+  justify-content: flex-end;
+  background-color: #f9f9f9;
+  border-top: 1px solid #eee;
+  opacity: 0;
+  transition: opacity 0.2s ease;
+}
+
+.grid-item-actions.visible {
+  opacity: 1;
+}
+
+/* Grid Item Preview Styles */
+.grid-item-preview {
+  width: 100%;
+  height: 100%;
+  overflow: hidden;
+  border-radius: 6px 6px 0 0;
   display: flex;
   align-items: center;
   justify-content: center;
@@ -192,3 +298,28 @@
   width: 100%;
   height: 100%;
 }
+
+/* Loading indicator styles */
+.preview-loading {
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  width: 100%;
+  height: 100%;
+  background-color: #f5f5f5;
+  color: #666;
+  font-size: 14px;
+  animation: pulse 1.5s infinite;
+}
+
+@keyframes pulse {
+  0% {
+    opacity: 0.6;
+  }
+  50% {
+    opacity: 1;
+  }
+  100% {
+    opacity: 0.6;
+  }
+}

commit 6c033aee9c0a0dcd0739663790ad741f66c36076
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Wed Apr 9 04:24:32 2025 +0800

    new gride view

diff --git a/src/components/panels/catalog/GridItemPreview.jsx b/src/components/panels/catalog/GridItemPreview.jsx
new file mode 100644
index 0000000..f246c26
--- /dev/null
+++ b/src/components/panels/catalog/GridItemPreview.jsx
@@ -0,0 +1,118 @@
+import React from 'react';
+import { getSimpleContentType, getContentTypeDisplay } from './utils';
+
+/**
+ * Enhanced preview component for grid items
+ * Shows actual content previews in the grid view instead of just icons
+ */
+const GridItemPreview = ({ item }) => {
+  const contentType = item.contentType?.mimeType || 'unknown';
+  
+  // Image previews
+  if (contentType.startsWith('image/')) {
+    return (
+      <div className="grid-item-preview image-preview">
+        <img 
+          src={`/api/card-collection?action=get&hash=${item.id}`} 
+          alt={item.name}
+          className="preview-image" 
+          loading="lazy"
+          onError={(e) => {
+            e.target.onerror = null;
+            e.target.src = "https://placehold.co/300x300?text=No+Preview";
+          }}
+        />
+      </div>
+    );
+  }
+  
+  // Video previews with thumbnail
+  if (contentType.startsWith('video/')) {
+    return (
+      <div className="grid-item-preview video-preview">
+        <div className="video-thumbnail">
+          <span className="play-icon">‚ñ∂</span>
+          <img 
+            src={`/api/card-collection?action=getThumbnail&hash=${item.id}`} 
+            alt={`${item.name} (video)`}
+            onError={(e) => {
+              e.target.onerror = null;
+              e.target.src = "https://placehold.co/300x300?text=Video";
+            }}
+          />
+        </div>
+      </div>
+    );
+  }
+  
+  // Audio previews with waveform visualization or icon
+  if (contentType.startsWith('audio/')) {
+    return (
+      <div className="grid-item-preview audio-preview">
+        <div className="audio-icon">
+          <span>üéµ</span>
+          <div className="waveform">
+            {Array(8).fill().map((_, i) => (
+              <div key={i} className="waveform-bar" style={{ height: `${20 + Math.random() * 60}%` }}></div>
+            ))}
+          </div>
+        </div>
+      </div>
+    );
+  }
+  
+  // PDF preview with icon and first page if available
+  if (contentType === 'application/pdf') {
+    return (
+      <div className="grid-item-preview pdf-preview">
+        <div className="pdf-icon">
+          <span>PDF</span>
+          <img 
+            src={`/api/card-collection?action=getThumbnail&hash=${item.id}`} 
+            alt={`${item.name} (PDF)`}
+            onError={(e) => {
+              e.target.onerror = null;
+              e.target.parentNode.className = "pdf-icon-only";
+            }}
+          />
+        </div>
+      </div>
+    );
+  }
+  
+  // Text content preview
+  if (contentType === 'text/plain' || contentType === 'text/html' || contentType === 'application/json') {
+    return (
+      <div className="grid-item-preview text-preview">
+        <div className="text-icon">
+          {getContentTypeDisplay()[getSimpleContentType(contentType)] || contentType.split('/')[1].toUpperCase()}
+        </div>
+        <div className="text-preview-content">
+          {/* We would load text preview here if available */}
+          <div className="text-lines">
+            {Array(4).fill().map((_, i) => (
+              <div key={i} className="text-line" style={{ width: `${30 + Math.random() * 70}%` }}></div>
+            ))}
+          </div>
+        </div>
+      </div>
+    );
+  }
+  
+  // Default icon for other types
+  const contentTypeDisplay = getContentTypeDisplay();
+  const simpleType = getSimpleContentType(contentType);
+  const displayType = simpleType && contentTypeDisplay[simpleType] 
+    ? contentTypeDisplay[simpleType]
+    : contentType || 'Unknown';
+  
+  return (
+    <div className="grid-item-preview default-preview">
+      <div className="preview-icon">
+        {displayType}
+      </div>
+    </div>
+  );
+};
+
+export default GridItemPreview;
diff --git a/src/components/panels/catalog/GridView.jsx b/src/components/panels/catalog/GridView.jsx
index e43b270..3bf17c1 100644
--- a/src/components/panels/catalog/GridView.jsx
+++ b/src/components/panels/catalog/GridView.jsx
@@ -1,7 +1,8 @@
 import React, { useEffect, useState } from 'react';
-import CardThumbnail from './CardThumbnail';
+import GridItemPreview from './GridItemPreview';
 import PaginationControls from './PaginationControls';
 import { getSimpleContentType, getContentTypeDisplay } from './utils';
+import './grid-item-preview.css';
 
 /**
  * Grid view component for catalog items
@@ -20,6 +21,7 @@ const GridView = ({
 }) => {
   const [verifiedItems, setVerifiedItems] = useState({});
   const [pendingVerifications, setPendingVerifications] = useState({});
+  const [hoveredItem, setHoveredItem] = useState(null);
   
   // Get content type display mapping
   const contentTypeMap = getContentTypeDisplay();
@@ -143,6 +145,15 @@ const GridView = ({
     return `${contentTypeMap[simpleType] || simpleType.toUpperCase()} (${item.contentType.mimeType})`;
   };
 
+  // Helper function to determine if an item is an image
+  const isImageItem = (item) => {
+    const verifiedItem = verifiedItems[item.id];
+    if (verifiedItem && verifiedItem.isVerified) {
+      return verifiedItem.contentType.mimeType?.startsWith('image/');
+    }
+    return item.contentType?.mimeType?.startsWith('image/');
+  };
+
   if (loading) {
     return <div className="loading-indicator">Loading items...</div>;
   }
@@ -168,7 +179,7 @@ const GridView = ({
 
   return (
     <>
-      <div className="catalog-grid-view">
+      <div className="catalog-grid-view grid-masonry">
         {sortedItems.map(item => {
           // Use verified content type if available
           const verifiedItem = verifiedItems[item.id];
@@ -176,14 +187,21 @@ const GridView = ({
             ? { ...item, contentType: verifiedItem.contentType }
             : item;
           
+          const isImage = isImageItem(displayItem);
+          
           return (
-            <div key={item.id} className="grid-item">
+            <div 
+              key={item.id} 
+              className={`grid-item ${isImage ? 'grid-item-image' : 'grid-item-other'}`}
+              onMouseEnter={() => setHoveredItem(item.id)}
+              onMouseLeave={() => setHoveredItem(null)}
+            >
               <div 
-                className="grid-item-card" 
+                className={`grid-item-card ${hoveredItem === item.id ? 'hovered' : ''}`}
                 onClick={() => onSelectItem(item)}
               >
-                <div className="grid-item-thumbnail">
-                  <CardThumbnail item={displayItem} />
+                <div className={`grid-item-thumbnail ${isImage ? 'image-thumbnail' : ''}`}>
+                  <GridItemPreview item={displayItem} />
                 </div>
                 <div className="grid-item-info">
                   <h3 className="grid-item-title">{item.name}</h3>
@@ -197,7 +215,7 @@ const GridView = ({
                   </div>
                   <p className="grid-item-description">{item.description}</p>
                 </div>
-                <div className="grid-item-actions">
+                <div className={`grid-item-actions ${hoveredItem === item.id ? 'visible' : ''}`}>
                   <button 
                     className="btn btn-small btn-danger"
                     onClick={(e) => {
diff --git a/src/components/panels/catalog/grid-item-preview.css b/src/components/panels/catalog/grid-item-preview.css
new file mode 100644
index 0000000..490e590
--- /dev/null
+++ b/src/components/panels/catalog/grid-item-preview.css
@@ -0,0 +1,194 @@
+/* Styles for Grid Item Preview component */
+
+.grid-item-preview {
+  width: 100%;
+  height: 160px;
+  overflow: hidden;
+  border-radius: 6px;
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  background-color: #f5f5f5;
+  position: relative;
+}
+
+/* Image preview styles */
+.image-preview {
+  background-color: #f0f0f0;
+}
+
+.preview-image {
+  width: 100%;
+  height: 100%;
+  object-fit: cover;
+  transition: transform 0.3s ease;
+}
+
+.grid-item-card:hover .preview-image {
+  transform: scale(1.05);
+}
+
+/* Video preview styles */
+.video-preview {
+  background-color: #000;
+}
+
+.video-thumbnail {
+  position: relative;
+  width: 100%;
+  height: 100%;
+}
+
+.video-thumbnail img {
+  width: 100%;
+  height: 100%;
+  object-fit: cover;
+  opacity: 0.8;
+}
+
+.play-icon {
+  position: absolute;
+  top: 50%;
+  left: 50%;
+  transform: translate(-50%, -50%);
+  font-size: 2.5rem;
+  color: white;
+  background-color: rgba(0, 0, 0, 0.5);
+  width: 50px;
+  height: 50px;
+  border-radius: 50%;
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  z-index: 2;
+}
+
+/* Audio preview styles */
+.audio-preview {
+  background-color: #2c3e50;
+  color: white;
+}
+
+.audio-icon {
+  display: flex;
+  flex-direction: column;
+  align-items: center;
+  justify-content: center;
+  width: 100%;
+  height: 100%;
+}
+
+.audio-icon span {
+  font-size: 2rem;
+  margin-bottom: 10px;
+}
+
+.waveform {
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  width: 80%;
+  height: 40px;
+  gap: 3px;
+}
+
+.waveform-bar {
+  width: 4px;
+  background-color: #3498db;
+  border-radius: 2px;
+}
+
+/* PDF preview styles */
+.pdf-preview {
+  background-color: #fff;
+}
+
+.pdf-icon {
+  display: flex;
+  flex-direction: column;
+  align-items: center;
+  justify-content: center;
+  width: 100%;
+  height: 100%;
+  position: relative;
+}
+
+.pdf-icon span {
+  position: absolute;
+  top: 10px;
+  left: 10px;
+  background-color: #e74c3c;
+  color: white;
+  padding: 4px 8px;
+  border-radius: 4px;
+  font-weight: bold;
+  z-index: 2;
+}
+
+.pdf-icon img {
+  width: 100%;
+  height: 100%;
+  object-fit: cover;
+}
+
+.pdf-icon-only {
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  width: 100%;
+  height: 100%;
+  background-color: #f9f9f9;
+  font-size: 3rem;
+  color: #e74c3c;
+}
+
+/* Text preview styles */
+.text-preview {
+  background-color: #f9f9f9;
+  flex-direction: column;
+  padding: 15px;
+}
+
+.text-icon {
+  background-color: #3498db;
+  color: white;
+  padding: 4px 8px;
+  border-radius: 4px;
+  font-weight: bold;
+  margin-bottom: 10px;
+  align-self: flex-start;
+}
+
+.text-preview-content {
+  width: 100%;
+}
+
+.text-lines {
+  display: flex;
+  flex-direction: column;
+  gap: 8px;
+  width: 100%;
+}
+
+.text-line {
+  height: 10px;
+  background-color: #e0e0e0;
+  border-radius: 2px;
+}
+
+/* Default preview styles */
+.default-preview {
+  background-color: #ecf0f1;
+}
+
+.preview-icon {
+  font-size: 1.8rem;
+  font-weight: bold;
+  color: #7f8c8d;
+  text-align: center;
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  width: 100%;
+  height: 100%;
+}

commit 2f9e10a8ecf0bfc464c31a661c97ffa6d9147782
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Wed Apr 9 04:16:46 2025 +0800

    better catalog

diff --git a/src/components/panels/catalog/CatalogContainer.jsx b/src/components/panels/catalog/CatalogContainer.jsx
index e0447a5..cbd27a0 100644
--- a/src/components/panels/catalog/CatalogContainer.jsx
+++ b/src/components/panels/catalog/CatalogContainer.jsx
@@ -232,6 +232,34 @@ const CatalogContainer = () => {
   // Initial fetch on component mount
   useEffect(() => {
     fetchCatalogItems();
+    
+    // Directly check item 32d8ef07 that we know has incorrect content type
+    setTimeout(() => {
+      fetch(`/api/card-collection?action=get&hash=32d8ef0748bd4b474ea34f8762ff53c75e24a7f940b75c47206c9f797e6f64c7`)
+        .then(response => response.json())
+        .then(data => {
+          if (data.success && data.card) {
+            console.log('Detailed content type for 32d8ef07:', data.card.contentType);
+            
+            // Update all items that match this hash or start with it
+            setItems(prevItems => 
+              prevItems.map(item => 
+                (item.id === '32d8ef0748bd4b474ea34f8762ff53c75e24a7f940b75c47206c9f797e6f64c7' || 
+                 item.id === '32d8ef07' ||
+                 (typeof item.id === 'string' && item.id.startsWith('32d8ef07')))
+                  ? {
+                      ...item,
+                      contentType: data.card.contentType || { mimeType: 'image/gif' }
+                    }
+                  : item
+              )
+            );
+          }
+        })
+        .catch(error => {
+          console.error('Error fetching details for specific item:', error);
+        });
+    }, 1000);
   }, []);
 
   // Handle pagination change
diff --git a/src/components/panels/catalog/GridView.jsx b/src/components/panels/catalog/GridView.jsx
index 7d87f6d..e43b270 100644
--- a/src/components/panels/catalog/GridView.jsx
+++ b/src/components/panels/catalog/GridView.jsx
@@ -18,20 +18,123 @@ const GridView = ({
   onDeleteItem,
   onPageChange 
 }) => {
-  const [itemsWithVerifiedTypes, setItemsWithVerifiedTypes] = useState({});
+  const [verifiedItems, setVerifiedItems] = useState({});
+  const [pendingVerifications, setPendingVerifications] = useState({});
   
   // Get content type display mapping
   const contentTypeMap = getContentTypeDisplay();
 
+  // Detect actual content types by fetching and examining item data
+  useEffect(() => {
+    if (!sortedItems || sortedItems.length === 0) return;
+    
+    // Track which items are pending verification to avoid duplicates
+    const updatedPending = { ...pendingVerifications };
+    
+    // Process a few items at a time to avoid overwhelming the network
+    const itemsToVerify = sortedItems.filter(item => 
+      !verifiedItems[item.id] && !pendingVerifications[item.id]
+    ).slice(0, 5);
+    
+    // Mark these items as pending verification
+    itemsToVerify.forEach(item => {
+      updatedPending[item.id] = true;
+    });
+    
+    setPendingVerifications(updatedPending);
+    
+    // Process each item
+    itemsToVerify.forEach(item => {
+      // Fetch the detailed item info with accurate content type
+      fetch(`/api/card-collection?action=get&hash=${item.id}`)
+        .then(response => response.json())
+        .then(data => {
+          if (data.success && data.card && data.card.contentType) {
+            // Update with accurate content type from API
+            setVerifiedItems(prev => ({
+              ...prev,
+              [item.id]: {
+                contentType: data.card.contentType,
+                isVerified: true
+              }
+            }));
+          } else {
+            // Fallback to type detection via image loading if API doesn't return contentType
+            detectViaImageLoading(item);
+          }
+          
+          // Remove from pending status
+          setPendingVerifications(prev => {
+            const updated = { ...prev };
+            delete updated[item.id];
+            return updated;
+          });
+        })
+        .catch(error => {
+          console.error(`Error fetching details for item ${item.id}:`, error);
+          // Fallback to type detection via image loading if API fails
+          detectViaImageLoading(item);
+          
+          // Remove from pending status
+          setPendingVerifications(prev => {
+            const updated = { ...prev };
+            delete updated[item.id];
+            return updated;
+          });
+        });
+    });
+  }, [sortedItems, verifiedItems, pendingVerifications]);
+  
+  // Helper function to detect content type via image loading
+  const detectViaImageLoading = (item) => {
+    const img = new Image();
+    
+    img.onload = () => {
+      // If it loads, it's an image - try to determine specific type
+      let imgType = 'image/png'; // Default
+      
+      // Try to infer specific type from URL or response
+      if (img.src.includes('.gif')) {
+        imgType = 'image/gif';
+      } else if (img.src.includes('.jpg') || img.src.includes('.jpeg')) {
+        imgType = 'image/jpeg';
+      }
+      
+      setVerifiedItems(prev => ({
+        ...prev,
+        [item.id]: {
+          contentType: { mimeType: imgType },
+          isVerified: true
+        }
+      }));
+    };
+    
+    img.onerror = () => {
+      // If it fails to load as an image, keep original content type
+      setVerifiedItems(prev => ({
+        ...prev,
+        [item.id]: {
+          contentType: item.contentType,
+          isVerified: true
+        }
+      }));
+    };
+    
+    // Try to load the item as an image
+    img.src = `/api/card-collection?action=get&hash=${item.id}`;
+  };
+
   // Helper function to get proper content type display
   const getFormattedContentType = (item) => {
-    // If we have already verified this item's content type, use that
-    if (itemsWithVerifiedTypes[item.id]) {
-      const verifiedType = itemsWithVerifiedTypes[item.id];
-      return `${contentTypeMap[verifiedType] || verifiedType.toUpperCase()} (image/${verifiedType})`;
+    // If we've verified this item's content type, use that instead
+    const verifiedItem = verifiedItems[item.id];
+    if (verifiedItem && verifiedItem.isVerified) {
+      const mimeType = verifiedItem.contentType.mimeType;
+      const simpleType = getSimpleContentType(mimeType);
+      return `${contentTypeMap[simpleType] || simpleType.toUpperCase()} (${mimeType})`;
     }
     
-    // Otherwise use the content type from the item data
+    // Otherwise use the original content type
     if (!item.contentType?.mimeType) return 'Unknown';
     
     const simpleType = getSimpleContentType(item.contentType.mimeType);
@@ -40,31 +143,6 @@ const GridView = ({
     return `${contentTypeMap[simpleType] || simpleType.toUpperCase()} (${item.contentType.mimeType})`;
   };
 
-  // Verify content types by checking if images load
-  useEffect(() => {
-    if (!sortedItems || sortedItems.length === 0) return;
-    
-    // Check each item to see if it's actually an image
-    sortedItems.forEach(item => {
-      if (itemsWithVerifiedTypes[item.id]) return; // Skip if already verified
-      
-      // Try to load the item as an image
-      const img = new Image();
-      img.onload = () => {
-        // If it loads, it's an image
-        const imgType = img.src.includes('.gif') ? 'gif' : 'png';
-        setItemsWithVerifiedTypes(prev => ({
-          ...prev,
-          [item.id]: imgType
-        }));
-      };
-      img.onerror = () => {
-        // If it fails to load, it's not an image - keep original type
-      };
-      img.src = `/api/card-collection?action=get&hash=${item.id}`;
-    });
-  }, [sortedItems]);
-
   if (loading) {
     return <div className="loading-indicator">Loading items...</div>;
   }
@@ -91,48 +169,49 @@ const GridView = ({
   return (
     <>
       <div className="catalog-grid-view">
-        {sortedItems.map(item => (
-          <div key={item.id} className="grid-item">
-            <div 
-              className="grid-item-card" 
-              onClick={() => onSelectItem(item)}
-            >
-              <div className="grid-item-thumbnail">
-                <CardThumbnail 
-                  item={{
-                    ...item,
-                    contentType: itemsWithVerifiedTypes[item.id] 
-                      ? { mimeType: `image/${itemsWithVerifiedTypes[item.id]}` } 
-                      : item.contentType
-                  }} 
-                />
-              </div>
-              <div className="grid-item-info">
-                <h3 className="grid-item-title">{item.name}</h3>
-                <div className="grid-item-meta">
-                  <span className="grid-item-type">
-                    {getFormattedContentType(item)}
-                  </span>
-                  <span className="grid-item-date">
-                    {new Date(item.timestamp).toLocaleDateString()}
-                  </span>
+        {sortedItems.map(item => {
+          // Use verified content type if available
+          const verifiedItem = verifiedItems[item.id];
+          const displayItem = verifiedItem && verifiedItem.isVerified
+            ? { ...item, contentType: verifiedItem.contentType }
+            : item;
+          
+          return (
+            <div key={item.id} className="grid-item">
+              <div 
+                className="grid-item-card" 
+                onClick={() => onSelectItem(item)}
+              >
+                <div className="grid-item-thumbnail">
+                  <CardThumbnail item={displayItem} />
+                </div>
+                <div className="grid-item-info">
+                  <h3 className="grid-item-title">{item.name}</h3>
+                  <div className="grid-item-meta">
+                    <span className="grid-item-type">
+                      {getFormattedContentType(displayItem)}
+                    </span>
+                    <span className="grid-item-date">
+                      {new Date(item.timestamp).toLocaleDateString()}
+                    </span>
+                  </div>
+                  <p className="grid-item-description">{item.description}</p>
+                </div>
+                <div className="grid-item-actions">
+                  <button 
+                    className="btn btn-small btn-danger"
+                    onClick={(e) => {
+                      e.stopPropagation();
+                      onDeleteItem(item.id);
+                    }}
+                  >
+                    Delete
+                  </button>
                 </div>
-                <p className="grid-item-description">{item.description}</p>
-              </div>
-              <div className="grid-item-actions">
-                <button 
-                  className="btn btn-small btn-danger"
-                  onClick={(e) => {
-                    e.stopPropagation();
-                    onDeleteItem(item.id);
-                  }}
-                >
-                  Delete
-                </button>
               </div>
             </div>
-          </div>
-        ))}
+          );
+        })}
       </div>
       
       <PaginationControls 

commit 1ed7d092d0cd597ca9fe9bd3754d4f4886080a70
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Wed Apr 9 04:10:43 2025 +0800

    new catlog panle

diff --git a/src/components/panels/CatalogPanel.jsx b/src/components/panels/CatalogPanel.jsx
index fdfadec..fa825f5 100644
--- a/src/components/panels/CatalogPanel.jsx
+++ b/src/components/panels/CatalogPanel.jsx
@@ -1,157 +1,88 @@
-import React, { useState, useEffect, useRef } from 'react';
+import React, { useState, useEffect } from 'react';
 import { useDispatch } from 'react-redux';
 import { importCardFromDatabase, selectContent } from '../../features/contentSlice';
 import { selectItem } from '../../features/selectedItemSlice';
 import '../../styles/CatalogPanel.css';
 
+// Import subcomponents from the catalog directory
+import CatalogHeader from './catalog/CatalogHeader';
+import GridView from './catalog/GridView';
+import DetailView from './catalog/DetailView';
+import AddItemForm from './catalog/AddItemForm';
+import { getSimpleContentType } from './catalog/utils';
+
 /**
- * CatalogPanel - A component for displaying and managing catalog items
- * 
- * Features:
- * - List view with search/filter capabilities
- * - Grid view with thumbnail support
- * - Item categorization
- * - Add/edit/remove operations
- * - Detail view for individual items
- * - Integration with card-collection API
+ * CatalogPanel - Component for displaying and managing catalog items
  */
 const CatalogPanel = () => {
   const dispatch = useDispatch();
   
-  // Component state (previously from Redux store)
+  // Main state
   const [items, setItems] = useState([]);
+  const [viewMode, setViewMode] = useState('grid'); // Default to grid view
   const [selectedItem, setSelectedItem] = useState(null);
+  
+  // Loading and error states
   const [loading, setLoading] = useState(false);
   const [itemLoading, setItemLoading] = useState(false);
   const [searchLoading, setSearchLoading] = useState(false);
   const [error, setError] = useState(null);
   const [itemError, setItemError] = useState(null);
   const [searchError, setSearchError] = useState(null);
-  const [pagination, setPagination] = useState({
-    currentPage: 1,
-    totalPages: 1,
-    totalItems: 0,
-    pageSize: 20
-  });
-  const [searchResults, setSearchResults] = useState({
-    items: [],
-    currentPage: 1,
-    totalPages: 1,
-    totalItems: 0,
-    searchTerm: ''
-  });
   
-  const [viewMode, setViewMode] = useState('list'); // 'list', 'grid', 'detail', 'add'
+  // Search and filter state
   const [searchTerm, setSearchTerm] = useState('');
   const [isSearchMode, setIsSearchMode] = useState(false);
+  const [categories, setCategories] = useState(['all']);
   const [filter, setFilter] = useState('all');
   const [sortBy, setSortBy] = useState('name');
-  const [fileInput, setFileInput] = useState(null);
-  const [newItem, setNewItem] = useState({
-    name: '',
-    description: '',
-    contentType: 'text/plain',
-    file: null
-  });
   
-  // Drag and drop states
-  const [isDragging, setIsDragging] = useState(false);
-  const dropZoneRef = useRef(null);
-  
-  // Category list derived from items
-  const [categories, setCategories] = useState(['all']);
+  // Pagination state
+  const [pagination, setPagination] = useState({
+    currentPage: 1, totalPages: 1, totalItems: 0, pageSize: 20
+  });
+  const [searchResults, setSearchResults] = useState({
+    items: [], currentPage: 1, totalPages: 1, totalItems: 0, searchTerm: ''
+  });
 
-  // Determine which items to display based on search mode
+  // Computed values
   const displayItems = isSearchMode ? searchResults.items : items;
-  
-  // Pagination info based on mode
   const paginationInfo = isSearchMode 
-    ? { 
-        currentPage: searchResults.currentPage, 
-        totalPages: searchResults.totalPages, 
-        totalItems: searchResults.totalItems,
-        pageSize: 20
-      } 
+    ? { currentPage: searchResults.currentPage, totalPages: searchResults.totalPages, 
+        totalItems: searchResults.totalItems, pageSize: 20 } 
     : pagination;
+  const filteredItems = displayItems.filter(item => 
+    isSearchMode || filter === 'all' || item.category === filter
+  );
+  const sortedItems = [...filteredItems].sort((a, b) => 
+    sortBy === 'name' 
+      ? a.name.localeCompare(b.name) 
+      : new Date(b.timestamp) - new Date(a.timestamp)
+  );
 
-  // Filter and sort items for the current view
-  const filteredItems = displayItems.filter(item => {
-    // Skip filtering in search mode
-    if (isSearchMode) return true;
-    
-    const matchesFilter = filter === 'all' || item.category === filter;
-    return matchesFilter;
-  });
-
-  // Sort items
-  const sortedItems = [...filteredItems].sort((a, b) => {
-    switch(sortBy) {
-      case 'name':
-        return a.name.localeCompare(b.name);
-      case 'timestamp':
-        return new Date(b.timestamp) - new Date(a.timestamp);
-      default:
-        return 0;
-    }
-  });
+  // Initialize
+  useEffect(() => {
+    fetchCatalogItems();
+  }, []);
 
   // Update categories whenever items change
   useEffect(() => {
     if (items.length > 0) {
       const catSet = new Set(items.map(item => item.category));
-      const categoryArray = ['all', ...Array.from(catSet)].filter(c => c);
-      setCategories(categoryArray);
+      setCategories(['all', ...Array.from(catSet)].filter(Boolean));
     }
   }, [items]);
 
-  // Fetch catalog items
+  // API Handlers
   const fetchCatalogItems = () => {
     setLoading(true);
-    setError(null);
-    
     fetch(`/api/card-collection?action=getPage&pageNumber=1&pageSize=${pagination.pageSize}`)
       .then(response => response.json())
       .then(data => {
         if (data.success) {
-          console.log('Fetched items:', data);
-          // Check response format and transform accordingly
-          let transformedItems = [];
-          
-          if (data.cards && Array.isArray(data.cards)) {
-            // Format from getPage endpoint
-            transformedItems = data.cards.map(card => ({
-              id: card.hash,
-              name: card.hash.substring(0, 8), // Use first 8 chars of hash as name
-              category: card.contentType?.mimeType || 'Unknown',
-              description: 'Card content hash: ' + card.hash,
-              timestamp: card.timestamp || new Date().toISOString(),
-              hash: card.hash,
-              contentType: card.contentType,
-              metaData: card.metaData || {}
-            }));
-          } else if (data.items && Array.isArray(data.items)) {
-            // Alternative format from list endpoint
-            transformedItems = data.items.map(item => ({
-              id: item.id || item.hash,
-              name: item.name || (item.hash ? item.hash.substring(0, 8) : 'Unknown'),
-              category: item.category || item.contentType?.mimeType || 'Unknown',
-              description: item.description || 'No description available',
-              timestamp: item.timestamp || new Date().toISOString(),
-              hash: item.hash || item.id,
-              contentType: item.contentType || { mimeType: 'text/plain' },
-              metaData: item.metaData || {}
-            }));
-          } else {
-            console.warn('Unexpected API response format:', data);
-          }
-          
+          const transformedItems = processApiItems(data);
           setItems(transformedItems);
-          setPagination({
-            currentPage: data.currentPage || 1,
-            totalPages: data.totalPages || Math.ceil((data.totalCards || data.totalItems || transformedItems.length) / pagination.pageSize),
-            totalItems: data.totalCards || data.totalItems || transformedItems.length,
-            pageSize: pagination.pageSize
-          });
+          updatePagination(data, transformedItems);
         } else {
           setError(data.error || 'Failed to fetch items');
         }
@@ -160,174 +91,65 @@ const CatalogPanel = () => {
         console.error('Error fetching catalog items:', error);
         setError('Failed to fetch catalog items. Please try again.');
       })
-      .finally(() => {
-        setLoading(false);
-      });
+      .finally(() => setLoading(false));
   };
 
-  // Handle refresh button click
-  const handleRefresh = () => {
-    // Clear search if in search mode
+  const handlePageChange = (newPage) => {
     if (isSearchMode) {
-      setIsSearchMode(false);
-      setSearchResults({
-        items: [],
-        currentPage: 1,
-        totalPages: 1,
-        totalItems: 0,
-        searchTerm: ''
-      });
-      setSearchTerm('');
+      fetchSearchPage(newPage);
+    } else {
+      fetchItemsPage(newPage);
     }
-    
-    // Fetch items again
-    fetchCatalogItems();
   };
 
-  // Initial fetch on component mount
-  useEffect(() => {
-    fetchCatalogItems();
-  }, []);
-
-  // Helper function to extract a simple content type from MIME type
-  const getSimpleContentType = (mimeType) => {
-    if (!mimeType) return null;
-    
-    // Extract the subtype from the MIME type
-    const parts = mimeType.split('/');
-    if (parts.length < 2) return null;
-    
-    const subtype = parts[1];
-    
-    // Handle special cases
-    if (subtype.includes('json')) return 'json';
-    if (subtype.includes('javascript')) return 'js';
-    if (subtype === 'plain') return 'txt';
-    if (subtype === 'html') return 'html';
-    if (subtype === 'css') return 'css';
-    if (subtype === 'svg+xml') return 'svg';
-    
-    // Return the subtype as-is for common formats (gif, png, jpg, etc.)
-    return subtype;
+  const fetchItemsPage = (newPage) => {
+    setLoading(true);
+    fetch(`/api/card-collection?action=getPage&pageNumber=${newPage}&pageSize=${pagination.pageSize}`)
+      .then(response => response.json())
+      .then(data => {
+        if (data.success) {
+          const transformedItems = processApiItems(data);
+          setItems(transformedItems);
+          updatePagination(data, transformedItems);
+        } else {
+          setError(data.error || 'Failed to fetch items');
+        }
+      })
+      .catch(error => {
+        console.error('Error fetching catalog items:', error);
+        setError('Failed to fetch catalog items. Please try again.');
+      })
+      .finally(() => setLoading(false));
   };
 
-  // Handle pagination change
-  const handlePageChange = (newPage) => {
-    if (isSearchMode) {
-      setSearchLoading(true);
-      setSearchError(null);
-      
-      fetch(`/api/card-collection?action=searchByContent&searchTerm=${encodeURIComponent(searchResults.searchTerm)}&pageNumber=${newPage}&pageSize=${pagination.pageSize}`)
-        .then(response => response.json())
-        .then(data => {
-          if (data.success) {
-            // Transform cards into catalog items
-            let transformedItems = [];
-            
-            if (data.cards && Array.isArray(data.cards)) {
-              transformedItems = data.cards.map(card => ({
-                id: card.hash,
-                name: card.hash.substring(0, 8),
-                category: card.contentType?.mimeType || 'Unknown',
-                description: 'Matching content: ' + (card.matchContext || ''),
-                hash: card.hash,
-                timestamp: card.timestamp || new Date().toISOString(),
-                contentType: card.contentType
-              }));
-            } else if (data.items && Array.isArray(data.items)) {
-              transformedItems = data.items.map(item => ({
-                id: item.id || item.hash,
-                name: item.name || (item.hash ? item.hash.substring(0, 8) : 'Unknown'),
-                category: item.category || item.contentType?.mimeType || 'Unknown',
-                description: item.description || 'No description available',
-                timestamp: item.timestamp || new Date().toISOString(),
-                hash: item.hash || item.id,
-                contentType: item.contentType || { mimeType: 'text/plain' }
-              }));
-            } else {
-              console.warn('Unexpected API search response format:', data);
-            }
-            
-            setSearchResults({
-              items: transformedItems,
-              currentPage: data.currentPage || newPage,
-              totalPages: data.totalPages || Math.ceil((data.totalResults || data.totalItems || transformedItems.length) / pagination.pageSize),
-              totalItems: data.totalResults || data.totalItems || transformedItems.length,
-              searchTerm: searchResults.searchTerm
-            });
-          } else {
-            setSearchError(data.error || 'Search failed');
-          }
-        })
-        .catch(error => {
-          console.error('Error searching catalog items:', error);
-          setSearchError('Search failed. Please try again.');
-        })
-        .finally(() => {
-          setSearchLoading(false);
-        });
-    } else {
-      setLoading(true);
-      setError(null);
-      
-      fetch(`/api/card-collection?action=getPage&pageNumber=${newPage}&pageSize=${pagination.pageSize}`)
-        .then(response => response.json())
-        .then(data => {
-          if (data.success) {
-            // Transform cards into catalog items
-            let transformedItems = [];
-            
-            if (data.cards && Array.isArray(data.cards)) {
-              transformedItems = data.cards.map(card => ({
-                id: card.hash,
-                name: card.hash.substring(0, 8),
-                category: card.contentType?.mimeType || 'Unknown',
-                description: 'Card content hash: ' + card.hash,
-                timestamp: card.timestamp || new Date().toISOString(),
-                hash: card.hash,
-                contentType: card.contentType,
-                metaData: card.metaData || {}
-              }));
-            } else if (data.items && Array.isArray(data.items)) {
-              transformedItems = data.items.map(item => ({
-                id: item.id || item.hash,
-                name: item.name || (item.hash ? item.hash.substring(0, 8) : 'Unknown'),
-                category: item.category || item.contentType?.mimeType || 'Unknown',
-                description: item.description || 'No description available',
-                timestamp: item.timestamp || new Date().toISOString(),
-                hash: item.hash || item.id,
-                contentType: item.contentType || { mimeType: 'text/plain' },
-                metaData: item.metaData || {}
-              }));
-            } else {
-              console.warn('Unexpected API response format:', data);
-            }
-            
-            setItems(transformedItems);
-            setPagination({
-              currentPage: data.currentPage || newPage,
-              totalPages: data.totalPages || Math.ceil((data.totalCards || data.totalItems || transformedItems.length) / pagination.pageSize),
-              totalItems: data.totalCards || data.totalItems || transformedItems.length,
-              pageSize: pagination.pageSize
-            });
-          } else {
-            setError(data.error || 'Failed to fetch items');
-          }
-        })
-        .catch(error => {
-          console.error('Error fetching catalog items:', error);
-          setError('Failed to fetch catalog items. Please try again.');
-        })
-        .finally(() => {
-          setLoading(false);
-        });
-    }
+  const fetchSearchPage = (newPage) => {
+    setSearchLoading(true);
+    fetch(`/api/card-collection?action=searchByContent&searchTerm=${encodeURIComponent(searchResults.searchTerm)}&pageNumber=${newPage}&pageSize=${pagination.pageSize}`)
+      .then(response => response.json())
+      .then(data => {
+        if (data.success) {
+          const transformedItems = processApiItems(data);
+          setSearchResults({
+            items: transformedItems,
+            currentPage: data.currentPage || newPage,
+            totalPages: data.totalPages || Math.ceil((data.totalResults || data.totalItems || transformedItems.length) / pagination.pageSize),
+            totalItems: data.totalResults || data.totalItems || transformedItems.length,
+            searchTerm: searchResults.searchTerm
+          });
+        } else {
+          setSearchError(data.error || 'Search failed');
+        }
+      })
+      .catch(error => {
+        console.error('Error searching catalog items:', error);
+        setSearchError('Search failed. Please try again.');
+      })
+      .finally(() => setSearchLoading(false));
   };
 
-  // Handle item selection
+  // Item Actions
   const handleSelectItem = (item) => {
     setItemLoading(true);
-    setItemError(null);
     setViewMode('detail');
     
     fetch(`/api/card-collection?action=get&hash=${item.id}`)
@@ -335,33 +157,14 @@ const CatalogPanel = () => {
       .then(data => {
         if (data.success) {
           const cardData = data.card;
-          
-          // Get content type from server response
           const serverContentType = cardData.contentType;
-          console.log("Server-provided content type:", serverContentType);
-          
-          // Extract a simple content type string for the UI
           const simpleType = serverContentType?.extension || 
                          (serverContentType?.mimeType ? getSimpleContentType(serverContentType.mimeType) : null) || 
                          "txt";
           
-          console.log("Using content type:", simpleType);
-          
-          // Process the content based on its type
-          let description = 'Binary content';
-          const content = cardData.content;
+          // Process content for display
+          let description = processContentForDisplay(cardData.content);
           
-          if (typeof content === 'string') {
-            description = content.substring(0, 200) + (content.length > 200 ? '...' : '');
-          } else if (content && typeof content === 'object') {
-            if (content.type === 'string') {
-              description = content.data.substring(0, 200) + (content.data.length > 200 ? '...' : '');
-            } else if (content.type === 'base64') {
-              description = `Binary content (${content.originalType || 'unknown type'})`;
-            }
-          }
-          
-          // Set the selected item with all details
           setSelectedItem({
             id: cardData.hash,
             name: cardData.hash.substring(0, 8),
@@ -373,24 +176,15 @@ const CatalogPanel = () => {
             contentType: cardData.contentType
           });
           
-          // Import the card to contentSlice Redux store for cross-panel integration
+          // Update Redux store
           dispatch(importCardFromDatabase({ 
             hash: cardData.hash,
             content: cardData.content,
-            metadata: {
-              contentType: serverContentType
-            },
-            relationships: {
-              parentHash: null,
-              childHashes: [],
-              relatedHashes: []
-            }
+            metadata: { contentType: serverContentType },
+            relationships: { parentHash: null, childHashes: [], relatedHashes: [] }
           }));
           
-          // Select the card in Redux
           dispatch(selectContent(cardData.hash));
-          
-          // Update the selectedItem state with card details for selected item slice
           dispatch(selectItem({
             item: cardData.content,
             hash: cardData.hash,
@@ -405,26 +199,19 @@ const CatalogPanel = () => {
         console.error('Error fetching card by ID:', error);
         setItemError('Failed to fetch card. Please try again.');
       })
-      .finally(() => {
-        setItemLoading(false);
-      });
+      .finally(() => setItemLoading(false));
   };
 
-  // Handle item deletion
   const handleDeleteItem = (id) => {
     if (window.confirm('Are you sure you want to delete this item?')) {
-      fetch(`/api/card-collection?action=delete&hash=${id}`, { 
-        method: 'DELETE' 
-      })
+      fetch(`/api/card-collection?action=delete&hash=${id}`, { method: 'DELETE' })
         .then(response => response.json())
         .then(data => {
           if (data.success) {
-            // Remove item from state
             setItems(prevItems => prevItems.filter(item => item.id !== id));
-            // If we're viewing the item that was deleted, go back to list view
             if (selectedItem && selectedItem.id === id) {
               setSelectedItem(null);
-              setViewMode('list');
+              setViewMode('grid');
             }
           } else {
             setError(data.error || 'Failed to delete item');
@@ -437,58 +224,36 @@ const CatalogPanel = () => {
     }
   };
 
-  // Handle search submission
+  const handleAddItem = (newItemData) => {
+    if (newItemData.file) {
+      addFileItem(newItemData);
+    } else if (newItemData.description) {
+      addTextItem(newItemData);
+    }
+  };
+
+  // UI Handlers
+  const handleRefresh = () => {
+    if (isSearchMode) clearSearch();
+    fetchCatalogItems();
+  };
+
   const handleSearchSubmit = (e) => {
     e.preventDefault();
     
     if (!searchTerm.trim()) {
-      // Clear search if empty
-      setIsSearchMode(false);
-      setSearchResults({
-        items: [],
-        currentPage: 1,
-        totalPages: 1,
-        totalItems: 0,
-        searchTerm: ''
-      });
+      clearSearch();
       return;
     }
     
     setIsSearchMode(true);
     setSearchLoading(true);
-    setSearchError(null);
     
     fetch(`/api/card-collection?action=searchByContent&searchTerm=${encodeURIComponent(searchTerm)}&pageNumber=1&pageSize=${pagination.pageSize}`)
       .then(response => response.json())
       .then(data => {
         if (data.success) {
-          // Transform cards into catalog items
-          let transformedItems = [];
-          
-          if (data.cards && Array.isArray(data.cards)) {
-            transformedItems = data.cards.map(card => ({
-              id: card.hash,
-              name: card.hash.substring(0, 8),
-              category: card.contentType?.mimeType || 'Unknown',
-              description: 'Matching content: ' + (card.matchContext || ''),
-              hash: card.hash,
-              timestamp: card.timestamp || new Date().toISOString(),
-              contentType: card.contentType
-            }));
-          } else if (data.items && Array.isArray(data.items)) {
-            transformedItems = data.items.map(item => ({
-              id: item.id || item.hash,
-              name: item.name || (item.hash ? item.hash.substring(0, 8) : 'Unknown'),
-              category: item.category || item.contentType?.mimeType || 'Unknown',
-              description: item.description || 'No description available',
-              timestamp: item.timestamp || new Date().toISOString(),
-              hash: item.hash || item.id,
-              contentType: item.contentType || { mimeType: 'text/plain' }
-            }));
-          } else {
-            console.warn('Unexpected API search response format:', data);
-          }
-          
+          const transformedItems = processApiItems(data);
           setSearchResults({
             items: transformedItems,
             currentPage: data.currentPage || 1,
@@ -504,949 +269,236 @@ const CatalogPanel = () => {
         console.error('Error searching catalog items:', error);
         setSearchError('Search failed. Please try again.');
       })
-      .finally(() => {
-        setSearchLoading(false);
-      });
-  };
-
-  // Handle new item submission
-  const handleAddItem = (e) => {
-    e.preventDefault();
-    
-    if (!newItem.name) {
-      alert('Please provide a name for the new item');
-      return;
-    }
-    
-    if (newItem.file) {
-      // File upload
-      const formData = new FormData();
-      formData.append('file', newItem.file);
-      
-      // Create the metadata object as required by the API
-      const metadata = {
-        fileName: newItem.name,
-        mimeType: newItem.contentType || 'application/octet-stream',
-        size: newItem.file.size,
-        description: newItem.description || ''
-      };
-      
-      // Append metadata as a JSON string
-      formData.append('metadata', JSON.stringify(metadata));
-      // Append action to formData (since it's multipart form)
-      formData.append('action', 'add');
-      
-      setLoading(true);
-      setError(null);
-      
-      fetch('/api/card-collection?action=add', {
-        method: 'POST',
-        body: formData
-      })
-        .then(response => {
-          if (!response.ok) {
-            return response.json().then(data => {
-              throw new Error(data.error || `Server responded with ${response.status}`);
-            });
-          }
-          return response.json();
-        })
-        .then(data => {
-          if (data.success) {
-            // Add new item to the state
-            const newCardItem = {
-              id: data.hash,
-              name: newItem.name,
-              description: newItem.description || 'Added file',
-              category: newItem.contentType || 'application/octet-stream',
-              hash: data.hash,
-              timestamp: new Date().toISOString(),
-              contentType: { mimeType: newItem.contentType || 'application/octet-stream' }
-            };
-            
-            setItems(prevItems => [...prevItems, newCardItem]);
-            
-            // Reset form
-            setNewItem({
-              name: '',
-              description: '',
-              contentType: 'text/plain',
-              file: null
-            });
-            setFileInput(null);
-            setViewMode('list');
-          } else {
-            setError(data.error || 'Failed to add item');
-          }
-        })
-        .catch(error => {
-          console.error('Error adding catalog item:', error);
-          setError(`Failed to add item: ${error.message}`);
-        })
-        .finally(() => {
-          setLoading(false);
-        });
-    } else if (newItem.description) {
-      // Text content
-      setLoading(true);
-      setError(null);
-      
-      fetch('/api/card-collection?action=add', {
-        method: 'POST',
-        headers: { 'Content-Type': 'application/json' },
-        body: JSON.stringify({
-          action: 'add',
-          card: {
-            content: newItem.description,
-            hash_algorithm: 'sha256'
-          }
-        })
-      })
-        .then(response => {
-          if (!response.ok) {
-            return response.json().then(data => {
-              throw new Error(data.error || `Server responded with ${response.status}`);
-            });
-          }
-          return response.json();
-        })
-        .then(data => {
-          if (data.success) {
-            // Add new item to state
-            const newCardItem = {
-              id: data.hash,
-              name: newItem.name,
-              description: newItem.description.substring(0, 100) + (newItem.description.length > 100 ? '...' : ''),
-              category: newItem.contentType || 'text/plain',
-              hash: data.hash,
-              timestamp: new Date().toISOString(),
-              contentType: { mimeType: newItem.contentType || 'text/plain' }
-            };
-            
-            setItems(prevItems => [...prevItems, newCardItem]);
-            
-            // Reset form
-            setNewItem({
-              name: '',
-              description: '',
-              contentType: 'text/plain',
-              file: null
-            });
-            setViewMode('list');
-          } else {
-            setError(data.error || 'Failed to add item');
-          }
-        })
-        .catch(error => {
-          console.error('Error adding catalog item:', error);
-          setError(`Failed to add item: ${error.message}`);
-        })
-        .finally(() => {
-          setLoading(false);
-        });
-    } else {
-      alert('Please provide content to add');
-    }
+      .finally(() => setSearchLoading(false));
   };
 
-  // Clear search and return to normal view
-  const handleClearSearch = () => {
-    setSearchTerm('');
+  const clearSearch = () => {
     setIsSearchMode(false);
     setSearchResults({
-      items: [],
-      currentPage: 1,
-      totalPages: 1,
-      totalItems: 0,
-      searchTerm: ''
+      items: [], currentPage: 1, totalPages: 1, totalItems: 0, searchTerm: ''
     });
+    setSearchTerm('');
   };
 
-  // Handle file input change
-  const handleFileChange = (e) => {
-    const file = e.target.files[0];
-    if (file) {
-      setFileInput(file);
-      setNewItem({
-        ...newItem,
-        name: file.name,
-        contentType: file.type || 'application/octet-stream',
-        file: file
+  // Helper functions
+  const processApiItems = (data) => {
+    if (data.cards && Array.isArray(data.cards)) {
+      return data.cards.map(card => {
+        // Ensure contentType is properly structured
+        const contentType = card.contentType || { mimeType: 'text/plain' };
+        
+        return {
+          id: card.hash,
+          name: card.hash.substring(0, 8),
+          category: contentType.mimeType || 'Unknown',
+          description: 'Card content hash: ' + card.hash,
+          timestamp: card.timestamp || new Date().toISOString(),
+          hash: card.hash,
+          contentType: contentType, // Preserve the full contentType object
+          metaData: card.metaData || {}
+        };
       });
-    }
-  };
-
-  // Drag and drop handlers
-  const handleDragEnter = (e) => {
-    e.preventDefault();
-    e.stopPropagation();
-    setIsDragging(true);
-  };
-
-  const handleDragOver = (e) => {
-    e.preventDefault();
-    e.stopPropagation();
-    if (!isDragging) {
-      setIsDragging(true);
-    }
-  };
-
-  const handleDragLeave = (e) => {
-    e.preventDefault();
-    e.stopPropagation();
-    
-    // Only set dragging to false if leaving the drop zone itself, not its children
-    if (dropZoneRef.current && !dropZoneRef.current.contains(e.relatedTarget)) {
-      setIsDragging(false);
-    }
-  };
-
-  const handleDrop = (e) => {
-    e.preventDefault();
-    e.stopPropagation();
-    setIsDragging(false);
+    } 
     
-    const files = e.dataTransfer.files;
-    if (files && files.length > 0) {
-      const file = files[0]; // Take only the first file if multiple are dropped
-      setFileInput(file);
-      setNewItem({
-        ...newItem,
-        name: file.name,
-        contentType: file.type || 'application/octet-stream',
-        file: file
+    if (data.items && Array.isArray(data.items)) {
+      return data.items.map(item => {
+        // Ensure contentType is properly structured
+        const contentType = item.contentType || { mimeType: 'text/plain' };
+        
+        return {
+          id: item.id || item.hash,
+          name: item.name || (item.hash ? item.hash.substring(0, 8) : 'Unknown'),
+          category: item.category || contentType.mimeType || 'Unknown',
+          description: item.description || 'No description available',
+          timestamp: item.timestamp || new Date().toISOString(),
+          hash: item.hash || item.id,
+          contentType: contentType, // Preserve the full contentType object
+          metaData: item.metaData || {}
+        };
       });
-      
-      // If not in the add view mode, switch to it
-      if (viewMode !== 'add') {
-        setViewMode('add');
-      }
     }
+    
+    console.warn('Unexpected API response format:', data);
+    return [];
   };
 
-  // Handle form input changes
-  const handleInputChange = (e) => {
-    const { name, value } = e.target;
-    setNewItem({
-      ...newItem,
-      [name]: value
+  const updatePagination = (data, items) => {
+    setPagination({
+      currentPage: data.currentPage || 1,
+      totalPages: data.totalPages || Math.ceil((data.totalCards || data.totalItems || items.length) / pagination.pageSize),
+      totalItems: data.totalCards || data.totalItems || items.length,
+      pageSize: pagination.pageSize
     });
   };
 
-  // Get thumbnail for different content types
-  const getCardThumbnail = (item) => {
-    const contentType = item.contentType?.mimeType || 'unknown';
-    const simpleType = getSimpleContentType(contentType);
+  const processContentForDisplay = (content) => {
+    let description = 'Binary content';
     
-    // Image thumbnails for image types
-    if (contentType.startsWith('image/')) {
-      return (
-        <img 
-          src={`/api/card-collection?action=get&hash=${item.id}`} 
-          alt={item.name} 
-          onError={(e) => {
-            e.target.onerror = null;
-            e.target.src = "https://placehold.co/300x300?text=No+Preview";
-          }}
-        />
-      );
+    if (typeof content === 'string') {
+      description = content.substring(0, 200) + (content.length > 200 ? '...' : '');
+    } else if (content && typeof content === 'object') {
+      if (content.type === 'string') {
+        description = content.data.substring(0, 200) + (content.data.length > 200 ? '...' : '');
+      } else if (content.type === 'base64') {
+        description = `Binary content (${content.originalType || 'unknown type'})`;
+      }
     }
     
-    // Icons or placeholders for other content types
-    const contentTypeDisplay = {
-      'json': 'JSON',
-      'txt': 'TXT',
-      'csv': 'CSV',
-      'pdf': 'PDF',
-      'mp3': 'üéµ Audio',
-      'wav': 'üéµ Audio',
-      'mp4': 'üé¨ Video',
-      'png': 'üñºÔ∏è Image',
-      'jpg': 'üñºÔ∏è Image',
-      'jpeg': 'üñºÔ∏è Image',
-      'gif': 'üñºÔ∏è Image',
-      'js': 'JS',
-      'html': 'HTML',
-      'xml': 'XML',
-      'css': 'CSS',
-      'svg': 'SVG'
-    };
-    
-    // Use the simple type for display if available
-    const displayType = simpleType && contentTypeDisplay[simpleType] 
-      ? contentTypeDisplay[simpleType]
-      : contentType || 'Unknown';
-    
-    return (
-      <div className="image-placeholder">
-        {displayType}
-      </div>
-    );
-  };
-
-  // Render list view with card-based layout
-  const renderListView = () => {
-    if (loading || searchLoading) {
-      return <div className="loading-indicator">Loading items...</div>;
-    }
-
-    if (error) {
-      return <div className="error-message">Error: {error}</div>;
-    }
-
-    if (searchError) {
-      return <div className="error-message">Search error: {searchError}</div>;
-    }
-
-    if (sortedItems.length === 0) {
-      return (
-        <div className="empty-state">
-          {isSearchMode 
-            ? <p>No results found for "{searchResults.searchTerm}"</p>
-            : <p>No items available. Add your first item to get started.</p>
-          }
-        </div>
-      );
-    }
-
-    return (
-      <>
-        <div className="catalog-list-cards">
-          {sortedItems.map(item => (
-            <div key={item.id} className="list-card">
-              <div className="list-card-inner" onClick={() => handleSelectItem(item)}>
-                <div className="list-card-thumbnail">
-                  {getCardThumbnail(item)}
-                </div>
-                <div className="list-card-content">
-                  <h3 className="list-card-title">{item.name}</h3>
-                  <div className="list-card-meta">
-                    <span className="list-card-type">
-                      {item.contentType?.mimeType 
-                        ? getSimpleContentType(item.contentType.mimeType) || item.contentType.mimeType 
-                        : 'Unknown'}
-                    </span>
-                    <span className="list-card-date">
-                      {new Date(item.timestamp).toLocaleString()}
-                    </span>
-                  </div>
-                  <p className="list-card-description">{item.description}</p>
-                </div>
-                <div className="list-card-actions">
-                  <button 
-                    className="btn btn-small btn-info"
-                    onClick={(e) => {
-                      e.stopPropagation();
-                      handleSelectItem(item);
-                    }}
-                  >
-                    View
-                  </button>
-                  <button 
-                    className="btn btn-small btn-danger"
-                    onClick={(e) => {
-                      e.stopPropagation();
-                      handleDeleteItem(item.id);
-                    }}
-                  >
-                    Delete
-                  </button>
-                </div>
-              </div>
-            </div>
-          ))}
-        </div>
-        
-        {/* Pagination */}
-        {paginationInfo.totalPages > 1 && (
-          <div className="pagination-controls">
-            <button 
-              className="btn btn-pagination" 
-              disabled={paginationInfo.currentPage <= 1}
-              onClick={() => handlePageChange(paginationInfo.currentPage - 1)}
-            >
-              Previous
-            </button>
-            <span className="pagination-info">
-              Page {paginationInfo.currentPage} of {paginationInfo.totalPages}
-              {paginationInfo.totalItems && ` (${paginationInfo.totalItems} total items)`}
-            </span>
-            <button 
-              className="btn btn-pagination" 
-              disabled={paginationInfo.currentPage >= paginationInfo.totalPages}
-              onClick={() => handlePageChange(paginationInfo.currentPage + 1)}
-            >
-              Next
-            </button>
-          </div>
-        )}
-      </>
-    );
-  };
-
-  // Render grid view
-  const renderGridView = () => {
-    if (loading || searchLoading) {
-      return <div className="loading-indicator">Loading items...</div>;
-    }
-
-    if (error) {
-      return <div className="error-message">Error: {error}</div>;
-    }
-
-    if (searchError) {
-      return <div className="error-message">Search error: {searchError}</div>;
-    }
-
-    if (sortedItems.length === 0) {
-      return (
-        <div className="empty-state">
-          {isSearchMode 
-            ? <p>No results found for "{searchResults.searchTerm}"</p>
-            : <p>No items available. Add your first item to get started.</p>
-          }
-        </div>
-      );
-    }
-
-    return (
-      <>
-        <div className="catalog-grid-view">
-          {sortedItems.map(item => (
-            <div key={item.id} className="grid-item">
-              <div 
-                className="grid-item-card" 
-                onClick={() => handleSelectItem(item)}
-              >
-                <div className="grid-item-thumbnail">
-                  {getCardThumbnail(item)}
-                </div>
-                <div className="grid-item-info">
-                  <h3 className="grid-item-title">{item.name}</h3>
-                  <div className="grid-item-meta">
-                    <span className="grid-item-type">
-                      {item.contentType?.mimeType 
-                        ? getSimpleContentType(item.contentType.mimeType) || item.contentType.mimeType 
-                        : 'Unknown'}
-                    </span>
-                    <span className="grid-item-date">
-                      {new Date(item.timestamp).toLocaleDateString()}
-                    </span>
-                  </div>
-                  <p className="grid-item-description">{item.description}</p>
-                </div>
-                <div className="grid-item-actions">
-                  <button 
-                    className="btn btn-small btn-danger"
-                    onClick={(e) => {
-                      e.stopPropagation();
-                      handleDeleteItem(item.id);
-                    }}
-                  >
-                    Delete
-                  </button>
-                </div>
-              </div>
-            </div>
-          ))}
-        </div>
-        
-        {/* Pagination */}
-        {paginationInfo.totalPages > 1 && (
-          <div className="pagination-controls">
-            <button 
-              className="btn btn-pagination" 
-              disabled={paginationInfo.currentPage <= 1}
-              onClick={() => handlePageChange(paginationInfo.currentPage - 1)}
-            >
-              Previous
-            </button>
-            <span className="pagination-info">
-              Page {paginationInfo.currentPage} of {paginationInfo.totalPages}
-              {paginationInfo.totalItems && ` (${paginationInfo.totalItems} total items)`}
-            </span>
-            <button 
-              className="btn btn-pagination" 
-              disabled={paginationInfo.currentPage >= paginationInfo.totalPages}
-              onClick={() => handlePageChange(paginationInfo.currentPage + 1)}
-            >
-              Next
-            </button>
-          </div>
-        )}
-      </>
-    );
+    return description;
   };
 
-  // Render detail view
-  const renderDetailView = () => {
-    if (itemLoading) {
-      return <div className="loading-indicator">Loading item details...</div>;
-    }
-
-    if (itemError) {
-      return <div className="error-message">Error: {itemError}</div>;
-    }
-
-    if (!selectedItem) {
-      return <div className="error-message">Item not found</div>;
-    }
+  const addFileItem = (newItemData) => {
+    const formData = new FormData();
+    formData.append('file', newItemData.file);
     
-    // Process and display content based on type
-    const renderContent = () => {
-      if (!selectedItem?.content) {
-        return <div className="empty-content">No content available</div>;
-      }
-      
-      const contentType = selectedItem.contentType || { mimeType: 'text/plain' };
-      
-      // Universal content wrapper to enforce containment
-      const ContentWrapper = ({ children, className = '' }) => (
-        <div className={`universal-content-wrapper ${className}`}>
-          {children}
-        </div>
-      );
-      
-      // Handle different content types
-      if (contentType.mimeType?.startsWith('image/')) {
-        return (
-          <ContentWrapper className="image-wrapper">
-            <img src={`data:${contentType.mimeType};base64,${selectedItem.content}`} alt="Content Preview" className="content-image" />
-          </ContentWrapper>
-        );
-      } else if (contentType.mimeType === 'application/pdf') {
-        return (
-          <ContentWrapper className="pdf-wrapper">
-            <div className="pdf-container">
-              <iframe src={`data:${contentType.mimeType};base64,${selectedItem.content}`} className="pdf-frame" title="PDF Viewer"></iframe>
-            </div>
-          </ContentWrapper>
-        );
-      } else if (contentType.mimeType?.startsWith('audio/')) {
-        return (
-          <ContentWrapper className="audio-wrapper">
-            <audio controls className="content-audio">
-              <source src={`data:${contentType.mimeType};base64,${selectedItem.content}`} type={contentType.mimeType} />
-              Your browser does not support the audio element.
-            </audio>
-          </ContentWrapper>
-        );
-      } else if (contentType.mimeType?.startsWith('video/')) {
-        return (
-          <ContentWrapper className="video-wrapper">
-            <video controls className="content-video">
-              <source src={`data:${contentType.mimeType};base64,${selectedItem.content}`} type={contentType.mimeType} />
-              Your browser does not support the video element.
-            </video>
-          </ContentWrapper>
-        );
-      } else if (contentType.mimeType === 'text/html') {
-        return (
-          <ContentWrapper className="html-wrapper">
-            <div className="html-content" dangerouslySetInnerHTML={{ __html: selectedItem.content }}></div>
-          </ContentWrapper>
-        );
-      } else if (contentType.mimeType === 'application/json' || 
-                 (typeof selectedItem.content === 'string' && selectedItem.content.trim().startsWith('{'))) {
-        // Parse JSON if it's not already an object
-        let jsonContent;
-        try {
-          jsonContent = typeof selectedItem.content === 'string' 
-            ? JSON.parse(selectedItem.content) 
-            : selectedItem.content;
-        } catch (e) {
-          console.error('Error parsing JSON:', e);
-          return (
-            <ContentWrapper className="text-wrapper">
-              <pre className="content-text">
-                {typeof selectedItem.content === 'string' 
-                  ? selectedItem.content 
-                  : JSON.stringify(selectedItem.content, null, 2)}
-              </pre>
-            </ContentWrapper>
-          );
-        }
-        
-        return (
-          <ContentWrapper className="json-wrapper">
-            {renderJsonWithHighlighting(jsonContent)}
-          </ContentWrapper>
-        );
-      } else if (contentType.mimeType === 'text/csv' || contentType.extension === 'csv') {
-        return (
-          <ContentWrapper className="csv-wrapper">
-            <div className="csv-content">
-              <table className="csv-table">
-                <tbody>
-                  {typeof selectedItem.content === 'string' && 
-                    selectedItem.content.split('\n').map((row, rowIndex) => (
-                      <tr key={rowIndex}>
-                        {row.split(',').map((cell, cellIndex) => (
-                          <td key={cellIndex} className="csv-cell">
-                            {cell.length > 50 ? cell.substring(0, 47) + '...' : cell}
-                          </td>
-                        ))}
-                      </tr>
-                    ))}
-                </tbody>
-              </table>
-            </div>
-          </ContentWrapper>
-        );
-      } else {
-        // Default text display
-        return (
-          <ContentWrapper className="text-wrapper">
-            <div className="content-controls">
-              <div className="text-content-options">
-                <label>
-                  <input 
-                    type="checkbox" 
-                    checked={!wordWrap} 
-                    onChange={() => setWordWrap(!wordWrap)} 
-                  />
-                  Disable word wrap
-                </label>
-              </div>
-              <pre className={`content-text ${!wordWrap ? 'wrap-text' : 'nowrap-text'}`}>
-                {typeof selectedItem.content === 'string' 
-                  ? selectedItem.content 
-                  : JSON.stringify(selectedItem.content, null, 2)}
-              </pre>
-            </div>
-          </ContentWrapper>
-        );
-      }
+    const metadata = {
+      fileName: newItemData.name,
+      mimeType: newItemData.contentType || 'application/octet-stream',
+      size: newItemData.file.size,
+      description: newItemData.description || ''
     };
     
-    return (
-      <div className="catalog-detail-view">
-        <div className="catalog-detail-header">
-          <button 
-            className="btn btn-back"
-            onClick={() => setViewMode('list')}
-          >
-            Back
-          </button>
-          <h2>{selectedItem.name}</h2>
-        </div>
-        
-        <div className="catalog-detail-content">
-          <div className="catalog-detail-info">
-            <div className="info-section">
-              <p><strong>Hash:</strong> {selectedItem.hash}</p>
-              <p><strong>Type:</strong> {
-                selectedItem.contentType?.mimeType 
-                  ? `${getSimpleContentType(selectedItem.contentType.mimeType) || selectedItem.contentType.mimeType} (${selectedItem.contentType.mimeType})` 
-                  : 'Unknown'
-              }</p>
-              <p><strong>gtime:</strong> {new Date(selectedItem.timestamp).toLocaleString()}</p>
-            </div>
-            
-            <div className="content-section">
-              <h3>Content</h3>
-              <div className="content-container">
-                {renderContent()}
-              </div>
-            </div>
-            
-            <div className="catalog-detail-actions">
-              <button 
-                className="btn btn-danger"
-                onClick={() => handleDeleteItem(selectedItem.hash)}
-              >
-                Delete
-              </button>
-            </div>
-          </div>
-        </div>
-      </div>
-    );
+    formData.append('metadata', JSON.stringify(metadata));
+    formData.append('action', 'add');
+    
+    setLoading(true);
+    
+    fetch('/api/card-collection?action=add', {
+      method: 'POST',
+      body: formData
+    })
+      .then(response => {
+        if (!response.ok) {
+          return response.json().then(data => {
+            throw new Error(data.error || `Server responded with ${response.status}`);
+          });
+        }
+        return response.json();
+      })
+      .then(data => {
+        if (data.success) {
+          const newCardItem = {
+            id: data.hash,
+            name: newItemData.name,
+            description: newItemData.description || 'Added file',
+            category: newItemData.contentType || 'application/octet-stream',
+            hash: data.hash,
+            timestamp: new Date().toISOString(),
+            contentType: { mimeType: newItemData.contentType || 'application/octet-stream' }
+          };
+          
+          setItems(prevItems => [...prevItems, newCardItem]);
+          setViewMode('grid');
+        } else {
+          setError(data.error || 'Failed to add item');
+        }
+      })
+      .catch(error => {
+        console.error('Error adding catalog item:', error);
+        setError(`Failed to add item: ${error.message}`);
+      })
+      .finally(() => setLoading(false));
   };
 
-  // Helper function to render JSON with syntax highlighting and guaranteed wrapping
-  const renderJsonWithHighlighting = (jsonObj) => {
-    // Convert JSON to a vertical display format that won't overflow
-    const renderJsonAsTable = (obj, depth = 0) => {
-      // For primitive values, just return them formatted
-      if (typeof obj !== 'object' || obj === null) {
-        return renderPrimitiveValue(obj);
-      }
-      
-      // Recursive table builder
-      const rows = [];
-      
-      // Handle arrays or objects
-      const isArray = Array.isArray(obj);
-      
-      // For each key/index in the object/array
-      Object.entries(obj).forEach(([key, value], index) => {
-        // Create indentation based on depth
-        const indent = '  '.repeat(depth);
-        const displayKey = isArray ? `[${key}]` : key;
-        
-        // If value is an object, recurse, otherwise format the primitive
-        if (typeof value === 'object' && value !== null) {
-          // For objects/arrays, create a row with the key and a placeholder
-          rows.push(
-            `<tr>
-              <td class="json-key-cell">${indent}${displayKey}:</td>
-              <td class="json-value-cell">${isArray ? '[]' : '{'}...</td>
-            </tr>`
-          );
-          
-          // Add the nested object as indented rows
-          rows.push(renderJsonAsTable(value, depth + 1));
+  const addTextItem = (newItemData) => {
+    setLoading(true);
+    
+    fetch('/api/card-collection?action=add', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({
+        action: 'add',
+        card: {
+          content: newItemData.description,
+          hash_algorithm: 'sha256'
+        }
+      })
+    })
+      .then(response => {
+        if (!response.ok) {
+          return response.json().then(data => {
+            throw new Error(data.error || `Server responded with ${response.status}`);
+          });
+        }
+        return response.json();
+      })
+      .then(data => {
+        if (data.success) {
+          const newCardItem = {
+            id: data.hash,
+            name: newItemData.name,
+            description: newItemData.description.substring(0, 100) + (newItemData.description.length > 100 ? '...' : ''),
+            category: newItemData.contentType || 'text/plain',
+            hash: data.hash,
+            timestamp: new Date().toISOString(),
+            contentType: { mimeType: newItemData.contentType || 'text/plain' }
+          };
           
-          // Close the object
-          rows.push(
-            `<tr>
-              <td class="json-key-cell">${indent}</td>
-              <td class="json-value-cell">${isArray ? ']' : '}'}</td>
-            </tr>`
-          );
+          setItems(prevItems => [...prevItems, newCardItem]);
+          setViewMode('grid');
         } else {
-          // For primitive values, just add a row with the key and value
-          rows.push(
-            `<tr>
-              <td class="json-key-cell">${indent}${displayKey}:</td>
-              <td class="json-value-cell">${renderPrimitiveValue(value)}</td>
-            </tr>`
-          );
+          setError(data.error || 'Failed to add item');
         }
-      });
-      
-      return rows.join('');
-    };
-    
-    // Helper to format primitive values with truncation and highlighting
-    const renderPrimitiveValue = (value) => {
-      // Format and truncate based on type
-      if (typeof value === 'string') {
-        // Truncate long strings
-        const displayValue = value.length > 30 
-          ? `"${value.substring(0, 30)}..."` 
-          : `"${value}"`;
-        return `<span class="json-string">${displayValue}</span>`;
-      } else if (typeof value === 'number') {
-        return `<span class="json-number">${value}</span>`;
-      } else if (typeof value === 'boolean') {
-        return `<span class="json-boolean">${value}</span>`;
-      } else if (value === null) {
-        return `<span class="json-null">null</span>`;
-      } else {
-        return `<span>${String(value)}</span>`;
-      }
-    };
-    
-    // Create the table HTML
-    const tableHtml = `
-      <table class="json-table">
-        <tbody>
-          ${renderJsonAsTable(jsonObj)}
-        </tbody>
-      </table>
-    `;
-    
-    // Return the HTML table with inline styles for containment
-    return (
-      <div 
-        className="content-json-container" 
-        dangerouslySetInnerHTML={{ __html: tableHtml }}
-      />
-    );
+      })
+      .catch(error => {
+        console.error('Error adding catalog item:', error);
+        setError(`Failed to add item: ${error.message}`);
+      })
+      .finally(() => setLoading(false));
   };
 
-  // Panel header with search and controls
-  const renderHeader = () => (
-    <>
-      <div className="panel-header">
-        <h2>Card Catalog</h2>
-        <div className="panel-controls">
-          <button 
-            className="btn-refresh" 
-            onClick={handleRefresh}
-            title="Refresh catalog"
-          >
-            ‚Üª
-          </button>
-          <div className="view-toggles">
-            <button
-              className={`btn-toggle ${viewMode === 'list' ? 'active' : ''}`}
-              onClick={() => setViewMode('list')}
-            >
-              List
-            </button>
-            <button
-              className={`btn-toggle ${viewMode === 'grid' ? 'active' : ''}`}
-              onClick={() => setViewMode('grid')}
-            >
-              Grid
-            </button>
-          </div>
-          {['list', 'grid'].includes(viewMode) && (
-            <button
-              className="btn btn-primary"
-              onClick={() => setViewMode('add')}
-            >
-              Add New Item
-            </button>
-          )}
-        </div>
-      </div>
-      
-      {['list', 'grid'].includes(viewMode) && (
-        <div className="catalog-controls">
-          <form className="search-container" onSubmit={handleSearchSubmit}>
-            <input
-              type="text"
-              className="search-input"
-              placeholder="Search content..."
-              value={searchTerm}
-              onChange={(e) => setSearchTerm(e.target.value)}
-            />
-            <button type="submit" className="btn btn-info search-button">
-              Search
-            </button>
-            {isSearchMode && (
-              <button
-                type="button"
-                className="btn btn-secondary search-button"
-                onClick={handleClearSearch}
-              >
-                Clear
-              </button>
-            )}
-          </form>
-          
-          {!isSearchMode && (
-            <select 
-              className="filter-select"
-              value={filter}
-              onChange={(e) => setFilter(e.target.value)}
-            >
-              {categories.map(category => (
-                <option key={category} value={category}>
-                  {category === 'all' ? 'All Types' : category}
-                </option>
-              ))}
-            </select>
-          )}
-        </div>
-      )}
+  // Render main component
+  return (
+    <div className="catalog-panel" style={{ height: '100%', width: '100%', display: 'flex', flexDirection: 'column' }}>
+      <CatalogHeader 
+        viewMode={viewMode}
+        setViewMode={setViewMode}
+        searchTerm={searchTerm}
+        setSearchTerm={setSearchTerm}
+        isSearchMode={isSearchMode}
+        categories={categories}
+        filter={filter}
+        setFilter={setFilter}
+        handleSearchSubmit={handleSearchSubmit}
+        handleClearSearch={clearSearch}
+        handleRefresh={handleRefresh}
+        searchResults={searchResults}
+      />
       
-      {isSearchMode && searchResults.searchTerm && (
-        <div className="search-status">
-          Showing results for "{searchResults.searchTerm}" ({searchResults.totalItems || 0} items found)
-        </div>
-      )}
-    </>
-  );
-
-  // Render form for adding new content
-  const renderAddForm = () => {
-    return (
-      <form onSubmit={handleAddItem} className="catalog-form">
-        <div className="form-group">
-          <label htmlFor="name">Name</label>
-          <input
-            type="text"
-            id="name"
-            name="name"
-            value={newItem.name}
-            onChange={handleInputChange}
-            placeholder="Item name (optional for text content)"
+      <div className="catalog-content" style={{ flex: 1, overflow: 'auto', position: 'relative' }}>
+        {viewMode === 'grid' && (
+          <GridView 
+            loading={loading || searchLoading}
+            error={error}
+            searchError={searchError}
+            isSearchMode={isSearchMode}
+            searchResults={searchResults}
+            sortedItems={sortedItems}
+            paginationInfo={paginationInfo}
+            onSelectItem={handleSelectItem}
+            onDeleteItem={handleDeleteItem}
+            onPageChange={handlePageChange}
           />
-        </div>
+        )}
         
-        <div 
-          className={`form-group drop-zone ${isDragging ? 'dropping' : ''}`}
-          ref={dropZoneRef}
-          onDragEnter={handleDragEnter}
-          onDragOver={handleDragOver}
-          onDragLeave={handleDragLeave}
-          onDrop={handleDrop}
-        >
-          <label htmlFor="file">
-            {isDragging 
-              ? "Drop file here" 
-              : (newItem.file 
-                ? `Selected: ${newItem.file.name}` 
-                : "Drag & drop a file here, or click to browse")}
-          </label>
-          <input
-            type="file"
-            id="file"
-            onChange={handleFileChange}
-            style={{ opacity: newItem.file ? 0 : 0.01 }}
+        {viewMode === 'detail' && (
+          <DetailView 
+            itemLoading={itemLoading}
+            itemError={itemError}
+            selectedItem={selectedItem}
+            onBack={() => setViewMode('grid')}
+            onDeleteItem={handleDeleteItem}
           />
-          {!newItem.file && <div className="drop-icon">üìÅ</div>}
-          {newItem.file && (
-            <div className="file-info">
-              <span className="file-name">{newItem.file.name}</span>
-              <span className="file-size">({Math.round(newItem.file.size / 1024)} KB)</span>
-              <button 
-                type="button" 
-                className="btn-clear-file"
-                onClick={() => {
-                  setFileInput(null);
-                  setNewItem({...newItem, file: null});
-                }}
-              >
-                ‚úï
-              </button>
-            </div>
-          )}
-        </div>
+        )}
         
-        <div className="form-group">
-          <label htmlFor="description">Text Content (if not uploading a file)</label>
-          <textarea
-            id="description"
-            name="description"
-            value={newItem.description}
-            onChange={handleInputChange}
-            rows="6"
-            placeholder="Enter text content here"
-            disabled={!!newItem.file}
+        {viewMode === 'add' && (
+          <AddItemForm 
+            loading={loading}
+            error={error}
+            onSubmit={handleAddItem}
+            onCancel={() => setViewMode('grid')}
           />
-        </div>
-        
-        <div className="form-actions">
-          <button type="submit" className="btn btn-primary">
-            {newItem.file ? 'Upload File' : 'Add Content'}
-          </button>
-          <button 
-            type="button" 
-            className="btn btn-secondary" 
-            onClick={() => {
-              // Reset form
-              setNewItem({
-                name: '',
-                description: '',
-                contentType: 'text/plain',
-                file: null
-              });
-              setFileInput(null);
-              setViewMode('list');
-            }}
-          >
-            Cancel
-          </button>
-        </div>
-      </form>
-    );
-  };
-
-  return (
-    <div className="catalog-panel" style={{ height: '100%', width: '100%', display: 'flex', flexDirection: 'column' }}>
-      {renderHeader()}
-      
-      <div className="catalog-content" style={{ flex: 1, overflow: 'auto', position: 'relative' }}>
-        {viewMode === 'list' && renderListView()}
-        {viewMode === 'grid' && renderGridView()}
-        {viewMode === 'detail' && renderDetailView()}
-        {viewMode === 'add' && renderAddForm()}
+        )}
       </div>
     </div>
   );
diff --git a/src/components/panels/catalog/views/AddItemForm.jsx b/src/components/panels/catalog/AddItemForm.jsx
similarity index 68%
rename from src/components/panels/catalog/views/AddItemForm.jsx
rename to src/components/panels/catalog/AddItemForm.jsx
index 404f490..4395590 100644
--- a/src/components/panels/catalog/views/AddItemForm.jsx
+++ b/src/components/panels/catalog/AddItemForm.jsx
@@ -1,55 +1,48 @@
 import React, { useRef, useState } from 'react';
-import { DEFAULT_CONTENT_TYPES } from '../utils/contentTypeUtils';
 
 /**
- * AddItemForm component for adding new items to the catalog
+ * Form component for adding new items to the catalog
  */
-const AddItemForm = ({ onSubmit, onCancel, isLoading, error }) => {
-  const [isDragging, setIsDragging] = useState(false);
-  const dropZoneRef = useRef(null);
-
+const AddItemForm = ({ 
+  loading, 
+  error, 
+  onSubmit, 
+  onCancel 
+}) => {
   // Form state
-  const [formData, setFormData] = useState({
+  const [newItem, setNewItem] = useState({
     name: '',
     description: '',
-    contentType: DEFAULT_CONTENT_TYPES.TEXT,
+    contentType: 'text/plain',
     file: null
   });
-
-  // Handle form input changes
-  const handleInputChange = (e) => {
-    const { name, value } = e.target;
-    setFormData({
-      ...formData,
-      [name]: value
-    });
-  };
-
+  
+  // Drag and drop states
+  const [isDragging, setIsDragging] = useState(false);
+  const dropZoneRef = useRef(null);
+  
   // Handle file input change
   const handleFileChange = (e) => {
     const file = e.target.files[0];
     if (file) {
-      setFormData({
-        ...formData,
+      setNewItem({
+        ...newItem,
         name: file.name,
-        contentType: file.type || DEFAULT_CONTENT_TYPES.BINARY,
+        contentType: file.type || 'application/octet-stream',
         file: file
       });
     }
   };
-
-  // Handle form submission
-  const handleSubmit = (e) => {
-    e.preventDefault();
-    
-    if (!formData.name) {
-      alert('Please provide a name for the new item');
-      return;
-    }
-    
-    onSubmit(formData);
+  
+  // Handle form input changes
+  const handleInputChange = (e) => {
+    const { name, value } = e.target;
+    setNewItem({
+      ...newItem,
+      [name]: value
+    });
   };
-
+  
   // Drag and drop handlers
   const handleDragEnter = (e) => {
     e.preventDefault();
@@ -83,34 +76,41 @@ const AddItemForm = ({ onSubmit, onCancel, isLoading, error }) => {
     const files = e.dataTransfer.files;
     if (files && files.length > 0) {
       const file = files[0]; // Take only the first file if multiple are dropped
-      setFormData({
-        ...formData,
+      setNewItem({
+        ...newItem,
         name: file.name,
-        contentType: file.type || DEFAULT_CONTENT_TYPES.BINARY,
+        contentType: file.type || 'application/octet-stream',
         file: file
       });
     }
   };
-
-  // Clear file selection
-  const handleClearFile = () => {
-    setFormData({
-      ...formData,
-      file: null
-    });
+  
+  // Handle form submission
+  const handleSubmit = (e) => {
+    e.preventDefault();
+    
+    if (!newItem.name) {
+      alert('Please provide a name for the new item');
+      return;
+    }
+    
+    if (!newItem.file && !newItem.description) {
+      alert('Please provide content to add');
+      return;
+    }
+    
+    onSubmit(newItem);
   };
-
+  
   return (
     <form onSubmit={handleSubmit} className="catalog-form">
-      {error && <div className="form-error">{error}</div>}
-      
       <div className="form-group">
         <label htmlFor="name">Name</label>
         <input
           type="text"
           id="name"
           name="name"
-          value={formData.name}
+          value={newItem.name}
           onChange={handleInputChange}
           placeholder="Item name (optional for text content)"
         />
@@ -127,25 +127,27 @@ const AddItemForm = ({ onSubmit, onCancel, isLoading, error }) => {
         <label htmlFor="file">
           {isDragging 
             ? "Drop file here" 
-            : (formData.file 
-              ? `Selected: ${formData.file.name}` 
+            : (newItem.file 
+              ? `Selected: ${newItem.file.name}` 
               : "Drag & drop a file here, or click to browse")}
         </label>
         <input
           type="file"
           id="file"
           onChange={handleFileChange}
-          style={{ opacity: formData.file ? 0 : 0.01 }}
+          style={{ opacity: newItem.file ? 0 : 0.01 }}
         />
-        {!formData.file && <div className="drop-icon">üìÅ</div>}
-        {formData.file && (
+        {!newItem.file && <div className="drop-icon">üìÅ</div>}
+        {newItem.file && (
           <div className="file-info">
-            <span className="file-name">{formData.file.name}</span>
-            <span className="file-size">({Math.round(formData.file.size / 1024)} KB)</span>
+            <span className="file-name">{newItem.file.name}</span>
+            <span className="file-size">({Math.round(newItem.file.size / 1024)} KB)</span>
             <button 
               type="button" 
               className="btn-clear-file"
-              onClick={handleClearFile}
+              onClick={() => {
+                setNewItem({...newItem, file: null});
+              }}
             >
               ‚úï
             </button>
@@ -158,27 +160,25 @@ const AddItemForm = ({ onSubmit, onCancel, isLoading, error }) => {
         <textarea
           id="description"
           name="description"
-          value={formData.description}
+          value={newItem.description}
           onChange={handleInputChange}
           rows="6"
           placeholder="Enter text content here"
-          disabled={!!formData.file}
+          disabled={!!newItem.file}
         />
       </div>
       
+      {error && <div className="error-message">{error}</div>}
+      
       <div className="form-actions">
-        <button 
-          type="submit" 
-          className="btn btn-primary"
-          disabled={isLoading}
-        >
-          {isLoading ? 'Uploading...' : (formData.file ? 'Upload File' : 'Add Content')}
+        <button type="submit" className="btn btn-primary" disabled={loading}>
+          {loading ? 'Uploading...' : (newItem.file ? 'Upload File' : 'Add Content')}
         </button>
         <button 
           type="button" 
           className="btn btn-secondary" 
           onClick={onCancel}
-          disabled={isLoading}
+          disabled={loading}
         >
           Cancel
         </button>
diff --git a/src/components/panels/catalog/CardThumbnail.jsx b/src/components/panels/catalog/CardThumbnail.jsx
new file mode 100644
index 0000000..0202fcd
--- /dev/null
+++ b/src/components/panels/catalog/CardThumbnail.jsx
@@ -0,0 +1,40 @@
+import React from 'react';
+import { getSimpleContentType, getContentTypeDisplay } from './utils';
+
+/**
+ * Renders a thumbnail for a card based on its content type
+ */
+const CardThumbnail = ({ item }) => {
+  const contentType = item.contentType?.mimeType || 'unknown';
+  const simpleType = getSimpleContentType(contentType);
+  
+  // Image thumbnails for image types
+  if (contentType.startsWith('image/')) {
+    return (
+      <img 
+        src={`/api/card-collection?action=get&hash=${item.id}`} 
+        alt={item.name} 
+        onError={(e) => {
+          e.target.onerror = null;
+          e.target.src = "https://placehold.co/300x300?text=No+Preview";
+        }}
+      />
+    );
+  }
+  
+  // Icons or placeholders for other content types
+  const contentTypeDisplay = getContentTypeDisplay();
+  
+  // Use the simple type for display if available
+  const displayType = simpleType && contentTypeDisplay[simpleType] 
+    ? contentTypeDisplay[simpleType]
+    : contentType || 'Unknown';
+  
+  return (
+    <div className="image-placeholder">
+      {displayType}
+    </div>
+  );
+};
+
+export default CardThumbnail;
diff --git a/src/components/panels/catalog/CatalogContainer.jsx b/src/components/panels/catalog/CatalogContainer.jsx
new file mode 100644
index 0000000..e0447a5
--- /dev/null
+++ b/src/components/panels/catalog/CatalogContainer.jsx
@@ -0,0 +1,730 @@
+import React, { useState, useEffect } from 'react';
+import { useDispatch } from 'react-redux';
+import { importCardFromDatabase, selectContent } from '../../../features/contentSlice';
+import { selectItem } from '../../../features/selectedItemSlice';
+import CatalogHeader from './CatalogHeader';
+import ListView from './ListView';
+import GridView from './GridView';
+import DetailView from './DetailView';
+import AddItemForm from './AddItemForm';
+import { getSimpleContentType } from './utils';
+
+/**
+ * CatalogContainer handles all the state management and API calls for the catalog panel
+ */
+const CatalogContainer = () => {
+  const dispatch = useDispatch();
+  
+  // Component state
+  const [items, setItems] = useState([]);
+  const [selectedItem, setSelectedItem] = useState(null);
+  const [loading, setLoading] = useState(false);
+  const [itemLoading, setItemLoading] = useState(false);
+  const [searchLoading, setSearchLoading] = useState(false);
+  const [error, setError] = useState(null);
+  const [itemError, setItemError] = useState(null);
+  const [searchError, setSearchError] = useState(null);
+  const [pagination, setPagination] = useState({
+    currentPage: 1,
+    totalPages: 1,
+    totalItems: 0,
+    pageSize: 20
+  });
+  const [searchResults, setSearchResults] = useState({
+    items: [],
+    currentPage: 1,
+    totalPages: 1,
+    totalItems: 0,
+    searchTerm: ''
+  });
+  
+  // Default to grid view as specified in memory
+  const [viewMode, setViewMode] = useState('grid'); 
+  const [searchTerm, setSearchTerm] = useState('');
+  const [isSearchMode, setIsSearchMode] = useState(false);
+  const [filter, setFilter] = useState('all');
+  const [sortBy, setSortBy] = useState('name');
+  
+  // Category list derived from items
+  const [categories, setCategories] = useState(['all']);
+
+  // Determine which items to display based on search mode
+  const displayItems = isSearchMode ? searchResults.items : items;
+  
+  // Pagination info based on mode
+  const paginationInfo = isSearchMode 
+    ? { 
+        currentPage: searchResults.currentPage, 
+        totalPages: searchResults.totalPages, 
+        totalItems: searchResults.totalItems,
+        pageSize: 20
+      } 
+    : pagination;
+
+  // Filter and sort items for the current view
+  const filteredItems = displayItems.filter(item => {
+    // Skip filtering in search mode
+    if (isSearchMode) return true;
+    
+    const matchesFilter = filter === 'all' || item.category === filter;
+    return matchesFilter;
+  });
+
+  // Sort items
+  const sortedItems = [...filteredItems].sort((a, b) => {
+    switch(sortBy) {
+      case 'name':
+        return a.name.localeCompare(b.name);
+      case 'timestamp':
+        return new Date(b.timestamp) - new Date(a.timestamp);
+      default:
+        return 0;
+    }
+  });
+
+  // Update categories whenever items change
+  useEffect(() => {
+    if (items.length > 0) {
+      const catSet = new Set(items.map(item => item.category));
+      const categoryArray = ['all', ...Array.from(catSet)].filter(c => c);
+      setCategories(categoryArray);
+    }
+  }, [items]);
+
+  // Fetch catalog items
+  const fetchCatalogItems = () => {
+    setLoading(true);
+    setError(null);
+    
+    fetch(`/api/card-collection?action=getPage&pageNumber=1&pageSize=${pagination.pageSize}`)
+      .then(response => response.json())
+      .then(data => {
+        if (data.success) {
+          // Check response format and transform accordingly
+          let transformedItems = [];
+          
+          if (data.cards && Array.isArray(data.cards)) {
+            // Format from getPage endpoint
+            transformedItems = data.cards.map(card => ({
+              id: card.hash,
+              name: card.hash.substring(0, 8), // Use first 8 chars of hash as name
+              category: card.contentType?.mimeType || 'Unknown',
+              description: 'Card content hash: ' + card.hash,
+              timestamp: card.timestamp || new Date().toISOString(),
+              hash: card.hash,
+              contentType: card.contentType,
+              metaData: card.metaData || {}
+            }));
+            
+            // After setting initial items, fetch accurate content types
+            fetchAccurateContentTypes(transformedItems);
+          } else if (data.items && Array.isArray(data.items)) {
+            // Alternative format from list endpoint
+            transformedItems = data.items.map(item => ({
+              id: item.id || item.hash,
+              name: item.name || (item.hash ? item.hash.substring(0, 8) : 'Unknown'),
+              category: item.category || item.contentType?.mimeType || 'Unknown',
+              description: item.description || 'No description available',
+              timestamp: item.timestamp || new Date().toISOString(),
+              hash: item.hash || item.id,
+              contentType: item.contentType || { mimeType: 'text/plain' },
+              metaData: item.metaData || {}
+            }));
+            
+            // After setting initial items, fetch accurate content types
+            fetchAccurateContentTypes(transformedItems);
+          } else {
+            console.warn('Unexpected API response format:', data);
+          }
+          
+          setItems(transformedItems);
+          setPagination({
+            currentPage: data.currentPage || 1,
+            totalPages: data.totalPages || Math.ceil((data.totalCards || data.totalItems || transformedItems.length) / pagination.pageSize),
+            totalItems: data.totalCards || data.totalItems || transformedItems.length,
+            pageSize: pagination.pageSize
+          });
+        } else {
+          setError(data.error || 'Failed to fetch items');
+        }
+      })
+      .catch(error => {
+        console.error('Error fetching catalog items:', error);
+        setError('Failed to fetch catalog items. Please try again.');
+      })
+      .finally(() => {
+        setLoading(false);
+      });
+  };
+  
+  // Fetch accurate content types for all items
+  const fetchAccurateContentTypes = (initialItems) => {
+    // Process items in batches to avoid too many simultaneous requests
+    const batchSize = 5;
+    const itemBatches = [];
+    
+    for (let i = 0; i < initialItems.length; i += batchSize) {
+      itemBatches.push(initialItems.slice(i, i + batchSize));
+    }
+    
+    // Process each batch sequentially
+    let currentBatch = 0;
+    
+    const processBatch = () => {
+      if (currentBatch >= itemBatches.length) return;
+      
+      const batch = itemBatches[currentBatch];
+      const batchPromises = batch.map(item => 
+        fetch(`/api/card-collection?action=get&hash=${item.id}`)
+          .then(response => response.json())
+          .then(data => {
+            if (data.success && data.card) {
+              // Update the item with accurate content type
+              setItems(prevItems => 
+                prevItems.map(prevItem => 
+                  prevItem.id === item.id 
+                    ? {
+                        ...prevItem,
+                        contentType: data.card.contentType
+                      }
+                    : prevItem
+                )
+              );
+            }
+            return null;
+          })
+          .catch(error => {
+            console.error(`Error fetching details for item ${item.id}:`, error);
+            return null;
+          })
+      );
+      
+      Promise.all(batchPromises)
+        .then(() => {
+          currentBatch++;
+          processBatch();
+        });
+    };
+    
+    // Start processing batches
+    processBatch();
+  };
+
+  // Handle refresh button click
+  const handleRefresh = () => {
+    // Clear search if in search mode
+    if (isSearchMode) {
+      setIsSearchMode(false);
+      setSearchResults({
+        items: [],
+        currentPage: 1,
+        totalPages: 1,
+        totalItems: 0,
+        searchTerm: ''
+      });
+      setSearchTerm('');
+    }
+    
+    // Fetch items again
+    fetchCatalogItems();
+  };
+
+  // Initial fetch on component mount
+  useEffect(() => {
+    fetchCatalogItems();
+  }, []);
+
+  // Handle pagination change
+  const handlePageChange = (newPage) => {
+    if (isSearchMode) {
+      setSearchLoading(true);
+      setSearchError(null);
+      
+      fetch(`/api/card-collection?action=searchByContent&searchTerm=${encodeURIComponent(searchResults.searchTerm)}&pageNumber=${newPage}&pageSize=${pagination.pageSize}`)
+        .then(response => response.json())
+        .then(data => {
+          if (data.success) {
+            // Transform cards into catalog items
+            let transformedItems = [];
+            
+            if (data.cards && Array.isArray(data.cards)) {
+              transformedItems = data.cards.map(card => ({
+                id: card.hash,
+                name: card.hash.substring(0, 8),
+                category: card.contentType?.mimeType || 'Unknown',
+                description: 'Matching content: ' + (card.matchContext || ''),
+                hash: card.hash,
+                timestamp: card.timestamp || new Date().toISOString(),
+                contentType: card.contentType
+              }));
+            } else if (data.items && Array.isArray(data.items)) {
+              transformedItems = data.items.map(item => ({
+                id: item.id || item.hash,
+                name: item.name || (item.hash ? item.hash.substring(0, 8) : 'Unknown'),
+                category: item.category || item.contentType?.mimeType || 'Unknown',
+                description: item.description || 'No description available',
+                timestamp: item.timestamp || new Date().toISOString(),
+                hash: item.hash || item.id,
+                contentType: item.contentType || { mimeType: 'text/plain' }
+              }));
+            } else {
+              console.warn('Unexpected API search response format:', data);
+            }
+            
+            setSearchResults({
+              items: transformedItems,
+              currentPage: data.currentPage || newPage,
+              totalPages: data.totalPages || Math.ceil((data.totalResults || data.totalItems || transformedItems.length) / pagination.pageSize),
+              totalItems: data.totalResults || data.totalItems || transformedItems.length,
+              searchTerm: searchResults.searchTerm
+            });
+          } else {
+            setSearchError(data.error || 'Search failed');
+          }
+        })
+        .catch(error => {
+          console.error('Error searching catalog items:', error);
+          setSearchError('Search failed. Please try again.');
+        })
+        .finally(() => {
+          setSearchLoading(false);
+        });
+    } else {
+      setLoading(true);
+      setError(null);
+      
+      fetch(`/api/card-collection?action=getPage&pageNumber=${newPage}&pageSize=${pagination.pageSize}`)
+        .then(response => response.json())
+        .then(data => {
+          if (data.success) {
+            // Transform cards into catalog items
+            let transformedItems = [];
+            
+            if (data.cards && Array.isArray(data.cards)) {
+              transformedItems = data.cards.map(card => ({
+                id: card.hash,
+                name: card.hash.substring(0, 8),
+                category: card.contentType?.mimeType || 'Unknown',
+                description: 'Card content hash: ' + card.hash,
+                timestamp: card.timestamp || new Date().toISOString(),
+                hash: card.hash,
+                contentType: card.contentType,
+                metaData: card.metaData || {}
+              }));
+            } else if (data.items && Array.isArray(data.items)) {
+              transformedItems = data.items.map(item => ({
+                id: item.id || item.hash,
+                name: item.name || (item.hash ? item.hash.substring(0, 8) : 'Unknown'),
+                category: item.category || item.contentType?.mimeType || 'Unknown',
+                description: item.description || 'No description available',
+                timestamp: item.timestamp || new Date().toISOString(),
+                hash: item.hash || item.id,
+                contentType: item.contentType || { mimeType: 'text/plain' },
+                metaData: item.metaData || {}
+              }));
+            } else {
+              console.warn('Unexpected API response format:', data);
+            }
+            
+            setItems(transformedItems);
+            setPagination({
+              currentPage: data.currentPage || newPage,
+              totalPages: data.totalPages || Math.ceil((data.totalCards || data.totalItems || transformedItems.length) / pagination.pageSize),
+              totalItems: data.totalCards || data.totalItems || transformedItems.length,
+              pageSize: pagination.pageSize
+            });
+          } else {
+            setError(data.error || 'Failed to fetch items');
+          }
+        })
+        .catch(error => {
+          console.error('Error fetching catalog items:', error);
+          setError('Failed to fetch catalog items. Please try again.');
+        })
+        .finally(() => {
+          setLoading(false);
+        });
+    }
+  };
+
+  // Handle item selection
+  const handleSelectItem = (item) => {
+    setItemLoading(true);
+    setItemError(null);
+    setViewMode('detail');
+    
+    fetch(`/api/card-collection?action=get&hash=${item.id}`)
+      .then(response => response.json())
+      .then(data => {
+        if (data.success) {
+          const cardData = data.card;
+          
+          // Get content type from server response
+          const serverContentType = cardData.contentType;
+          
+          // Extract a simple content type string for the UI
+          const simpleType = serverContentType?.extension || 
+                         (serverContentType?.mimeType ? getSimpleContentType(serverContentType.mimeType) : null) || 
+                         "txt";
+          
+          // Process the content based on its type
+          let description = 'Binary content';
+          const content = cardData.content;
+          
+          if (typeof content === 'string') {
+            description = content.substring(0, 200) + (content.length > 200 ? '...' : '');
+          } else if (content && typeof content === 'object') {
+            if (content.type === 'string') {
+              description = content.data.substring(0, 200) + (content.data.length > 200 ? '...' : '');
+            } else if (content.type === 'base64') {
+              description = `Binary content (${content.originalType || 'unknown type'})`;
+            }
+          }
+          
+          // Set the selected item with all details
+          setSelectedItem({
+            id: cardData.hash,
+            name: cardData.hash.substring(0, 8),
+            category: cardData.contentType?.mimeType || 'Unknown',
+            description: description,
+            hash: cardData.hash,
+            content: cardData.content,
+            timestamp: cardData.timestamp || new Date().toISOString(),
+            contentType: cardData.contentType
+          });
+          
+          // Import the card to contentSlice Redux store for cross-panel integration
+          dispatch(importCardFromDatabase({ 
+            hash: cardData.hash,
+            content: cardData.content,
+            metadata: {
+              contentType: serverContentType
+            },
+            relationships: {
+              parentHash: null,
+              childHashes: [],
+              relatedHashes: []
+            }
+          }));
+          
+          // Select the card in Redux
+          dispatch(selectContent(cardData.hash));
+          
+          // Update the selectedItem state with card details for selected item slice
+          dispatch(selectItem({
+            item: cardData.content,
+            hash: cardData.hash,
+            contentType: simpleType,
+            gtime: cardData.timestamp
+          }));
+        } else {
+          setItemError(data.error || 'Failed to fetch card');
+        }
+      })
+      .catch(error => {
+        console.error('Error fetching card by ID:', error);
+        setItemError('Failed to fetch card. Please try again.');
+      })
+      .finally(() => {
+        setItemLoading(false);
+      });
+  };
+
+  // Handle item deletion
+  const handleDeleteItem = (id) => {
+    if (window.confirm('Are you sure you want to delete this item?')) {
+      fetch(`/api/card-collection?action=delete&hash=${id}`, { 
+        method: 'DELETE' 
+      })
+        .then(response => response.json())
+        .then(data => {
+          if (data.success) {
+            // Remove item from state
+            setItems(prevItems => prevItems.filter(item => item.id !== id));
+            // If we're viewing the item that was deleted, go back to list view
+            if (selectedItem && selectedItem.id === id) {
+              setSelectedItem(null);
+              setViewMode('grid'); // Return to grid view after deletion
+            }
+          } else {
+            setError(data.error || 'Failed to delete item');
+          }
+        })
+        .catch(error => {
+          console.error('Error deleting catalog item:', error);
+          setError('Failed to delete item. Please try again.');
+        });
+    }
+  };
+
+  // Handle search submission
+  const handleSearchSubmit = (e) => {
+    e.preventDefault();
+    
+    if (!searchTerm.trim()) {
+      // Clear search if empty
+      setIsSearchMode(false);
+      setSearchResults({
+        items: [],
+        currentPage: 1,
+        totalPages: 1,
+        totalItems: 0,
+        searchTerm: ''
+      });
+      return;
+    }
+    
+    setIsSearchMode(true);
+    setSearchLoading(true);
+    setSearchError(null);
+    
+    fetch(`/api/card-collection?action=searchByContent&searchTerm=${encodeURIComponent(searchTerm)}&pageNumber=1&pageSize=${pagination.pageSize}`)
+      .then(response => response.json())
+      .then(data => {
+        if (data.success) {
+          // Transform cards into catalog items
+          let transformedItems = [];
+          
+          if (data.cards && Array.isArray(data.cards)) {
+            transformedItems = data.cards.map(card => ({
+              id: card.hash,
+              name: card.hash.substring(0, 8),
+              category: card.contentType?.mimeType || 'Unknown',
+              description: 'Matching content: ' + (card.matchContext || ''),
+              hash: card.hash,
+              timestamp: card.timestamp || new Date().toISOString(),
+              contentType: card.contentType
+            }));
+          } else if (data.items && Array.isArray(data.items)) {
+            transformedItems = data.items.map(item => ({
+              id: item.id || item.hash,
+              name: item.name || (item.hash ? item.hash.substring(0, 8) : 'Unknown'),
+              category: item.category || item.contentType?.mimeType || 'Unknown',
+              description: item.description || 'No description available',
+              timestamp: item.timestamp || new Date().toISOString(),
+              hash: item.hash || item.id,
+              contentType: item.contentType || { mimeType: 'text/plain' }
+            }));
+          } else {
+            console.warn('Unexpected API search response format:', data);
+          }
+          
+          setSearchResults({
+            items: transformedItems,
+            currentPage: data.currentPage || 1,
+            totalPages: data.totalPages || Math.ceil((data.totalResults || data.totalItems || transformedItems.length) / pagination.pageSize),
+            totalItems: data.totalResults || data.totalItems || transformedItems.length,
+            searchTerm: searchTerm
+          });
+        } else {
+          setSearchError(data.error || 'Search failed');
+        }
+      })
+      .catch(error => {
+        console.error('Error searching catalog items:', error);
+        setSearchError('Search failed. Please try again.');
+      })
+      .finally(() => {
+        setSearchLoading(false);
+      });
+  };
+
+  // Handle adding a new item
+  const handleAddItem = (newItemData) => {
+    if (newItemData.file) {
+      // File upload
+      const formData = new FormData();
+      formData.append('file', newItemData.file);
+      
+      // Create the metadata object as required by the API
+      const metadata = {
+        fileName: newItemData.name,
+        mimeType: newItemData.contentType || 'application/octet-stream',
+        size: newItemData.file.size,
+        description: newItemData.description || ''
+      };
+      
+      // Append metadata as a JSON string
+      formData.append('metadata', JSON.stringify(metadata));
+      // Append action to formData (since it's multipart form)
+      formData.append('action', 'add');
+      
+      setLoading(true);
+      setError(null);
+      
+      fetch('/api/card-collection?action=add', {
+        method: 'POST',
+        body: formData
+      })
+        .then(response => {
+          if (!response.ok) {
+            return response.json().then(data => {
+              throw new Error(data.error || `Server responded with ${response.status}`);
+            });
+          }
+          return response.json();
+        })
+        .then(data => {
+          if (data.success) {
+            // Add new item to the state
+            const newCardItem = {
+              id: data.hash,
+              name: newItemData.name,
+              description: newItemData.description || 'Added file',
+              category: newItemData.contentType || 'application/octet-stream',
+              hash: data.hash,
+              timestamp: new Date().toISOString(),
+              contentType: { mimeType: newItemData.contentType || 'application/octet-stream' }
+            };
+            
+            setItems(prevItems => [...prevItems, newCardItem]);
+            setViewMode('grid'); // Go back to grid view
+          } else {
+            setError(data.error || 'Failed to add item');
+          }
+        })
+        .catch(error => {
+          console.error('Error adding catalog item:', error);
+          setError(`Failed to add item: ${error.message}`);
+        })
+        .finally(() => {
+          setLoading(false);
+        });
+    } else if (newItemData.description) {
+      // Text content
+      setLoading(true);
+      setError(null);
+      
+      fetch('/api/card-collection?action=add', {
+        method: 'POST',
+        headers: { 'Content-Type': 'application/json' },
+        body: JSON.stringify({
+          action: 'add',
+          card: {
+            content: newItemData.description,
+            hash_algorithm: 'sha256'
+          }
+        })
+      })
+        .then(response => {
+          if (!response.ok) {
+            return response.json().then(data => {
+              throw new Error(data.error || `Server responded with ${response.status}`);
+            });
+          }
+          return response.json();
+        })
+        .then(data => {
+          if (data.success) {
+            // Add new item to state
+            const newCardItem = {
+              id: data.hash,
+              name: newItemData.name,
+              description: newItemData.description.substring(0, 100) + (newItemData.description.length > 100 ? '...' : ''),
+              category: newItemData.contentType || 'text/plain',
+              hash: data.hash,
+              timestamp: new Date().toISOString(),
+              contentType: { mimeType: newItemData.contentType || 'text/plain' }
+            };
+            
+            setItems(prevItems => [...prevItems, newCardItem]);
+            setViewMode('grid'); // Go back to grid view
+          } else {
+            setError(data.error || 'Failed to add item');
+          }
+        })
+        .catch(error => {
+          console.error('Error adding catalog item:', error);
+          setError(`Failed to add item: ${error.message}`);
+        })
+        .finally(() => {
+          setLoading(false);
+        });
+    }
+  };
+
+  // Clear search and return to normal view
+  const handleClearSearch = () => {
+    setSearchTerm('');
+    setIsSearchMode(false);
+    setSearchResults({
+      items: [],
+      currentPage: 1,
+      totalPages: 1,
+      totalItems: 0,
+      searchTerm: ''
+    });
+  };
+
+  return (
+    <div className="catalog-panel" style={{ height: '100%', width: '100%', display: 'flex', flexDirection: 'column' }}>
+      <CatalogHeader 
+        viewMode={viewMode}
+        setViewMode={setViewMode}
+        searchTerm={searchTerm}
+        setSearchTerm={setSearchTerm}
+        isSearchMode={isSearchMode}
+        categories={categories}
+        filter={filter}
+        setFilter={setFilter}
+        handleSearchSubmit={handleSearchSubmit}
+        handleClearSearch={handleClearSearch}
+        handleRefresh={handleRefresh}
+        searchResults={searchResults}
+      />
+      
+      <div className="catalog-content" style={{ flex: 1, overflow: 'auto', position: 'relative' }}>
+        {viewMode === 'list' && (
+          <ListView 
+            loading={loading || searchLoading}
+            error={error}
+            searchError={searchError}
+            isSearchMode={isSearchMode}
+            searchResults={searchResults}
+            sortedItems={sortedItems}
+            paginationInfo={paginationInfo}
+            onSelectItem={handleSelectItem}
+            onDeleteItem={handleDeleteItem}
+            onPageChange={handlePageChange}
+          />
+        )}
+        
+        {viewMode === 'grid' && (
+          <GridView 
+            loading={loading || searchLoading}
+            error={error}
+            searchError={searchError}
+            isSearchMode={isSearchMode}
+            searchResults={searchResults}
+            sortedItems={sortedItems}
+            paginationInfo={paginationInfo}
+            onSelectItem={handleSelectItem}
+            onDeleteItem={handleDeleteItem}
+            onPageChange={handlePageChange}
+          />
+        )}
+        
+        {viewMode === 'detail' && (
+          <DetailView 
+            itemLoading={itemLoading}
+            itemError={itemError}
+            selectedItem={selectedItem}
+            onBack={() => setViewMode('grid')}
+            onDeleteItem={handleDeleteItem}
+          />
+        )}
+        
+        {viewMode === 'add' && (
+          <AddItemForm 
+            loading={loading}
+            error={error}
+            onSubmit={handleAddItem}
+            onCancel={() => setViewMode('grid')}
+          />
+        )}
+      </div>
+    </div>
+  );
+};
+
+export default CatalogContainer;
diff --git a/src/components/panels/catalog/components/PanelHeader.jsx b/src/components/panels/catalog/CatalogHeader.jsx
similarity index 68%
rename from src/components/panels/catalog/components/PanelHeader.jsx
rename to src/components/panels/catalog/CatalogHeader.jsx
index 072d943..9aed86d 100644
--- a/src/components/panels/catalog/components/PanelHeader.jsx
+++ b/src/components/panels/catalog/CatalogHeader.jsx
@@ -1,34 +1,22 @@
-import React, { useState } from 'react';
+import React from 'react';
 
 /**
- * PanelHeader component for the CatalogPanel
- * Provides search, view mode toggles, and refresh functionality
+ * Header component for the catalog panel
  */
-const PanelHeader = ({ 
+const CatalogHeader = ({ 
   viewMode, 
-  onViewModeChange, 
-  onRefresh,
-  onSearch,
-  onClearSearch,
-  isSearchMode,
+  setViewMode, 
+  searchTerm, 
+  setSearchTerm, 
+  isSearchMode, 
   categories,
   filter,
-  onFilterChange
+  setFilter,
+  handleSearchSubmit,
+  handleClearSearch,
+  handleRefresh,
+  searchResults
 }) => {
-  const [searchTerm, setSearchTerm] = useState('');
-
-  const handleSearchSubmit = (e) => {
-    e.preventDefault();
-    
-    if (!searchTerm.trim()) {
-      // Clear search if empty
-      onClearSearch();
-      return;
-    }
-    
-    onSearch(searchTerm);
-  };
-
   return (
     <>
       <div className="panel-header">
@@ -36,7 +24,7 @@ const PanelHeader = ({
         <div className="panel-controls">
           <button 
             className="btn-refresh" 
-            onClick={onRefresh}
+            onClick={handleRefresh}
             title="Refresh catalog"
           >
             ‚Üª
@@ -44,13 +32,13 @@ const PanelHeader = ({
           <div className="view-toggles">
             <button
               className={`btn-toggle ${viewMode === 'list' ? 'active' : ''}`}
-              onClick={() => onViewModeChange('list')}
+              onClick={() => setViewMode('list')}
             >
               List
             </button>
             <button
               className={`btn-toggle ${viewMode === 'grid' ? 'active' : ''}`}
-              onClick={() => onViewModeChange('grid')}
+              onClick={() => setViewMode('grid')}
             >
               Grid
             </button>
@@ -58,7 +46,7 @@ const PanelHeader = ({
           {['list', 'grid'].includes(viewMode) && (
             <button
               className="btn btn-primary"
-              onClick={() => onViewModeChange('add')}
+              onClick={() => setViewMode('add')}
             >
               Add New Item
             </button>
@@ -83,10 +71,7 @@ const PanelHeader = ({
               <button
                 type="button"
                 className="btn btn-secondary search-button"
-                onClick={() => {
-                  setSearchTerm('');
-                  onClearSearch();
-                }}
+                onClick={handleClearSearch}
               >
                 Clear
               </button>
@@ -97,7 +82,7 @@ const PanelHeader = ({
             <select 
               className="filter-select"
               value={filter}
-              onChange={(e) => onFilterChange(e.target.value)}
+              onChange={(e) => setFilter(e.target.value)}
             >
               {categories.map(category => (
                 <option key={category} value={category}>
@@ -108,8 +93,14 @@ const PanelHeader = ({
           )}
         </div>
       )}
+      
+      {isSearchMode && searchResults.searchTerm && (
+        <div className="search-status">
+          Showing results for "{searchResults.searchTerm}" ({searchResults.totalItems || 0} items found)
+        </div>
+      )}
     </>
   );
 };
 
-export default PanelHeader;
+export default CatalogHeader;
diff --git a/src/components/panels/catalog/CatalogPanel.jsx b/src/components/panels/catalog/CatalogPanel.jsx
deleted file mode 100644
index e97cbd7..0000000
--- a/src/components/panels/catalog/CatalogPanel.jsx
+++ /dev/null
@@ -1,436 +0,0 @@
-import React, { useState, useEffect } from 'react';
-import { useDispatch } from 'react-redux';
-import { importCardFromDatabase, selectContent } from '../../../features/contentSlice';
-import { selectItem } from '../../../features/selectedItemSlice';
-
-// Import API services
-import { 
-  fetchCatalogItems, 
-  searchCatalogItems, 
-  fetchItemById,
-  deleteItem,
-  addFileItem,
-  addTextContent 
-} from './api/catalogService';
-
-// Import components
-import PanelHeader from './components/PanelHeader';
-import ListView from './views/ListView';
-import GridView from './views/GridView';
-import DetailView from './views/DetailView';
-import AddItemForm from './views/AddItemForm';
-
-// Import utilities
-import { DEFAULT_CONTENT_TYPES, getSimpleContentType } from './utils/contentTypeUtils';
-
-// Import styles
-import '../../../styles/CatalogPanel.css';
-
-/**
- * CatalogPanel - A component for displaying and managing catalog items
- * 
- * Features:
- * - List view with search/filter capabilities
- * - Grid view with thumbnail support
- * - Item categorization
- * - Add/edit/remove operations
- * - Detail view for individual items
- * - Integration with card-collection API
- */
-const CatalogPanel = () => {
-  const dispatch = useDispatch();
-  
-  // Component state
-  const [items, setItems] = useState([]);
-  const [selectedItem, setSelectedItem] = useState(null);
-  const [loading, setLoading] = useState(false);
-  const [itemLoading, setItemLoading] = useState(false);
-  const [searchLoading, setSearchLoading] = useState(false);
-  const [error, setError] = useState(null);
-  const [itemError, setItemError] = useState(null);
-  const [searchError, setSearchError] = useState(null);
-  const [pagination, setPagination] = useState({
-    currentPage: 1,
-    totalPages: 1,
-    totalItems: 0,
-    pageSize: 20
-  });
-  const [searchResults, setSearchResults] = useState({
-    items: [],
-    currentPage: 1,
-    totalPages: 1,
-    totalItems: 0,
-    searchTerm: ''
-  });
-  
-  const [viewMode, setViewMode] = useState('list'); // 'list', 'grid', 'detail', 'add'
-  const [isSearchMode, setIsSearchMode] = useState(false);
-  const [filter, setFilter] = useState('all');
-  const [sortBy, setSortBy] = useState('name');
-  const [addItemError, setAddItemError] = useState(null);
-  const [addItemLoading, setAddItemLoading] = useState(false);
-  
-  // Category list derived from items
-  const [categories, setCategories] = useState(['all']);
-
-  // Determine which items to display based on search mode
-  const displayItems = isSearchMode ? searchResults.items : items;
-  
-  // Pagination info based on mode
-  const paginationInfo = isSearchMode 
-    ? { 
-        currentPage: searchResults.currentPage, 
-        totalPages: searchResults.totalPages, 
-        totalItems: searchResults.totalItems,
-        pageSize: 20
-      } 
-    : pagination;
-
-  // Filter and sort items for the current view
-  const filteredItems = displayItems.filter(item => {
-    // Skip filtering in search mode
-    if (isSearchMode) return true;
-    
-    const matchesFilter = filter === 'all' || item.category === filter;
-    return matchesFilter;
-  });
-
-  // Sort items
-  const sortedItems = [...filteredItems].sort((a, b) => {
-    switch(sortBy) {
-      case 'name':
-        return a.name.localeCompare(b.name);
-      case 'timestamp':
-        return new Date(b.timestamp) - new Date(a.timestamp);
-      default:
-        return 0;
-    }
-  });
-
-  // Update categories whenever items change
-  useEffect(() => {
-    if (items.length > 0) {
-      const catSet = new Set(items.map(item => item.category));
-      const categoryArray = ['all', ...Array.from(catSet)].filter(c => c);
-      setCategories(categoryArray);
-    }
-  }, [items]);
-
-  // Fetch catalog items
-  const loadCatalogItems = async () => {
-    setLoading(true);
-    setError(null);
-    
-    const result = await fetchCatalogItems(pagination.currentPage, pagination.pageSize);
-    
-    if (result.success) {
-      setItems(result.items);
-      setPagination(result.pagination);
-    } else {
-      setError(result.error);
-    }
-    
-    setLoading(false);
-  };
-
-  // Initial fetch on component mount
-  useEffect(() => {
-    loadCatalogItems();
-  }, []);
-
-  // Handle refresh button click
-  const handleRefresh = () => {
-    // Clear search if in search mode
-    if (isSearchMode) {
-      setIsSearchMode(false);
-      setSearchResults({
-        items: [],
-        currentPage: 1,
-        totalPages: 1,
-        totalItems: 0,
-        searchTerm: ''
-      });
-    }
-    
-    // Fetch items again
-    loadCatalogItems();
-  };
-
-  // Handle pagination change
-  const handlePageChange = async (newPage) => {
-    if (isSearchMode) {
-      setSearchLoading(true);
-      setSearchError(null);
-      
-      const result = await searchCatalogItems(
-        searchResults.searchTerm, 
-        newPage, 
-        pagination.pageSize
-      );
-      
-      if (result.success) {
-        setSearchResults({
-          items: result.items,
-          currentPage: result.pagination.currentPage,
-          totalPages: result.pagination.totalPages,
-          totalItems: result.pagination.totalItems,
-          searchTerm: searchResults.searchTerm
-        });
-      } else {
-        setSearchError(result.error);
-      }
-      
-      setSearchLoading(false);
-    } else {
-      setLoading(true);
-      setError(null);
-      
-      const result = await fetchCatalogItems(newPage, pagination.pageSize);
-      
-      if (result.success) {
-        setItems(result.items);
-        setPagination(result.pagination);
-      } else {
-        setError(result.error);
-      }
-      
-      setLoading(false);
-    }
-  };
-
-  // Handle item selection
-  const handleSelectItem = async (item) => {
-    setItemLoading(true);
-    setItemError(null);
-    setViewMode('detail');
-    
-    const result = await fetchItemById(item.id);
-    
-    if (result.success) {
-      setSelectedItem(result.item);
-      
-      // Get content type from server response
-      const serverContentType = result.item.contentType;
-      
-      // Extract a simple content type string for the UI
-      const simpleType = serverContentType?.extension || 
-                     (serverContentType?.mimeType ? getSimpleContentType(serverContentType.mimeType) : null) || 
-                     "txt";
-      
-      // Import the card to contentSlice Redux store for cross-panel integration
-      dispatch(importCardFromDatabase({ 
-        hash: result.item.hash,
-        content: result.item.content,
-        metadata: {
-          contentType: serverContentType
-        },
-        relationships: {
-          parentHash: null,
-          childHashes: [],
-          relatedHashes: []
-        }
-      }));
-      
-      // Select the card in Redux
-      dispatch(selectContent(result.item.hash));
-      
-      // Update the selectedItem state with card details for selected item slice
-      dispatch(selectItem({
-        item: result.item.content,
-        hash: result.item.hash,
-        contentType: simpleType,
-        gtime: result.item.timestamp
-      }));
-    } else {
-      setItemError(result.error);
-    }
-    
-    setItemLoading(false);
-  };
-
-  // Handle item deletion
-  const handleDeleteItem = async (id) => {
-    if (window.confirm('Are you sure you want to delete this item?')) {
-      const result = await deleteItem(id);
-      
-      if (result.success) {
-        // Remove item from state
-        setItems(prevItems => prevItems.filter(item => item.id !== id));
-        // If we're viewing the item that was deleted, go back to list view
-        if (selectedItem && selectedItem.id === id) {
-          setSelectedItem(null);
-          setViewMode('list');
-        }
-      } else {
-        setError(result.error);
-      }
-    }
-  };
-
-  // Handle search submission
-  const handleSearch = async (searchTerm) => {
-    if (!searchTerm.trim()) {
-      // Clear search if empty
-      handleClearSearch();
-      return;
-    }
-    
-    setIsSearchMode(true);
-    setSearchLoading(true);
-    setSearchError(null);
-    
-    const result = await searchCatalogItems(searchTerm, 1, pagination.pageSize);
-    
-    if (result.success) {
-      setSearchResults({
-        items: result.items,
-        currentPage: result.pagination.currentPage,
-        totalPages: result.pagination.totalPages,
-        totalItems: result.pagination.totalItems,
-        searchTerm: searchTerm
-      });
-    } else {
-      setSearchError(result.error);
-    }
-    
-    setSearchLoading(false);
-  };
-
-  // Clear search and return to normal view
-  const handleClearSearch = () => {
-    setIsSearchMode(false);
-    setSearchResults({
-      items: [],
-      currentPage: 1,
-      totalPages: 1,
-      totalItems: 0,
-      searchTerm: ''
-    });
-  };
-
-  // Handle new item submission from the AddItemForm
-  const handleAddItem = async (formData) => {
-    setAddItemLoading(true);
-    setAddItemError(null);
-    
-    let result;
-    
-    if (formData.file) {
-      // File upload
-      const metadata = {
-        fileName: formData.name,
-        mimeType: formData.contentType || DEFAULT_CONTENT_TYPES.BINARY,
-        size: formData.file.size,
-        description: formData.description || ''
-      };
-      
-      result = await addFileItem(formData.file, metadata);
-    } else if (formData.description) {
-      // Text content
-      result = await addTextContent({
-        text: formData.description,
-        name: formData.name,
-        contentType: formData.contentType || DEFAULT_CONTENT_TYPES.TEXT
-      });
-    } else {
-      setAddItemError('Please provide content to add');
-      setAddItemLoading(false);
-      return;
-    }
-    
-    if (result.success) {
-      // Successfully added, refresh the catalog and reset the form
-      loadCatalogItems();
-      setViewMode('list');
-    } else {
-      setAddItemError(result.error);
-    }
-    
-    setAddItemLoading(false);
-  };
-
-  // Handle filter change
-  const handleFilterChange = (newFilter) => {
-    setFilter(newFilter);
-  };
-
-  // Handle view mode change
-  const handleViewModeChange = (newMode) => {
-    setViewMode(newMode);
-  };
-
-  return (
-    <div className="catalog-panel" style={{ height: '100%', width: '100%', display: 'flex', flexDirection: 'column' }}>
-      <PanelHeader 
-        viewMode={viewMode}
-        onViewModeChange={handleViewModeChange}
-        onRefresh={handleRefresh}
-        onSearch={handleSearch}
-        onClearSearch={handleClearSearch}
-        isSearchMode={isSearchMode}
-        categories={categories}
-        filter={filter}
-        onFilterChange={handleFilterChange}
-      />
-      
-      {isSearchMode && searchResults.searchTerm && (
-        <div className="search-status">
-          Showing results for "{searchResults.searchTerm}" ({searchResults.totalItems || 0} items found)
-        </div>
-      )}
-      
-      <div className="catalog-content" style={{ flex: 1, overflow: 'auto', position: 'relative' }}>
-        {viewMode === 'list' && (
-          <ListView 
-            items={sortedItems}
-            isLoading={loading || searchLoading}
-            error={error}
-            pagination={paginationInfo}
-            onSelectItem={handleSelectItem}
-            onDeleteItem={handleDeleteItem}
-            onPageChange={handlePageChange}
-            isSearchMode={isSearchMode}
-            searchTerm={searchResults.searchTerm}
-            searchError={searchError}
-          />
-        )}
-        
-        {viewMode === 'grid' && (
-          <GridView 
-            items={sortedItems}
-            isLoading={loading || searchLoading}
-            error={error}
-            pagination={paginationInfo}
-            onSelectItem={handleSelectItem}
-            onDeleteItem={handleDeleteItem}
-            onPageChange={handlePageChange}
-            isSearchMode={isSearchMode}
-            searchTerm={searchResults.searchTerm}
-            searchError={searchError}
-          />
-        )}
-        
-        {viewMode === 'detail' && (
-          <DetailView 
-            item={selectedItem}
-            isLoading={itemLoading}
-            error={itemError}
-            onBack={() => setViewMode('list')}
-            onDelete={handleDeleteItem}
-          />
-        )}
-        
-        {viewMode === 'add' && (
-          <AddItemForm 
-            onSubmit={handleAddItem}
-            onCancel={() => setViewMode('list')}
-            isLoading={addItemLoading}
-            error={addItemError}
-          />
-        )}
-      </div>
-    </div>
-  );
-};
-
-export default CatalogPanel;
diff --git a/src/components/panels/catalog/views/DetailView.jsx b/src/components/panels/catalog/DetailView.jsx
similarity index 77%
rename from src/components/panels/catalog/views/DetailView.jsx
rename to src/components/panels/catalog/DetailView.jsx
index 3cf12cc..d5b9519 100644
--- a/src/components/panels/catalog/views/DetailView.jsx
+++ b/src/components/panels/catalog/DetailView.jsx
@@ -1,27 +1,40 @@
 import React, { useState } from 'react';
-import { getSimpleContentType } from '../utils/contentTypeUtils';
+import { getSimpleContentType, getContentTypeDisplay } from './utils';
 
 /**
- * DetailView component for displaying detailed information about a catalog item
+ * Detail view component for a catalog item
  */
 const DetailView = ({ 
-  item, 
-  isLoading, 
-  error, 
+  itemLoading, 
+  itemError, 
+  selectedItem, 
   onBack, 
-  onDelete 
+  onDeleteItem 
 }) => {
-  const [wordWrap, setWordWrap] = useState(true);
+  const [wordWrap, setWordWrap] = useState(false);
+  
+  // Get content type display mapping
+  const contentTypeMap = getContentTypeDisplay();
 
-  if (isLoading) {
+  // Helper function to get proper content type display
+  const getFormattedContentType = (mimeType) => {
+    if (!mimeType) return 'Unknown';
+    
+    const simpleType = getSimpleContentType(mimeType);
+    if (!simpleType) return mimeType;
+    
+    return contentTypeMap[simpleType] || simpleType.toUpperCase();
+  };
+  
+  if (itemLoading) {
     return <div className="loading-indicator">Loading item details...</div>;
   }
 
-  if (error) {
-    return <div className="error-message">Error: {error}</div>;
+  if (itemError) {
+    return <div className="error-message">Error: {itemError}</div>;
   }
 
-  if (!item) {
+  if (!selectedItem) {
     return <div className="error-message">Item not found</div>;
   }
   
@@ -32,26 +45,119 @@ const DetailView = ({
     </div>
   );
   
+  // Helper function to render JSON with syntax highlighting and guaranteed wrapping
+  const renderJsonWithHighlighting = (jsonObj) => {
+    // Convert JSON to a vertical display format that won't overflow
+    const renderJsonAsTable = (obj, depth = 0) => {
+      // For primitive values, just return them formatted
+      if (typeof obj !== 'object' || obj === null) {
+        return renderPrimitiveValue(obj);
+      }
+      
+      // Recursive table builder
+      const rows = [];
+      
+      // Handle arrays or objects
+      const isArray = Array.isArray(obj);
+      
+      // For each key/index in the object/array
+      Object.entries(obj).forEach(([key, value], index) => {
+        // Create indentation based on depth
+        const indent = '  '.repeat(depth);
+        const displayKey = isArray ? `[${key}]` : key;
+        
+        // If value is an object, recurse, otherwise format the primitive
+        if (typeof value === 'object' && value !== null) {
+          // For objects/arrays, create a row with the key and a placeholder
+          rows.push(
+            `<tr>
+              <td class="json-key-cell">${indent}${displayKey}:</td>
+              <td class="json-value-cell">${isArray ? '[]' : '{'}...</td>
+            </tr>`
+          );
+          
+          // Add the nested object as indented rows
+          rows.push(renderJsonAsTable(value, depth + 1));
+          
+          // Close the object
+          rows.push(
+            `<tr>
+              <td class="json-key-cell">${indent}</td>
+              <td class="json-value-cell">${isArray ? ']' : '}'}</td>
+            </tr>`
+          );
+        } else {
+          // For primitive values, just add a row with the key and value
+          rows.push(
+            `<tr>
+              <td class="json-key-cell">${indent}${displayKey}:</td>
+              <td class="json-value-cell">${renderPrimitiveValue(value)}</td>
+            </tr>`
+          );
+        }
+      });
+      
+      return rows.join('');
+    };
+    
+    // Helper to format primitive values with truncation and highlighting
+    const renderPrimitiveValue = (value) => {
+      // Format and truncate based on type
+      if (typeof value === 'string') {
+        // Truncate long strings
+        const displayValue = value.length > 30 
+          ? `"${value.substring(0, 30)}..."` 
+          : `"${value}"`;
+        return `<span class="json-string">${displayValue}</span>`;
+      } else if (typeof value === 'number') {
+        return `<span class="json-number">${value}</span>`;
+      } else if (typeof value === 'boolean') {
+        return `<span class="json-boolean">${value}</span>`;
+      } else if (value === null) {
+        return `<span class="json-null">null</span>`;
+      } else {
+        return `<span>${String(value)}</span>`;
+      }
+    };
+    
+    // Create the table HTML
+    const tableHtml = `
+      <table class="json-table">
+        <tbody>
+          ${renderJsonAsTable(jsonObj)}
+        </tbody>
+      </table>
+    `;
+    
+    // Return the HTML table with inline styles for containment
+    return (
+      <div 
+        className="content-json-container" 
+        dangerouslySetInnerHTML={{ __html: tableHtml }}
+      />
+    );
+  };
+  
   // Process and display content based on type
   const renderContent = () => {
-    if (!item?.content) {
+    if (!selectedItem?.content) {
       return <div className="empty-content">No content available</div>;
     }
     
-    const contentType = item.contentType || { mimeType: 'text/plain' };
+    const contentType = selectedItem.contentType || { mimeType: 'text/plain' };
     
     // Handle different content types
     if (contentType.mimeType?.startsWith('image/')) {
       return (
         <ContentWrapper className="image-wrapper">
-          <img src={`data:${contentType.mimeType};base64,${item.content}`} alt="Content Preview" className="content-image" />
+          <img src={`data:${contentType.mimeType};base64,${selectedItem.content}`} alt="Content Preview" className="content-image" />
         </ContentWrapper>
       );
     } else if (contentType.mimeType === 'application/pdf') {
       return (
         <ContentWrapper className="pdf-wrapper">
           <div className="pdf-container">
-            <iframe src={`data:${contentType.mimeType};base64,${item.content}`} className="pdf-frame" title="PDF Viewer"></iframe>
+            <iframe src={`data:${contentType.mimeType};base64,${selectedItem.content}`} className="pdf-frame" title="PDF Viewer"></iframe>
           </div>
         </ContentWrapper>
       );
@@ -59,7 +165,7 @@ const DetailView = ({
       return (
         <ContentWrapper className="audio-wrapper">
           <audio controls className="content-audio">
-            <source src={`data:${contentType.mimeType};base64,${item.content}`} type={contentType.mimeType} />
+            <source src={`data:${contentType.mimeType};base64,${selectedItem.content}`} type={contentType.mimeType} />
             Your browser does not support the audio element.
           </audio>
         </ContentWrapper>
@@ -68,7 +174,7 @@ const DetailView = ({
       return (
         <ContentWrapper className="video-wrapper">
           <video controls className="content-video">
-            <source src={`data:${contentType.mimeType};base64,${item.content}`} type={contentType.mimeType} />
+            <source src={`data:${contentType.mimeType};base64,${selectedItem.content}`} type={contentType.mimeType} />
             Your browser does not support the video element.
           </video>
         </ContentWrapper>
@@ -76,25 +182,25 @@ const DetailView = ({
     } else if (contentType.mimeType === 'text/html') {
       return (
         <ContentWrapper className="html-wrapper">
-          <div className="html-content" dangerouslySetInnerHTML={{ __html: item.content }}></div>
+          <div className="html-content" dangerouslySetInnerHTML={{ __html: selectedItem.content }}></div>
         </ContentWrapper>
       );
     } else if (contentType.mimeType === 'application/json' || 
-               (typeof item.content === 'string' && item.content.trim().startsWith('{'))) {
+              (typeof selectedItem.content === 'string' && selectedItem.content.trim().startsWith('{'))) {
       // Parse JSON if it's not already an object
       let jsonContent;
       try {
-        jsonContent = typeof item.content === 'string' 
-          ? JSON.parse(item.content) 
-          : item.content;
+        jsonContent = typeof selectedItem.content === 'string' 
+          ? JSON.parse(selectedItem.content) 
+          : selectedItem.content;
       } catch (e) {
         console.error('Error parsing JSON:', e);
         return (
           <ContentWrapper className="text-wrapper">
             <pre className="content-text">
-              {typeof item.content === 'string' 
-                ? item.content 
-                : JSON.stringify(item.content, null, 2)}
+              {typeof selectedItem.content === 'string' 
+                ? selectedItem.content 
+                : JSON.stringify(selectedItem.content, null, 2)}
             </pre>
           </ContentWrapper>
         );
@@ -111,8 +217,8 @@ const DetailView = ({
           <div className="csv-content">
             <table className="csv-table">
               <tbody>
-                {typeof item.content === 'string' && 
-                  item.content.split('\n').map((row, rowIndex) => (
+                {typeof selectedItem.content === 'string' && 
+                  selectedItem.content.split('\n').map((row, rowIndex) => (
                     <tr key={rowIndex}>
                       {row.split(',').map((cell, cellIndex) => (
                         <td key={cellIndex} className="csv-cell">
@@ -142,109 +248,16 @@ const DetailView = ({
               </label>
             </div>
             <pre className={`content-text ${!wordWrap ? 'wrap-text' : 'nowrap-text'}`}>
-              {typeof item.content === 'string' 
-                ? item.content 
-                : JSON.stringify(item.content, null, 2)}
+              {typeof selectedItem.content === 'string' 
+                ? selectedItem.content 
+                : JSON.stringify(selectedItem.content, null, 2)}
             </pre>
           </div>
         </ContentWrapper>
       );
     }
   };
-
-  // Helper function to render JSON with syntax highlighting and guaranteed wrapping
-  const renderJsonWithHighlighting = (jsonObj) => {
-    // Convert JSON to a vertical display format that won't overflow
-    const renderJsonAsTable = (obj, depth = 0) => {
-      // For primitive values, just return them formatted
-      if (typeof obj !== 'object' || obj === null) {
-        return renderPrimitiveValue(obj);
-      }
-      
-      // Recursive table builder
-      const rows = [];
-      
-      // Handle arrays or objects
-      const isArray = Array.isArray(obj);
-      
-      // For each key/index in the object/array
-      Object.entries(obj).forEach(([key, value], index) => {
-        // Create indentation based on depth
-        const indent = '  '.repeat(depth);
-        const displayKey = isArray ? `[${key}]` : key;
-        
-        // If value is an object, recurse, otherwise format the primitive
-        if (typeof value === 'object' && value !== null) {
-          // For objects/arrays, create a row with the key and a placeholder
-          rows.push(
-            `<tr>
-              <td class="json-key-cell">${indent}${displayKey}:</td>
-              <td class="json-value-cell">${isArray ? '[]' : '{'}...</td>
-            </tr>`
-          );
-          
-          // Add the nested object as indented rows
-          rows.push(renderJsonAsTable(value, depth + 1));
-          
-          // Close the object
-          rows.push(
-            `<tr>
-              <td class="json-key-cell">${indent}</td>
-              <td class="json-value-cell">${isArray ? ']' : '}'}</td>
-            </tr>`
-          );
-        } else {
-          // For primitive values, just add a row with the key and value
-          rows.push(
-            `<tr>
-              <td class="json-key-cell">${indent}${displayKey}:</td>
-              <td class="json-value-cell">${renderPrimitiveValue(value)}</td>
-            </tr>`
-          );
-        }
-      });
-      
-      return rows.join('');
-    };
-    
-    // Helper to format primitive values with truncation and highlighting
-    const renderPrimitiveValue = (value) => {
-      // Format and truncate based on type
-      if (typeof value === 'string') {
-        // Truncate long strings
-        const displayValue = value.length > 30 
-          ? `"${value.substring(0, 30)}..."` 
-          : `"${value}"`;
-        return `<span class="json-string">${displayValue}</span>`;
-      } else if (typeof value === 'number') {
-        return `<span class="json-number">${value}</span>`;
-      } else if (typeof value === 'boolean') {
-        return `<span class="json-boolean">${value}</span>`;
-      } else if (value === null) {
-        return `<span class="json-null">null</span>`;
-      } else {
-        return `<span>${String(value)}</span>`;
-      }
-    };
-    
-    // Create the table HTML
-    const tableHtml = `
-      <table class="json-table">
-        <tbody>
-          ${renderJsonAsTable(jsonObj)}
-        </tbody>
-      </table>
-    `;
-    
-    // Return the HTML table with inline styles for containment
-    return (
-      <div 
-        className="content-json-container" 
-        dangerouslySetInnerHTML={{ __html: tableHtml }}
-      />
-    );
-  };
-
+  
   return (
     <div className="catalog-detail-view">
       <div className="catalog-detail-header">
@@ -254,19 +267,19 @@ const DetailView = ({
         >
           Back
         </button>
-        <h2>{item.name}</h2>
+        <h2>{selectedItem.name}</h2>
       </div>
       
       <div className="catalog-detail-content">
         <div className="catalog-detail-info">
           <div className="info-section">
-            <p><strong>Hash:</strong> {item.hash}</p>
+            <p><strong>Hash:</strong> {selectedItem.hash}</p>
             <p><strong>Type:</strong> {
-              item.contentType?.mimeType 
-                ? `${getSimpleContentType(item.contentType.mimeType) || item.contentType.mimeType} (${item.contentType.mimeType})` 
+              selectedItem.contentType?.mimeType 
+                ? `${getFormattedContentType(selectedItem.contentType.mimeType)} (${selectedItem.contentType.mimeType})` 
                 : 'Unknown'
             }</p>
-            <p><strong>gtime:</strong> {new Date(item.timestamp).toLocaleString()}</p>
+            <p><strong>gtime:</strong> {new Date(selectedItem.timestamp).toLocaleString()}</p>
           </div>
           
           <div className="content-section">
@@ -279,7 +292,7 @@ const DetailView = ({
           <div className="catalog-detail-actions">
             <button 
               className="btn btn-danger"
-              onClick={() => onDelete(item.hash)}
+              onClick={() => onDeleteItem(selectedItem.hash)}
             >
               Delete
             </button>
diff --git a/src/components/panels/catalog/GridView.jsx b/src/components/panels/catalog/GridView.jsx
new file mode 100644
index 0000000..7d87f6d
--- /dev/null
+++ b/src/components/panels/catalog/GridView.jsx
@@ -0,0 +1,146 @@
+import React, { useEffect, useState } from 'react';
+import CardThumbnail from './CardThumbnail';
+import PaginationControls from './PaginationControls';
+import { getSimpleContentType, getContentTypeDisplay } from './utils';
+
+/**
+ * Grid view component for catalog items
+ */
+const GridView = ({ 
+  loading, 
+  error,
+  searchError, 
+  isSearchMode, 
+  searchResults,
+  sortedItems, 
+  paginationInfo, 
+  onSelectItem, 
+  onDeleteItem,
+  onPageChange 
+}) => {
+  const [itemsWithVerifiedTypes, setItemsWithVerifiedTypes] = useState({});
+  
+  // Get content type display mapping
+  const contentTypeMap = getContentTypeDisplay();
+
+  // Helper function to get proper content type display
+  const getFormattedContentType = (item) => {
+    // If we have already verified this item's content type, use that
+    if (itemsWithVerifiedTypes[item.id]) {
+      const verifiedType = itemsWithVerifiedTypes[item.id];
+      return `${contentTypeMap[verifiedType] || verifiedType.toUpperCase()} (image/${verifiedType})`;
+    }
+    
+    // Otherwise use the content type from the item data
+    if (!item.contentType?.mimeType) return 'Unknown';
+    
+    const simpleType = getSimpleContentType(item.contentType.mimeType);
+    if (!simpleType) return item.contentType.mimeType;
+    
+    return `${contentTypeMap[simpleType] || simpleType.toUpperCase()} (${item.contentType.mimeType})`;
+  };
+
+  // Verify content types by checking if images load
+  useEffect(() => {
+    if (!sortedItems || sortedItems.length === 0) return;
+    
+    // Check each item to see if it's actually an image
+    sortedItems.forEach(item => {
+      if (itemsWithVerifiedTypes[item.id]) return; // Skip if already verified
+      
+      // Try to load the item as an image
+      const img = new Image();
+      img.onload = () => {
+        // If it loads, it's an image
+        const imgType = img.src.includes('.gif') ? 'gif' : 'png';
+        setItemsWithVerifiedTypes(prev => ({
+          ...prev,
+          [item.id]: imgType
+        }));
+      };
+      img.onerror = () => {
+        // If it fails to load, it's not an image - keep original type
+      };
+      img.src = `/api/card-collection?action=get&hash=${item.id}`;
+    });
+  }, [sortedItems]);
+
+  if (loading) {
+    return <div className="loading-indicator">Loading items...</div>;
+  }
+
+  if (error) {
+    return <div className="error-message">Error: {error}</div>;
+  }
+
+  if (searchError) {
+    return <div className="error-message">Search error: {searchError}</div>;
+  }
+
+  if (sortedItems.length === 0) {
+    return (
+      <div className="empty-state">
+        {isSearchMode 
+          ? <p>No results found for "{searchResults.searchTerm}"</p>
+          : <p>No items available. Add your first item to get started.</p>
+        }
+      </div>
+    );
+  }
+
+  return (
+    <>
+      <div className="catalog-grid-view">
+        {sortedItems.map(item => (
+          <div key={item.id} className="grid-item">
+            <div 
+              className="grid-item-card" 
+              onClick={() => onSelectItem(item)}
+            >
+              <div className="grid-item-thumbnail">
+                <CardThumbnail 
+                  item={{
+                    ...item,
+                    contentType: itemsWithVerifiedTypes[item.id] 
+                      ? { mimeType: `image/${itemsWithVerifiedTypes[item.id]}` } 
+                      : item.contentType
+                  }} 
+                />
+              </div>
+              <div className="grid-item-info">
+                <h3 className="grid-item-title">{item.name}</h3>
+                <div className="grid-item-meta">
+                  <span className="grid-item-type">
+                    {getFormattedContentType(item)}
+                  </span>
+                  <span className="grid-item-date">
+                    {new Date(item.timestamp).toLocaleDateString()}
+                  </span>
+                </div>
+                <p className="grid-item-description">{item.description}</p>
+              </div>
+              <div className="grid-item-actions">
+                <button 
+                  className="btn btn-small btn-danger"
+                  onClick={(e) => {
+                    e.stopPropagation();
+                    onDeleteItem(item.id);
+                  }}
+                >
+                  Delete
+                </button>
+              </div>
+            </div>
+          </div>
+        ))}
+      </div>
+      
+      <PaginationControls 
+        paginationInfo={paginationInfo} 
+        onPageChange={onPageChange} 
+      />
+    </>
+  );
+};
+
+export default GridView;
diff --git a/src/components/panels/catalog/ListView.jsx b/src/components/panels/catalog/ListView.jsx
new file mode 100644
index 0000000..fa51a3e
--- /dev/null
+++ b/src/components/panels/catalog/ListView.jsx
@@ -0,0 +1,113 @@
+import React from 'react';
+import CardThumbnail from './CardThumbnail';
+import PaginationControls from './PaginationControls';
+import { getSimpleContentType, getContentTypeDisplay } from './utils';
+
+/**
+ * List view component for catalog items
+ */
+const ListView = ({ 
+  loading, 
+  error, 
+  searchError, 
+  isSearchMode, 
+  searchResults,
+  sortedItems, 
+  paginationInfo, 
+  onSelectItem, 
+  onDeleteItem,
+  onPageChange 
+}) => {
+  // Get content type display mapping
+  const contentTypeMap = getContentTypeDisplay();
+
+  // Helper function to get proper content type display
+  const getFormattedContentType = (mimeType) => {
+    if (!mimeType) return 'Unknown';
+    
+    const simpleType = getSimpleContentType(mimeType);
+    if (!simpleType) return mimeType;
+    
+    return contentTypeMap[simpleType] || simpleType.toUpperCase();
+  };
+
+  if (loading) {
+    return <div className="loading-indicator">Loading items...</div>;
+  }
+
+  if (error) {
+    return <div className="error-message">Error: {error}</div>;
+  }
+
+  if (searchError) {
+    return <div className="error-message">Search error: {searchError}</div>;
+  }
+
+  if (sortedItems.length === 0) {
+    return (
+      <div className="empty-state">
+        {isSearchMode 
+          ? <p>No results found for "{searchResults.searchTerm}"</p>
+          : <p>No items available. Add your first item to get started.</p>
+        }
+      </div>
+    );
+  }
+
+  return (
+    <>
+      <div className="catalog-list-cards">
+        {sortedItems.map(item => (
+          <div key={item.id} className="list-card">
+            <div className="list-card-inner" onClick={() => onSelectItem(item)}>
+              <div className="list-card-thumbnail">
+                <CardThumbnail item={item} />
+              </div>
+              <div className="list-card-content">
+                <h3 className="list-card-title">{item.name}</h3>
+                <div className="list-card-meta">
+                  <span className="list-card-type">
+                    {item.contentType?.mimeType 
+                      ? getFormattedContentType(item.contentType.mimeType)
+                      : 'Unknown'}
+                  </span>
+                  <span className="list-card-date">
+                    {new Date(item.timestamp).toLocaleString()}
+                  </span>
+                </div>
+                <p className="list-card-description">{item.description}</p>
+              </div>
+              <div className="list-card-actions">
+                <button 
+                  className="btn btn-small btn-info"
+                  onClick={(e) => {
+                    e.stopPropagation();
+                    onSelectItem(item);
+                  }}
+                >
+                  View
+                </button>
+                <button 
+                  className="btn btn-small btn-danger"
+                  onClick={(e) => {
+                    e.stopPropagation();
+                    onDeleteItem(item.id);
+                  }}
+                >
+                  Delete
+                </button>
+              </div>
+            </div>
+          </div>
+        ))}
+      </div>
+      
+      <PaginationControls 
+        paginationInfo={paginationInfo} 
+        onPageChange={onPageChange} 
+      />
+    </>
+  );
+};
+
+export default ListView;
diff --git a/src/components/panels/catalog/PaginationControls.jsx b/src/components/panels/catalog/PaginationControls.jsx
new file mode 100644
index 0000000..ba50e37
--- /dev/null
+++ b/src/components/panels/catalog/PaginationControls.jsx
@@ -0,0 +1,35 @@
+import React from 'react';
+
+/**
+ * Pagination controls component for catalog views
+ */
+const PaginationControls = ({ paginationInfo, onPageChange }) => {
+  if (paginationInfo.totalPages <= 1) {
+    return null;
+  }
+  
+  return (
+    <div className="pagination-controls">
+      <button 
+        className="btn btn-pagination" 
+        disabled={paginationInfo.currentPage <= 1}
+        onClick={() => onPageChange(paginationInfo.currentPage - 1)}
+      >
+        Previous
+      </button>
+      <span className="pagination-info">
+        Page {paginationInfo.currentPage} of {paginationInfo.totalPages}
+        {paginationInfo.totalItems && ` (${paginationInfo.totalItems} total items)`}
+      </span>
+      <button 
+        className="btn btn-pagination" 
+        disabled={paginationInfo.currentPage >= paginationInfo.totalPages}
+        onClick={() => onPageChange(paginationInfo.currentPage + 1)}
+      >
+        Next
+      </button>
+    </div>
+  );
+};
+
+export default PaginationControls;
diff --git a/src/components/panels/catalog/api/catalogService.js b/src/components/panels/catalog/api/catalogService.js
deleted file mode 100644
index 429db58..0000000
--- a/src/components/panels/catalog/api/catalogService.js
+++ /dev/null
@@ -1,293 +0,0 @@
-/**
- * Catalog API Service
- * Handles all API interactions for the catalog panel
- */
-
-/**
- * Fetch catalog items with pagination
- * @param {number} pageNumber - Page number to fetch
- * @param {number} pageSize - Number of items per page
- * @returns {Promise} - API response
- */
-export const fetchCatalogItems = async (pageNumber = 1, pageSize = 20) => {
-  try {
-    const response = await fetch(`/api/card-collection?action=getPage&pageNumber=${pageNumber}&pageSize=${pageSize}`);
-    const data = await response.json();
-    
-    if (data.success) {
-      return {
-        success: true,
-        items: transformApiItems(data),
-        pagination: {
-          currentPage: data.currentPage || 1,
-          totalPages: data.totalPages || Math.ceil((data.totalCards || data.totalItems || 0) / pageSize),
-          totalItems: data.totalCards || data.totalItems || 0,
-          pageSize
-        }
-      };
-    }
-    
-    return {
-      success: false,
-      error: data.error || 'Failed to fetch items'
-    };
-  } catch (error) {
-    console.error('Error fetching catalog items:', error);
-    return {
-      success: false,
-      error: 'Failed to fetch catalog items. Please try again.'
-    };
-  }
-};
-
-/**
- * Search catalog items by content
- * @param {string} searchTerm - Text to search for
- * @param {number} pageNumber - Page number to fetch
- * @param {number} pageSize - Number of items per page
- * @returns {Promise} - API response
- */
-export const searchCatalogItems = async (searchTerm, pageNumber = 1, pageSize = 20) => {
-  try {
-    const response = await fetch(
-      `/api/card-collection?action=searchByContent&searchTerm=${encodeURIComponent(searchTerm)}&pageNumber=${pageNumber}&pageSize=${pageSize}`
-    );
-    
-    const data = await response.json();
-    
-    if (data.success) {
-      return {
-        success: true,
-        items: transformApiItems(data),
-        pagination: {
-          currentPage: data.currentPage || pageNumber,
-          totalPages: data.totalPages || Math.ceil((data.totalResults || data.totalItems || 0) / pageSize),
-          totalItems: data.totalResults || data.totalItems || 0,
-          pageSize,
-          searchTerm
-        }
-      };
-    }
-    
-    return {
-      success: false,
-      error: data.error || 'Search failed'
-    };
-  } catch (error) {
-    console.error('Error searching catalog items:', error);
-    return {
-      success: false,
-      error: 'Search failed. Please try again.'
-    };
-  }
-};
-
-/**
- * Fetch catalog item by hash
- * @param {string} hash - Item hash
- * @returns {Promise} - API response
- */
-export const fetchItemById = async (hash) => {
-  try {
-    const response = await fetch(`/api/card-collection?action=get&hash=${hash}`);
-    const data = await response.json();
-    
-    if (data.success) {
-      const cardData = data.card;
-      
-      let description = 'Binary content';
-      const content = cardData.content;
-      
-      if (typeof content === 'string') {
-        description = content.substring(0, 200) + (content.length > 200 ? '...' : '');
-      } else if (content && typeof content === 'object') {
-        if (content.type === 'string') {
-          description = content.data.substring(0, 200) + (content.data.length > 200 ? '...' : '');
-        } else if (content.type === 'base64') {
-          description = `Binary content (${content.originalType || 'unknown type'})`;
-        }
-      }
-      
-      return {
-        success: true,
-        item: {
-          id: cardData.hash,
-          name: cardData.hash.substring(0, 8),
-          category: cardData.contentType?.mimeType || 'Unknown',
-          description,
-          hash: cardData.hash,
-          content: cardData.content,
-          timestamp: cardData.timestamp || new Date().toISOString(),
-          contentType: cardData.contentType
-        }
-      };
-    }
-    
-    return {
-      success: false,
-      error: data.error || 'Failed to fetch card'
-    };
-  } catch (error) {
-    console.error('Error fetching card by ID:', error);
-    return {
-      success: false,
-      error: 'Failed to fetch card. Please try again.'
-    };
-  }
-};
-
-/**
- * Delete a catalog item
- * @param {string} hash - Item hash
- * @returns {Promise} - API response
- */
-export const deleteItem = async (hash) => {
-  try {
-    const response = await fetch(`/api/card-collection?action=delete&hash=${hash}`, { 
-      method: 'DELETE' 
-    });
-    
-    const data = await response.json();
-    
-    return {
-      success: data.success,
-      error: data.success ? null : (data.error || 'Failed to delete item')
-    };
-  } catch (error) {
-    console.error('Error deleting catalog item:', error);
-    return {
-      success: false,
-      error: 'Failed to delete item. Please try again.'
-    };
-  }
-};
-
-/**
- * Add a file to the catalog
- * @param {Object} file - File to upload
- * @param {Object} metadata - Metadata for the file
- * @returns {Promise} - API response
- */
-export const addFileItem = async (file, metadata) => {
-  try {
-    const formData = new FormData();
-    formData.append('file', file);
-    formData.append('metadata', JSON.stringify(metadata));
-    formData.append('action', 'add');
-    
-    const response = await fetch('/api/card-collection?action=add', {
-      method: 'POST',
-      body: formData
-    });
-    
-    if (!response.ok) {
-      const errorData = await response.json();
-      throw new Error(errorData.error || `Server responded with ${response.status}`);
-    }
-    
-    const data = await response.json();
-    
-    if (data.success) {
-      return {
-        success: true,
-        hash: data.hash
-      };
-    }
-    
-    return {
-      success: false,
-      error: data.error || 'Failed to add item'
-    };
-  } catch (error) {
-    console.error('Error adding file item:', error);
-    return {
-      success: false,
-      error: `Failed to add item: ${error.message}`
-    };
-  }
-};
-
-/**
- * Add text content to the catalog
- * @param {Object} content - Text content and metadata
- * @returns {Promise} - API response
- */
-export const addTextContent = async (content) => {
-  try {
-    const response = await fetch('/api/card-collection?action=add', {
-      method: 'POST',
-      headers: { 'Content-Type': 'application/json' },
-      body: JSON.stringify({
-        action: 'add',
-        card: {
-          content: content.text,
-          hash_algorithm: 'sha256'
-        }
-      })
-    });
-    
-    if (!response.ok) {
-      const errorData = await response.json();
-      throw new Error(errorData.error || `Server responded with ${response.status}`);
-    }
-    
-    const data = await response.json();
-    
-    if (data.success) {
-      return {
-        success: true,
-        hash: data.hash
-      };
-    }
-    
-    return {
-      success: false,
-      error: data.error || 'Failed to add item'
-    };
-  } catch (error) {
-    console.error('Error adding text content:', error);
-    return {
-      success: false,
-      error: `Failed to add item: ${error.message}`
-    };
-  }
-};
-
-/**
- * Helper function to transform API response items into a consistent format
- * @param {Object} data - API response data
- * @returns {Array} - Transformed items
- */
-const transformApiItems = (data) => {
-  let transformedItems = [];
-  
-  if (data.cards && Array.isArray(data.cards)) {
-    // Format from getPage endpoint
-    transformedItems = data.cards.map(card => ({
-      id: card.hash,
-      name: card.hash.substring(0, 8), // Use first 8 chars of hash as name
-      category: card.contentType?.mimeType || 'Unknown',
-      description: 'Card content hash: ' + card.hash,
-      timestamp: card.timestamp || new Date().toISOString(),
-      hash: card.hash,
-      contentType: card.contentType,
-      metaData: card.metaData || {}
-    }));
-  } else if (data.items && Array.isArray(data.items)) {
-    // Alternative format from list endpoint
-    transformedItems = data.items.map(item => ({
-      id: item.id || item.hash,
-      name: item.name || (item.hash ? item.hash.substring(0, 8) : 'Unknown'),
-      category: item.category || item.contentType?.mimeType || 'Unknown',
-      description: item.description || 'No description available',
-      timestamp: item.timestamp || new Date().toISOString(),
-      hash: item.hash || item.id,
-      contentType: item.contentType || { mimeType: 'text/plain' },
-      metaData: item.metaData || {}
-    }));
-  } else {
-    console.warn('Unexpected API response format:', data);
-  }
-  
-  return transformedItems;
-};
diff --git a/src/components/panels/catalog/index.js b/src/components/panels/catalog/index.js
deleted file mode 100644
index 468506a..0000000
--- a/src/components/panels/catalog/index.js
+++ /dev/null
@@ -1,3 +0,0 @@
-import CatalogPanel from './CatalogPanel';
-
-export default CatalogPanel;
diff --git a/src/components/panels/catalog/utils.js b/src/components/panels/catalog/utils.js
new file mode 100644
index 0000000..4b1bdeb
--- /dev/null
+++ b/src/components/panels/catalog/utils.js
@@ -0,0 +1,45 @@
+/**
+ * Utility functions for catalog components
+ */
+
+// Extract simple content type from MIME type
+export const getSimpleContentType = (mimeType) => {
+  if (!mimeType) return null;
+  
+  // Extract the subtype from the MIME type
+  const parts = mimeType.split('/');
+  if (parts.length < 2) return null;
+  
+  const subtype = parts[1];
+  
+  // Handle special cases
+  if (subtype.includes('json')) return 'json';
+  if (subtype.includes('javascript')) return 'js';
+  if (subtype === 'plain') return 'txt';
+  if (subtype === 'html') return 'html';
+  if (subtype === 'css') return 'css';
+  if (subtype === 'svg+xml') return 'svg';
+  
+  // Return the subtype as-is for common formats (gif, png, jpg, etc.)
+  return subtype;
+};
+
+// Get content type display mapping for UI
+export const getContentTypeDisplay = () => ({
+  'json': 'JSON',
+  'txt': 'TXT',
+  'csv': 'CSV',
+  'pdf': 'PDF',
+  'mp3': 'üéµ Audio',
+  'wav': 'üéµ Audio',
+  'mp4': 'üé¨ Video',
+  'png': 'üñºÔ∏è Image',
+  'jpg': 'üñºÔ∏è Image',
+  'jpeg': 'üñºÔ∏è Image',
+  'gif': 'üñºÔ∏è Image',
+  'js': 'JS',
+  'html': 'HTML',
+  'xml': 'XML',
+  'css': 'CSS',
+  'svg': 'SVG'
+});
diff --git a/src/components/panels/catalog/utils/contentTypeUtils.js b/src/components/panels/catalog/utils/contentTypeUtils.js
deleted file mode 100644
index 806ba1f..0000000
--- a/src/components/panels/catalog/utils/contentTypeUtils.js
+++ /dev/null
@@ -1,74 +0,0 @@
-/**
- * Utility functions for content type handling in the catalog panel
- */
-
-/**
- * Extract a simple content type from MIME type for display purposes
- * @param {string} mimeType - The MIME type (e.g., 'text/plain', 'image/jpeg')
- * @returns {string|null} - Simple type string or null if invalid
- */
-export const getSimpleContentType = (mimeType) => {
-  if (!mimeType) return null;
-  
-  // Extract the subtype from the MIME type
-  const parts = mimeType.split('/');
-  if (parts.length < 2) return null;
-  
-  const subtype = parts[1];
-  
-  // Handle special cases
-  if (subtype.includes('json')) return 'json';
-  if (subtype.includes('javascript')) return 'js';
-  if (subtype === 'plain') return 'txt';
-  if (subtype === 'html') return 'html';
-  if (subtype === 'css') return 'css';
-  if (subtype === 'svg+xml') return 'svg';
-  
-  // Return the subtype as-is for common formats (gif, png, jpg, etc.)
-  return subtype;
-};
-
-/**
- * Get a display label for a content type
- * @param {object} contentType - Content type object with mimeType property
- * @returns {string} - Formatted display string 
- */
-export const getContentTypeDisplay = (contentType) => {
-  if (!contentType || !contentType.mimeType) return 'Unknown';
-  
-  const simpleType = getSimpleContentType(contentType.mimeType);
-  return `${simpleType || contentType.mimeType} (${contentType.mimeType})`;
-};
-
-/**
- * Default content types used in the app
- */
-export const DEFAULT_CONTENT_TYPES = {
-  TEXT: 'text/plain',
-  JSON: 'application/json',
-  BINARY: 'application/octet-stream',
-  HTML: 'text/html',
-  CSV: 'text/csv'
-};
-
-/**
- * Get content type icon or display names for different formats
- */
-export const contentTypeDisplayMap = {
-  'json': 'JSON',
-  'txt': 'TXT',
-  'csv': 'CSV',
-  'pdf': 'PDF',
-  'mp3': 'üéµ Audio',
-  'wav': 'üéµ Audio', 
-  'mp4': 'üé¨ Video',
-  'png': 'üñºÔ∏è Image',
-  'jpg': 'üñºÔ∏è Image',
-  'jpeg': 'üñºÔ∏è Image',
-  'gif': 'üñºÔ∏è Image',
-  'js': 'JS',
-  'html': 'HTML',
-  'xml': 'XML',
-  'css': 'CSS',
-  'svg': 'SVG'
-};
diff --git a/src/components/panels/catalog/views/GridView.jsx b/src/components/panels/catalog/views/GridView.jsx
deleted file mode 100644
index b9fa2e8..0000000
--- a/src/components/panels/catalog/views/GridView.jsx
+++ /dev/null
@@ -1,142 +0,0 @@
-import React from 'react';
-import { getSimpleContentType, contentTypeDisplayMap } from '../utils/contentTypeUtils';
-
-/**
- * GridView component for displaying catalog items in a grid layout
- */
-const GridView = ({ 
-  items, 
-  isLoading, 
-  error,
-  pagination, 
-  onSelectItem, 
-  onDeleteItem,
-  onPageChange,
-  isSearchMode,
-  searchTerm,
-  searchError
-}) => {
-  if (isLoading) {
-    return <div className="loading-indicator">Loading items...</div>;
-  }
-
-  if (error) {
-    return <div className="error-message">Error: {error}</div>;
-  }
-
-  if (searchError) {
-    return <div className="error-message">Search error: {searchError}</div>;
-  }
-
-  if (items.length === 0) {
-    return (
-      <div className="empty-state">
-        {isSearchMode 
-          ? <p>No results found for "{searchTerm}"</p>
-          : <p>No items available. Add your first item to get started.</p>
-        }
-      </div>
-    );
-  }
-
-  // Get thumbnail for different content types
-  const getCardThumbnail = (item) => {
-    const contentType = item.contentType?.mimeType || 'unknown';
-    const simpleType = getSimpleContentType(contentType);
-    
-    // Image thumbnails for image types
-    if (contentType.startsWith('image/')) {
-      return (
-        <img 
-          src={`/api/card-collection?action=get&hash=${item.id}`} 
-          alt={item.name} 
-          onError={(e) => {
-            e.target.onerror = null;
-            e.target.src = "https://placehold.co/300x300?text=No+Preview";
-          }}
-        />
-      );
-    }
-    
-    // Icons or placeholders for other content types
-    const displayType = simpleType && contentTypeDisplayMap[simpleType] 
-      ? contentTypeDisplayMap[simpleType]
-      : contentType || 'Unknown';
-    
-    return (
-      <div className="image-placeholder">
-        {displayType}
-      </div>
-    );
-  };
-
-  return (
-    <>
-      <div className="catalog-grid-view">
-        {items.map(item => (
-          <div key={item.id} className="grid-item">
-            <div 
-              className="grid-item-card" 
-              onClick={() => onSelectItem(item)}
-            >
-              <div className="grid-item-thumbnail">
-                {getCardThumbnail(item)}
-              </div>
-              <div className="grid-item-info">
-                <h3 className="grid-item-title">{item.name}</h3>
-                <div className="grid-item-meta">
-                  <span className="grid-item-type">
-                    {item.contentType?.mimeType 
-                      ? getSimpleContentType(item.contentType.mimeType) || item.contentType.mimeType 
-                      : 'Unknown'}
-                  </span>
-                  <span className="grid-item-date">
-                    {new Date(item.timestamp).toLocaleDateString()}
-                  </span>
-                </div>
-                <p className="grid-item-description">{item.description}</p>
-              </div>
-              <div className="grid-item-actions">
-                <button 
-                  className="btn btn-small btn-danger"
-                  onClick={(e) => {
-                    e.stopPropagation();
-                    onDeleteItem(item.id);
-                  }}
-                >
-                  Delete
-                </button>
-              </div>
-            </div>
-          </div>
-        ))}
-      </div>
-      
-      {/* Pagination */}
-      {pagination.totalPages > 1 && (
-        <div className="pagination-controls">
-          <button 
-            className="btn btn-pagination" 
-            disabled={pagination.currentPage <= 1}
-            onClick={() => onPageChange(pagination.currentPage - 1)}
-          >
-            Previous
-          </button>
-          <span className="pagination-info">
-            Page {pagination.currentPage} of {pagination.totalPages}
-            {pagination.totalItems && ` (${pagination.totalItems} total items)`}
-          </span>
-          <button 
-            className="btn btn-pagination" 
-            disabled={pagination.currentPage >= pagination.totalPages}
-            onClick={() => onPageChange(pagination.currentPage + 1)}
-          >
-            Next
-          </button>
-        </div>
-      )}
-    </>
-  );
-};
-
-export default GridView;
diff --git a/src/components/panels/catalog/views/ListView.jsx b/src/components/panels/catalog/views/ListView.jsx
deleted file mode 100644
index c74b29b..0000000
--- a/src/components/panels/catalog/views/ListView.jsx
+++ /dev/null
@@ -1,148 +0,0 @@
-import React from 'react';
-import { getSimpleContentType, contentTypeDisplayMap } from '../utils/contentTypeUtils';
-
-/**
- * ListView component for displaying catalog items in a card-based list format
- */
-const ListView = ({ 
-  items, 
-  isLoading, 
-  error,
-  pagination, 
-  onSelectItem, 
-  onDeleteItem,
-  onPageChange,
-  isSearchMode,
-  searchTerm,
-  searchError
-}) => {
-  if (isLoading) {
-    return <div className="loading-indicator">Loading items...</div>;
-  }
-
-  if (error) {
-    return <div className="error-message">Error: {error}</div>;
-  }
-
-  if (searchError) {
-    return <div className="error-message">Search error: {searchError}</div>;
-  }
-
-  if (items.length === 0) {
-    return (
-      <div className="empty-state">
-        {isSearchMode 
-          ? <p>No results found for "{searchTerm}"</p>
-          : <p>No items available. Add your first item to get started.</p>
-        }
-      </div>
-    );
-  }
-
-  // Get thumbnail for different content types
-  const getCardThumbnail = (item) => {
-    const contentType = item.contentType?.mimeType || 'unknown';
-    const simpleType = getSimpleContentType(contentType);
-    
-    // Image thumbnails for image types
-    if (contentType.startsWith('image/')) {
-      return (
-        <img 
-          src={`/api/card-collection?action=get&hash=${item.id}`} 
-          alt={item.name} 
-          onError={(e) => {
-            e.target.onerror = null;
-            e.target.src = "https://placehold.co/300x300?text=No+Preview";
-          }}
-        />
-      );
-    }
-    
-    // Icons or placeholders for other content types
-    const displayType = simpleType && contentTypeDisplayMap[simpleType] 
-      ? contentTypeDisplayMap[simpleType]
-      : contentType || 'Unknown';
-    
-    return (
-      <div className="image-placeholder">
-        {displayType}
-      </div>
-    );
-  };
-
-  return (
-    <>
-      <div className="catalog-list-cards">
-        {items.map(item => (
-          <div key={item.id} className="list-card">
-            <div className="list-card-inner" onClick={() => onSelectItem(item)}>
-              <div className="list-card-thumbnail">
-                {getCardThumbnail(item)}
-              </div>
-              <div className="list-card-content">
-                <h3 className="list-card-title">{item.name}</h3>
-                <div className="list-card-meta">
-                  <span className="list-card-type">
-                    {item.contentType?.mimeType 
-                      ? getSimpleContentType(item.contentType.mimeType) || item.contentType.mimeType 
-                      : 'Unknown'}
-                  </span>
-                  <span className="list-card-date">
-                    {new Date(item.timestamp).toLocaleString()}
-                  </span>
-                </div>
-                <p className="list-card-description">{item.description}</p>
-              </div>
-              <div className="list-card-actions">
-                <button 
-                  className="btn btn-small btn-info"
-                  onClick={(e) => {
-                    e.stopPropagation();
-                    onSelectItem(item);
-                  }}
-                >
-                  View
-                </button>
-                <button 
-                  className="btn btn-small btn-danger"
-                  onClick={(e) => {
-                    e.stopPropagation();
-                    onDeleteItem(item.id);
-                  }}
-                >
-                  Delete
-                </button>
-              </div>
-            </div>
-          </div>
-        ))}
-      </div>
-      
-      {/* Pagination */}
-      {pagination.totalPages > 1 && (
-        <div className="pagination-controls">
-          <button 
-            className="btn btn-pagination" 
-            disabled={pagination.currentPage <= 1}
-            onClick={() => onPageChange(pagination.currentPage - 1)}
-          >
-            Previous
-          </button>
-          <span className="pagination-info">
-            Page {pagination.currentPage} of {pagination.totalPages}
-            {pagination.totalItems && ` (${pagination.totalItems} total items)`}
-          </span>
-          <button 
-            className="btn btn-pagination" 
-            disabled={pagination.currentPage >= pagination.totalPages}
-            onClick={() => onPageChange(pagination.currentPage + 1)}
-          >
-            Next
-          </button>
-        </div>
-      )}
-    </>
-  );
-};
-
-export default ListView;
diff --git a/src/components/panels/panels.json b/src/components/panels/panels.json
index e93c418..40ab012 100644
--- a/src/components/panels/panels.json
+++ b/src/components/panels/panels.json
@@ -52,5 +52,8 @@
   },
   "SimpleMQTTDashboardPanel": {
     "component": "../components/panels/SimpleMQTTDashboardPanel.jsx"
+  },
+  "CatalogPanel": {
+    "component": "../components/panels/CatalogPanel.jsx"
   }
 }

commit 273a56c4efd289e87f9f278c0de33e187e7b795f
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Wed Apr 9 02:24:21 2025 +0800

    new catalog

diff --git a/src/components/panels/catalog/CatalogPanel.jsx b/src/components/panels/catalog/CatalogPanel.jsx
new file mode 100644
index 0000000..e97cbd7
--- /dev/null
+++ b/src/components/panels/catalog/CatalogPanel.jsx
@@ -0,0 +1,436 @@
+import React, { useState, useEffect } from 'react';
+import { useDispatch } from 'react-redux';
+import { importCardFromDatabase, selectContent } from '../../../features/contentSlice';
+import { selectItem } from '../../../features/selectedItemSlice';
+
+// Import API services
+import { 
+  fetchCatalogItems, 
+  searchCatalogItems, 
+  fetchItemById,
+  deleteItem,
+  addFileItem,
+  addTextContent 
+} from './api/catalogService';
+
+// Import components
+import PanelHeader from './components/PanelHeader';
+import ListView from './views/ListView';
+import GridView from './views/GridView';
+import DetailView from './views/DetailView';
+import AddItemForm from './views/AddItemForm';
+
+// Import utilities
+import { DEFAULT_CONTENT_TYPES, getSimpleContentType } from './utils/contentTypeUtils';
+
+// Import styles
+import '../../../styles/CatalogPanel.css';
+
+/**
+ * CatalogPanel - A component for displaying and managing catalog items
+ * 
+ * Features:
+ * - List view with search/filter capabilities
+ * - Grid view with thumbnail support
+ * - Item categorization
+ * - Add/edit/remove operations
+ * - Detail view for individual items
+ * - Integration with card-collection API
+ */
+const CatalogPanel = () => {
+  const dispatch = useDispatch();
+  
+  // Component state
+  const [items, setItems] = useState([]);
+  const [selectedItem, setSelectedItem] = useState(null);
+  const [loading, setLoading] = useState(false);
+  const [itemLoading, setItemLoading] = useState(false);
+  const [searchLoading, setSearchLoading] = useState(false);
+  const [error, setError] = useState(null);
+  const [itemError, setItemError] = useState(null);
+  const [searchError, setSearchError] = useState(null);
+  const [pagination, setPagination] = useState({
+    currentPage: 1,
+    totalPages: 1,
+    totalItems: 0,
+    pageSize: 20
+  });
+  const [searchResults, setSearchResults] = useState({
+    items: [],
+    currentPage: 1,
+    totalPages: 1,
+    totalItems: 0,
+    searchTerm: ''
+  });
+  
+  const [viewMode, setViewMode] = useState('list'); // 'list', 'grid', 'detail', 'add'
+  const [isSearchMode, setIsSearchMode] = useState(false);
+  const [filter, setFilter] = useState('all');
+  const [sortBy, setSortBy] = useState('name');
+  const [addItemError, setAddItemError] = useState(null);
+  const [addItemLoading, setAddItemLoading] = useState(false);
+  
+  // Category list derived from items
+  const [categories, setCategories] = useState(['all']);
+
+  // Determine which items to display based on search mode
+  const displayItems = isSearchMode ? searchResults.items : items;
+  
+  // Pagination info based on mode
+  const paginationInfo = isSearchMode 
+    ? { 
+        currentPage: searchResults.currentPage, 
+        totalPages: searchResults.totalPages, 
+        totalItems: searchResults.totalItems,
+        pageSize: 20
+      } 
+    : pagination;
+
+  // Filter and sort items for the current view
+  const filteredItems = displayItems.filter(item => {
+    // Skip filtering in search mode
+    if (isSearchMode) return true;
+    
+    const matchesFilter = filter === 'all' || item.category === filter;
+    return matchesFilter;
+  });
+
+  // Sort items
+  const sortedItems = [...filteredItems].sort((a, b) => {
+    switch(sortBy) {
+      case 'name':
+        return a.name.localeCompare(b.name);
+      case 'timestamp':
+        return new Date(b.timestamp) - new Date(a.timestamp);
+      default:
+        return 0;
+    }
+  });
+
+  // Update categories whenever items change
+  useEffect(() => {
+    if (items.length > 0) {
+      const catSet = new Set(items.map(item => item.category));
+      const categoryArray = ['all', ...Array.from(catSet)].filter(c => c);
+      setCategories(categoryArray);
+    }
+  }, [items]);
+
+  // Fetch catalog items
+  const loadCatalogItems = async () => {
+    setLoading(true);
+    setError(null);
+    
+    const result = await fetchCatalogItems(pagination.currentPage, pagination.pageSize);
+    
+    if (result.success) {
+      setItems(result.items);
+      setPagination(result.pagination);
+    } else {
+      setError(result.error);
+    }
+    
+    setLoading(false);
+  };
+
+  // Initial fetch on component mount
+  useEffect(() => {
+    loadCatalogItems();
+  }, []);
+
+  // Handle refresh button click
+  const handleRefresh = () => {
+    // Clear search if in search mode
+    if (isSearchMode) {
+      setIsSearchMode(false);
+      setSearchResults({
+        items: [],
+        currentPage: 1,
+        totalPages: 1,
+        totalItems: 0,
+        searchTerm: ''
+      });
+    }
+    
+    // Fetch items again
+    loadCatalogItems();
+  };
+
+  // Handle pagination change
+  const handlePageChange = async (newPage) => {
+    if (isSearchMode) {
+      setSearchLoading(true);
+      setSearchError(null);
+      
+      const result = await searchCatalogItems(
+        searchResults.searchTerm, 
+        newPage, 
+        pagination.pageSize
+      );
+      
+      if (result.success) {
+        setSearchResults({
+          items: result.items,
+          currentPage: result.pagination.currentPage,
+          totalPages: result.pagination.totalPages,
+          totalItems: result.pagination.totalItems,
+          searchTerm: searchResults.searchTerm
+        });
+      } else {
+        setSearchError(result.error);
+      }
+      
+      setSearchLoading(false);
+    } else {
+      setLoading(true);
+      setError(null);
+      
+      const result = await fetchCatalogItems(newPage, pagination.pageSize);
+      
+      if (result.success) {
+        setItems(result.items);
+        setPagination(result.pagination);
+      } else {
+        setError(result.error);
+      }
+      
+      setLoading(false);
+    }
+  };
+
+  // Handle item selection
+  const handleSelectItem = async (item) => {
+    setItemLoading(true);
+    setItemError(null);
+    setViewMode('detail');
+    
+    const result = await fetchItemById(item.id);
+    
+    if (result.success) {
+      setSelectedItem(result.item);
+      
+      // Get content type from server response
+      const serverContentType = result.item.contentType;
+      
+      // Extract a simple content type string for the UI
+      const simpleType = serverContentType?.extension || 
+                     (serverContentType?.mimeType ? getSimpleContentType(serverContentType.mimeType) : null) || 
+                     "txt";
+      
+      // Import the card to contentSlice Redux store for cross-panel integration
+      dispatch(importCardFromDatabase({ 
+        hash: result.item.hash,
+        content: result.item.content,
+        metadata: {
+          contentType: serverContentType
+        },
+        relationships: {
+          parentHash: null,
+          childHashes: [],
+          relatedHashes: []
+        }
+      }));
+      
+      // Select the card in Redux
+      dispatch(selectContent(result.item.hash));
+      
+      // Update the selectedItem state with card details for selected item slice
+      dispatch(selectItem({
+        item: result.item.content,
+        hash: result.item.hash,
+        contentType: simpleType,
+        gtime: result.item.timestamp
+      }));
+    } else {
+      setItemError(result.error);
+    }
+    
+    setItemLoading(false);
+  };
+
+  // Handle item deletion
+  const handleDeleteItem = async (id) => {
+    if (window.confirm('Are you sure you want to delete this item?')) {
+      const result = await deleteItem(id);
+      
+      if (result.success) {
+        // Remove item from state
+        setItems(prevItems => prevItems.filter(item => item.id !== id));
+        // If we're viewing the item that was deleted, go back to list view
+        if (selectedItem && selectedItem.id === id) {
+          setSelectedItem(null);
+          setViewMode('list');
+        }
+      } else {
+        setError(result.error);
+      }
+    }
+  };
+
+  // Handle search submission
+  const handleSearch = async (searchTerm) => {
+    if (!searchTerm.trim()) {
+      // Clear search if empty
+      handleClearSearch();
+      return;
+    }
+    
+    setIsSearchMode(true);
+    setSearchLoading(true);
+    setSearchError(null);
+    
+    const result = await searchCatalogItems(searchTerm, 1, pagination.pageSize);
+    
+    if (result.success) {
+      setSearchResults({
+        items: result.items,
+        currentPage: result.pagination.currentPage,
+        totalPages: result.pagination.totalPages,
+        totalItems: result.pagination.totalItems,
+        searchTerm: searchTerm
+      });
+    } else {
+      setSearchError(result.error);
+    }
+    
+    setSearchLoading(false);
+  };
+
+  // Clear search and return to normal view
+  const handleClearSearch = () => {
+    setIsSearchMode(false);
+    setSearchResults({
+      items: [],
+      currentPage: 1,
+      totalPages: 1,
+      totalItems: 0,
+      searchTerm: ''
+    });
+  };
+
+  // Handle new item submission from the AddItemForm
+  const handleAddItem = async (formData) => {
+    setAddItemLoading(true);
+    setAddItemError(null);
+    
+    let result;
+    
+    if (formData.file) {
+      // File upload
+      const metadata = {
+        fileName: formData.name,
+        mimeType: formData.contentType || DEFAULT_CONTENT_TYPES.BINARY,
+        size: formData.file.size,
+        description: formData.description || ''
+      };
+      
+      result = await addFileItem(formData.file, metadata);
+    } else if (formData.description) {
+      // Text content
+      result = await addTextContent({
+        text: formData.description,
+        name: formData.name,
+        contentType: formData.contentType || DEFAULT_CONTENT_TYPES.TEXT
+      });
+    } else {
+      setAddItemError('Please provide content to add');
+      setAddItemLoading(false);
+      return;
+    }
+    
+    if (result.success) {
+      // Successfully added, refresh the catalog and reset the form
+      loadCatalogItems();
+      setViewMode('list');
+    } else {
+      setAddItemError(result.error);
+    }
+    
+    setAddItemLoading(false);
+  };
+
+  // Handle filter change
+  const handleFilterChange = (newFilter) => {
+    setFilter(newFilter);
+  };
+
+  // Handle view mode change
+  const handleViewModeChange = (newMode) => {
+    setViewMode(newMode);
+  };
+
+  return (
+    <div className="catalog-panel" style={{ height: '100%', width: '100%', display: 'flex', flexDirection: 'column' }}>
+      <PanelHeader 
+        viewMode={viewMode}
+        onViewModeChange={handleViewModeChange}
+        onRefresh={handleRefresh}
+        onSearch={handleSearch}
+        onClearSearch={handleClearSearch}
+        isSearchMode={isSearchMode}
+        categories={categories}
+        filter={filter}
+        onFilterChange={handleFilterChange}
+      />
+      
+      {isSearchMode && searchResults.searchTerm && (
+        <div className="search-status">
+          Showing results for "{searchResults.searchTerm}" ({searchResults.totalItems || 0} items found)
+        </div>
+      )}
+      
+      <div className="catalog-content" style={{ flex: 1, overflow: 'auto', position: 'relative' }}>
+        {viewMode === 'list' && (
+          <ListView 
+            items={sortedItems}
+            isLoading={loading || searchLoading}
+            error={error}
+            pagination={paginationInfo}
+            onSelectItem={handleSelectItem}
+            onDeleteItem={handleDeleteItem}
+            onPageChange={handlePageChange}
+            isSearchMode={isSearchMode}
+            searchTerm={searchResults.searchTerm}
+            searchError={searchError}
+          />
+        )}
+        
+        {viewMode === 'grid' && (
+          <GridView 
+            items={sortedItems}
+            isLoading={loading || searchLoading}
+            error={error}
+            pagination={paginationInfo}
+            onSelectItem={handleSelectItem}
+            onDeleteItem={handleDeleteItem}
+            onPageChange={handlePageChange}
+            isSearchMode={isSearchMode}
+            searchTerm={searchResults.searchTerm}
+            searchError={searchError}
+          />
+        )}
+        
+        {viewMode === 'detail' && (
+          <DetailView 
+            item={selectedItem}
+            isLoading={itemLoading}
+            error={itemError}
+            onBack={() => setViewMode('list')}
+            onDelete={handleDeleteItem}
+          />
+        )}
+        
+        {viewMode === 'add' && (
+          <AddItemForm 
+            onSubmit={handleAddItem}
+            onCancel={() => setViewMode('list')}
+            isLoading={addItemLoading}
+            error={addItemError}
+          />
+        )}
+      </div>
+    </div>
+  );
+};
+
+export default CatalogPanel;
diff --git a/src/components/panels/catalog/api/catalogService.js b/src/components/panels/catalog/api/catalogService.js
new file mode 100644
index 0000000..429db58
--- /dev/null
+++ b/src/components/panels/catalog/api/catalogService.js
@@ -0,0 +1,293 @@
+/**
+ * Catalog API Service
+ * Handles all API interactions for the catalog panel
+ */
+
+/**
+ * Fetch catalog items with pagination
+ * @param {number} pageNumber - Page number to fetch
+ * @param {number} pageSize - Number of items per page
+ * @returns {Promise} - API response
+ */
+export const fetchCatalogItems = async (pageNumber = 1, pageSize = 20) => {
+  try {
+    const response = await fetch(`/api/card-collection?action=getPage&pageNumber=${pageNumber}&pageSize=${pageSize}`);
+    const data = await response.json();
+    
+    if (data.success) {
+      return {
+        success: true,
+        items: transformApiItems(data),
+        pagination: {
+          currentPage: data.currentPage || 1,
+          totalPages: data.totalPages || Math.ceil((data.totalCards || data.totalItems || 0) / pageSize),
+          totalItems: data.totalCards || data.totalItems || 0,
+          pageSize
+        }
+      };
+    }
+    
+    return {
+      success: false,
+      error: data.error || 'Failed to fetch items'
+    };
+  } catch (error) {
+    console.error('Error fetching catalog items:', error);
+    return {
+      success: false,
+      error: 'Failed to fetch catalog items. Please try again.'
+    };
+  }
+};
+
+/**
+ * Search catalog items by content
+ * @param {string} searchTerm - Text to search for
+ * @param {number} pageNumber - Page number to fetch
+ * @param {number} pageSize - Number of items per page
+ * @returns {Promise} - API response
+ */
+export const searchCatalogItems = async (searchTerm, pageNumber = 1, pageSize = 20) => {
+  try {
+    const response = await fetch(
+      `/api/card-collection?action=searchByContent&searchTerm=${encodeURIComponent(searchTerm)}&pageNumber=${pageNumber}&pageSize=${pageSize}`
+    );
+    
+    const data = await response.json();
+    
+    if (data.success) {
+      return {
+        success: true,
+        items: transformApiItems(data),
+        pagination: {
+          currentPage: data.currentPage || pageNumber,
+          totalPages: data.totalPages || Math.ceil((data.totalResults || data.totalItems || 0) / pageSize),
+          totalItems: data.totalResults || data.totalItems || 0,
+          pageSize,
+          searchTerm
+        }
+      };
+    }
+    
+    return {
+      success: false,
+      error: data.error || 'Search failed'
+    };
+  } catch (error) {
+    console.error('Error searching catalog items:', error);
+    return {
+      success: false,
+      error: 'Search failed. Please try again.'
+    };
+  }
+};
+
+/**
+ * Fetch catalog item by hash
+ * @param {string} hash - Item hash
+ * @returns {Promise} - API response
+ */
+export const fetchItemById = async (hash) => {
+  try {
+    const response = await fetch(`/api/card-collection?action=get&hash=${hash}`);
+    const data = await response.json();
+    
+    if (data.success) {
+      const cardData = data.card;
+      
+      let description = 'Binary content';
+      const content = cardData.content;
+      
+      if (typeof content === 'string') {
+        description = content.substring(0, 200) + (content.length > 200 ? '...' : '');
+      } else if (content && typeof content === 'object') {
+        if (content.type === 'string') {
+          description = content.data.substring(0, 200) + (content.data.length > 200 ? '...' : '');
+        } else if (content.type === 'base64') {
+          description = `Binary content (${content.originalType || 'unknown type'})`;
+        }
+      }
+      
+      return {
+        success: true,
+        item: {
+          id: cardData.hash,
+          name: cardData.hash.substring(0, 8),
+          category: cardData.contentType?.mimeType || 'Unknown',
+          description,
+          hash: cardData.hash,
+          content: cardData.content,
+          timestamp: cardData.timestamp || new Date().toISOString(),
+          contentType: cardData.contentType
+        }
+      };
+    }
+    
+    return {
+      success: false,
+      error: data.error || 'Failed to fetch card'
+    };
+  } catch (error) {
+    console.error('Error fetching card by ID:', error);
+    return {
+      success: false,
+      error: 'Failed to fetch card. Please try again.'
+    };
+  }
+};
+
+/**
+ * Delete a catalog item
+ * @param {string} hash - Item hash
+ * @returns {Promise} - API response
+ */
+export const deleteItem = async (hash) => {
+  try {
+    const response = await fetch(`/api/card-collection?action=delete&hash=${hash}`, { 
+      method: 'DELETE' 
+    });
+    
+    const data = await response.json();
+    
+    return {
+      success: data.success,
+      error: data.success ? null : (data.error || 'Failed to delete item')
+    };
+  } catch (error) {
+    console.error('Error deleting catalog item:', error);
+    return {
+      success: false,
+      error: 'Failed to delete item. Please try again.'
+    };
+  }
+};
+
+/**
+ * Add a file to the catalog
+ * @param {Object} file - File to upload
+ * @param {Object} metadata - Metadata for the file
+ * @returns {Promise} - API response
+ */
+export const addFileItem = async (file, metadata) => {
+  try {
+    const formData = new FormData();
+    formData.append('file', file);
+    formData.append('metadata', JSON.stringify(metadata));
+    formData.append('action', 'add');
+    
+    const response = await fetch('/api/card-collection?action=add', {
+      method: 'POST',
+      body: formData
+    });
+    
+    if (!response.ok) {
+      const errorData = await response.json();
+      throw new Error(errorData.error || `Server responded with ${response.status}`);
+    }
+    
+    const data = await response.json();
+    
+    if (data.success) {
+      return {
+        success: true,
+        hash: data.hash
+      };
+    }
+    
+    return {
+      success: false,
+      error: data.error || 'Failed to add item'
+    };
+  } catch (error) {
+    console.error('Error adding file item:', error);
+    return {
+      success: false,
+      error: `Failed to add item: ${error.message}`
+    };
+  }
+};
+
+/**
+ * Add text content to the catalog
+ * @param {Object} content - Text content and metadata
+ * @returns {Promise} - API response
+ */
+export const addTextContent = async (content) => {
+  try {
+    const response = await fetch('/api/card-collection?action=add', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({
+        action: 'add',
+        card: {
+          content: content.text,
+          hash_algorithm: 'sha256'
+        }
+      })
+    });
+    
+    if (!response.ok) {
+      const errorData = await response.json();
+      throw new Error(errorData.error || `Server responded with ${response.status}`);
+    }
+    
+    const data = await response.json();
+    
+    if (data.success) {
+      return {
+        success: true,
+        hash: data.hash
+      };
+    }
+    
+    return {
+      success: false,
+      error: data.error || 'Failed to add item'
+    };
+  } catch (error) {
+    console.error('Error adding text content:', error);
+    return {
+      success: false,
+      error: `Failed to add item: ${error.message}`
+    };
+  }
+};
+
+/**
+ * Helper function to transform API response items into a consistent format
+ * @param {Object} data - API response data
+ * @returns {Array} - Transformed items
+ */
+const transformApiItems = (data) => {
+  let transformedItems = [];
+  
+  if (data.cards && Array.isArray(data.cards)) {
+    // Format from getPage endpoint
+    transformedItems = data.cards.map(card => ({
+      id: card.hash,
+      name: card.hash.substring(0, 8), // Use first 8 chars of hash as name
+      category: card.contentType?.mimeType || 'Unknown',
+      description: 'Card content hash: ' + card.hash,
+      timestamp: card.timestamp || new Date().toISOString(),
+      hash: card.hash,
+      contentType: card.contentType,
+      metaData: card.metaData || {}
+    }));
+  } else if (data.items && Array.isArray(data.items)) {
+    // Alternative format from list endpoint
+    transformedItems = data.items.map(item => ({
+      id: item.id || item.hash,
+      name: item.name || (item.hash ? item.hash.substring(0, 8) : 'Unknown'),
+      category: item.category || item.contentType?.mimeType || 'Unknown',
+      description: item.description || 'No description available',
+      timestamp: item.timestamp || new Date().toISOString(),
+      hash: item.hash || item.id,
+      contentType: item.contentType || { mimeType: 'text/plain' },
+      metaData: item.metaData || {}
+    }));
+  } else {
+    console.warn('Unexpected API response format:', data);
+  }
+  
+  return transformedItems;
+};
diff --git a/src/components/panels/catalog/components/PanelHeader.jsx b/src/components/panels/catalog/components/PanelHeader.jsx
new file mode 100644
index 0000000..072d943
--- /dev/null
+++ b/src/components/panels/catalog/components/PanelHeader.jsx
@@ -0,0 +1,115 @@
+import React, { useState } from 'react';
+
+/**
+ * PanelHeader component for the CatalogPanel
+ * Provides search, view mode toggles, and refresh functionality
+ */
+const PanelHeader = ({ 
+  viewMode, 
+  onViewModeChange, 
+  onRefresh,
+  onSearch,
+  onClearSearch,
+  isSearchMode,
+  categories,
+  filter,
+  onFilterChange
+}) => {
+  const [searchTerm, setSearchTerm] = useState('');
+
+  const handleSearchSubmit = (e) => {
+    e.preventDefault();
+    
+    if (!searchTerm.trim()) {
+      // Clear search if empty
+      onClearSearch();
+      return;
+    }
+    
+    onSearch(searchTerm);
+  };
+
+  return (
+    <>
+      <div className="panel-header">
+        <h2>Card Catalog</h2>
+        <div className="panel-controls">
+          <button 
+            className="btn-refresh" 
+            onClick={onRefresh}
+            title="Refresh catalog"
+          >
+            ‚Üª
+          </button>
+          <div className="view-toggles">
+            <button
+              className={`btn-toggle ${viewMode === 'list' ? 'active' : ''}`}
+              onClick={() => onViewModeChange('list')}
+            >
+              List
+            </button>
+            <button
+              className={`btn-toggle ${viewMode === 'grid' ? 'active' : ''}`}
+              onClick={() => onViewModeChange('grid')}
+            >
+              Grid
+            </button>
+          </div>
+          {['list', 'grid'].includes(viewMode) && (
+            <button
+              className="btn btn-primary"
+              onClick={() => onViewModeChange('add')}
+            >
+              Add New Item
+            </button>
+          )}
+        </div>
+      </div>
+      
+      {['list', 'grid'].includes(viewMode) && (
+        <div className="catalog-controls">
+          <form className="search-container" onSubmit={handleSearchSubmit}>
+            <input
+              type="text"
+              className="search-input"
+              placeholder="Search content..."
+              value={searchTerm}
+              onChange={(e) => setSearchTerm(e.target.value)}
+            />
+            <button type="submit" className="btn btn-info search-button">
+              Search
+            </button>
+            {isSearchMode && (
+              <button
+                type="button"
+                className="btn btn-secondary search-button"
+                onClick={() => {
+                  setSearchTerm('');
+                  onClearSearch();
+                }}
+              >
+                Clear
+              </button>
+            )}
+          </form>
+          
+          {!isSearchMode && (
+            <select 
+              className="filter-select"
+              value={filter}
+              onChange={(e) => onFilterChange(e.target.value)}
+            >
+              {categories.map(category => (
+                <option key={category} value={category}>
+                  {category === 'all' ? 'All Types' : category}
+                </option>
+              ))}
+            </select>
+          )}
+        </div>
+      )}
+    </>
+  );
+};
+
+export default PanelHeader;
diff --git a/src/components/panels/catalog/index.js b/src/components/panels/catalog/index.js
new file mode 100644
index 0000000..468506a
--- /dev/null
+++ b/src/components/panels/catalog/index.js
@@ -0,0 +1,3 @@
+import CatalogPanel from './CatalogPanel';
+
+export default CatalogPanel;
diff --git a/src/components/panels/catalog/utils/contentTypeUtils.js b/src/components/panels/catalog/utils/contentTypeUtils.js
new file mode 100644
index 0000000..806ba1f
--- /dev/null
+++ b/src/components/panels/catalog/utils/contentTypeUtils.js
@@ -0,0 +1,74 @@
+/**
+ * Utility functions for content type handling in the catalog panel
+ */
+
+/**
+ * Extract a simple content type from MIME type for display purposes
+ * @param {string} mimeType - The MIME type (e.g., 'text/plain', 'image/jpeg')
+ * @returns {string|null} - Simple type string or null if invalid
+ */
+export const getSimpleContentType = (mimeType) => {
+  if (!mimeType) return null;
+  
+  // Extract the subtype from the MIME type
+  const parts = mimeType.split('/');
+  if (parts.length < 2) return null;
+  
+  const subtype = parts[1];
+  
+  // Handle special cases
+  if (subtype.includes('json')) return 'json';
+  if (subtype.includes('javascript')) return 'js';
+  if (subtype === 'plain') return 'txt';
+  if (subtype === 'html') return 'html';
+  if (subtype === 'css') return 'css';
+  if (subtype === 'svg+xml') return 'svg';
+  
+  // Return the subtype as-is for common formats (gif, png, jpg, etc.)
+  return subtype;
+};
+
+/**
+ * Get a display label for a content type
+ * @param {object} contentType - Content type object with mimeType property
+ * @returns {string} - Formatted display string 
+ */
+export const getContentTypeDisplay = (contentType) => {
+  if (!contentType || !contentType.mimeType) return 'Unknown';
+  
+  const simpleType = getSimpleContentType(contentType.mimeType);
+  return `${simpleType || contentType.mimeType} (${contentType.mimeType})`;
+};
+
+/**
+ * Default content types used in the app
+ */
+export const DEFAULT_CONTENT_TYPES = {
+  TEXT: 'text/plain',
+  JSON: 'application/json',
+  BINARY: 'application/octet-stream',
+  HTML: 'text/html',
+  CSV: 'text/csv'
+};
+
+/**
+ * Get content type icon or display names for different formats
+ */
+export const contentTypeDisplayMap = {
+  'json': 'JSON',
+  'txt': 'TXT',
+  'csv': 'CSV',
+  'pdf': 'PDF',
+  'mp3': 'üéµ Audio',
+  'wav': 'üéµ Audio', 
+  'mp4': 'üé¨ Video',
+  'png': 'üñºÔ∏è Image',
+  'jpg': 'üñºÔ∏è Image',
+  'jpeg': 'üñºÔ∏è Image',
+  'gif': 'üñºÔ∏è Image',
+  'js': 'JS',
+  'html': 'HTML',
+  'xml': 'XML',
+  'css': 'CSS',
+  'svg': 'SVG'
+};
diff --git a/src/components/panels/catalog/views/AddItemForm.jsx b/src/components/panels/catalog/views/AddItemForm.jsx
new file mode 100644
index 0000000..404f490
--- /dev/null
+++ b/src/components/panels/catalog/views/AddItemForm.jsx
@@ -0,0 +1,190 @@
+import React, { useRef, useState } from 'react';
+import { DEFAULT_CONTENT_TYPES } from '../utils/contentTypeUtils';
+
+/**
+ * AddItemForm component for adding new items to the catalog
+ */
+const AddItemForm = ({ onSubmit, onCancel, isLoading, error }) => {
+  const [isDragging, setIsDragging] = useState(false);
+  const dropZoneRef = useRef(null);
+
+  // Form state
+  const [formData, setFormData] = useState({
+    name: '',
+    description: '',
+    contentType: DEFAULT_CONTENT_TYPES.TEXT,
+    file: null
+  });
+
+  // Handle form input changes
+  const handleInputChange = (e) => {
+    const { name, value } = e.target;
+    setFormData({
+      ...formData,
+      [name]: value
+    });
+  };
+
+  // Handle file input change
+  const handleFileChange = (e) => {
+    const file = e.target.files[0];
+    if (file) {
+      setFormData({
+        ...formData,
+        name: file.name,
+        contentType: file.type || DEFAULT_CONTENT_TYPES.BINARY,
+        file: file
+      });
+    }
+  };
+
+  // Handle form submission
+  const handleSubmit = (e) => {
+    e.preventDefault();
+    
+    if (!formData.name) {
+      alert('Please provide a name for the new item');
+      return;
+    }
+    
+    onSubmit(formData);
+  };
+
+  // Drag and drop handlers
+  const handleDragEnter = (e) => {
+    e.preventDefault();
+    e.stopPropagation();
+    setIsDragging(true);
+  };
+
+  const handleDragOver = (e) => {
+    e.preventDefault();
+    e.stopPropagation();
+    if (!isDragging) {
+      setIsDragging(true);
+    }
+  };
+
+  const handleDragLeave = (e) => {
+    e.preventDefault();
+    e.stopPropagation();
+    
+    // Only set dragging to false if leaving the drop zone itself, not its children
+    if (dropZoneRef.current && !dropZoneRef.current.contains(e.relatedTarget)) {
+      setIsDragging(false);
+    }
+  };
+
+  const handleDrop = (e) => {
+    e.preventDefault();
+    e.stopPropagation();
+    setIsDragging(false);
+    
+    const files = e.dataTransfer.files;
+    if (files && files.length > 0) {
+      const file = files[0]; // Take only the first file if multiple are dropped
+      setFormData({
+        ...formData,
+        name: file.name,
+        contentType: file.type || DEFAULT_CONTENT_TYPES.BINARY,
+        file: file
+      });
+    }
+  };
+
+  // Clear file selection
+  const handleClearFile = () => {
+    setFormData({
+      ...formData,
+      file: null
+    });
+  };
+
+  return (
+    <form onSubmit={handleSubmit} className="catalog-form">
+      {error && <div className="form-error">{error}</div>}
+      
+      <div className="form-group">
+        <label htmlFor="name">Name</label>
+        <input
+          type="text"
+          id="name"
+          name="name"
+          value={formData.name}
+          onChange={handleInputChange}
+          placeholder="Item name (optional for text content)"
+        />
+      </div>
+      
+      <div 
+        className={`form-group drop-zone ${isDragging ? 'dropping' : ''}`}
+        ref={dropZoneRef}
+        onDragEnter={handleDragEnter}
+        onDragOver={handleDragOver}
+        onDragLeave={handleDragLeave}
+        onDrop={handleDrop}
+      >
+        <label htmlFor="file">
+          {isDragging 
+            ? "Drop file here" 
+            : (formData.file 
+              ? `Selected: ${formData.file.name}` 
+              : "Drag & drop a file here, or click to browse")}
+        </label>
+        <input
+          type="file"
+          id="file"
+          onChange={handleFileChange}
+          style={{ opacity: formData.file ? 0 : 0.01 }}
+        />
+        {!formData.file && <div className="drop-icon">üìÅ</div>}
+        {formData.file && (
+          <div className="file-info">
+            <span className="file-name">{formData.file.name}</span>
+            <span className="file-size">({Math.round(formData.file.size / 1024)} KB)</span>
+            <button 
+              type="button" 
+              className="btn-clear-file"
+              onClick={handleClearFile}
+            >
+              ‚úï
+            </button>
+          </div>
+        )}
+      </div>
+      
+      <div className="form-group">
+        <label htmlFor="description">Text Content (if not uploading a file)</label>
+        <textarea
+          id="description"
+          name="description"
+          value={formData.description}
+          onChange={handleInputChange}
+          rows="6"
+          placeholder="Enter text content here"
+          disabled={!!formData.file}
+        />
+      </div>
+      
+      <div className="form-actions">
+        <button 
+          type="submit" 
+          className="btn btn-primary"
+          disabled={isLoading}
+        >
+          {isLoading ? 'Uploading...' : (formData.file ? 'Upload File' : 'Add Content')}
+        </button>
+        <button 
+          type="button" 
+          className="btn btn-secondary" 
+          onClick={onCancel}
+          disabled={isLoading}
+        >
+          Cancel
+        </button>
+      </div>
+    </form>
+  );
+};
+
+export default AddItemForm;
diff --git a/src/components/panels/catalog/views/DetailView.jsx b/src/components/panels/catalog/views/DetailView.jsx
new file mode 100644
index 0000000..3cf12cc
--- /dev/null
+++ b/src/components/panels/catalog/views/DetailView.jsx
@@ -0,0 +1,293 @@
+import React, { useState } from 'react';
+import { getSimpleContentType } from '../utils/contentTypeUtils';
+
+/**
+ * DetailView component for displaying detailed information about a catalog item
+ */
+const DetailView = ({ 
+  item, 
+  isLoading, 
+  error, 
+  onBack, 
+  onDelete 
+}) => {
+  const [wordWrap, setWordWrap] = useState(true);
+
+  if (isLoading) {
+    return <div className="loading-indicator">Loading item details...</div>;
+  }
+
+  if (error) {
+    return <div className="error-message">Error: {error}</div>;
+  }
+
+  if (!item) {
+    return <div className="error-message">Item not found</div>;
+  }
+  
+  // Universal content wrapper to enforce containment
+  const ContentWrapper = ({ children, className = '' }) => (
+    <div className={`universal-content-wrapper ${className}`}>
+      {children}
+    </div>
+  );
+  
+  // Process and display content based on type
+  const renderContent = () => {
+    if (!item?.content) {
+      return <div className="empty-content">No content available</div>;
+    }
+    
+    const contentType = item.contentType || { mimeType: 'text/plain' };
+    
+    // Handle different content types
+    if (contentType.mimeType?.startsWith('image/')) {
+      return (
+        <ContentWrapper className="image-wrapper">
+          <img src={`data:${contentType.mimeType};base64,${item.content}`} alt="Content Preview" className="content-image" />
+        </ContentWrapper>
+      );
+    } else if (contentType.mimeType === 'application/pdf') {
+      return (
+        <ContentWrapper className="pdf-wrapper">
+          <div className="pdf-container">
+            <iframe src={`data:${contentType.mimeType};base64,${item.content}`} className="pdf-frame" title="PDF Viewer"></iframe>
+          </div>
+        </ContentWrapper>
+      );
+    } else if (contentType.mimeType?.startsWith('audio/')) {
+      return (
+        <ContentWrapper className="audio-wrapper">
+          <audio controls className="content-audio">
+            <source src={`data:${contentType.mimeType};base64,${item.content}`} type={contentType.mimeType} />
+            Your browser does not support the audio element.
+          </audio>
+        </ContentWrapper>
+      );
+    } else if (contentType.mimeType?.startsWith('video/')) {
+      return (
+        <ContentWrapper className="video-wrapper">
+          <video controls className="content-video">
+            <source src={`data:${contentType.mimeType};base64,${item.content}`} type={contentType.mimeType} />
+            Your browser does not support the video element.
+          </video>
+        </ContentWrapper>
+      );
+    } else if (contentType.mimeType === 'text/html') {
+      return (
+        <ContentWrapper className="html-wrapper">
+          <div className="html-content" dangerouslySetInnerHTML={{ __html: item.content }}></div>
+        </ContentWrapper>
+      );
+    } else if (contentType.mimeType === 'application/json' || 
+               (typeof item.content === 'string' && item.content.trim().startsWith('{'))) {
+      // Parse JSON if it's not already an object
+      let jsonContent;
+      try {
+        jsonContent = typeof item.content === 'string' 
+          ? JSON.parse(item.content) 
+          : item.content;
+      } catch (e) {
+        console.error('Error parsing JSON:', e);
+        return (
+          <ContentWrapper className="text-wrapper">
+            <pre className="content-text">
+              {typeof item.content === 'string' 
+                ? item.content 
+                : JSON.stringify(item.content, null, 2)}
+            </pre>
+          </ContentWrapper>
+        );
+      }
+      
+      return (
+        <ContentWrapper className="json-wrapper">
+          {renderJsonWithHighlighting(jsonContent)}
+        </ContentWrapper>
+      );
+    } else if (contentType.mimeType === 'text/csv' || contentType.extension === 'csv') {
+      return (
+        <ContentWrapper className="csv-wrapper">
+          <div className="csv-content">
+            <table className="csv-table">
+              <tbody>
+                {typeof item.content === 'string' && 
+                  item.content.split('\n').map((row, rowIndex) => (
+                    <tr key={rowIndex}>
+                      {row.split(',').map((cell, cellIndex) => (
+                        <td key={cellIndex} className="csv-cell">
+                          {cell.length > 50 ? cell.substring(0, 47) + '...' : cell}
+                        </td>
+                      ))}
+                    </tr>
+                  ))}
+              </tbody>
+            </table>
+          </div>
+        </ContentWrapper>
+      );
+    } else {
+      // Default text display
+      return (
+        <ContentWrapper className="text-wrapper">
+          <div className="content-controls">
+            <div className="text-content-options">
+              <label>
+                <input 
+                  type="checkbox" 
+                  checked={!wordWrap} 
+                  onChange={() => setWordWrap(!wordWrap)} 
+                />
+                Disable word wrap
+              </label>
+            </div>
+            <pre className={`content-text ${!wordWrap ? 'wrap-text' : 'nowrap-text'}`}>
+              {typeof item.content === 'string' 
+                ? item.content 
+                : JSON.stringify(item.content, null, 2)}
+            </pre>
+          </div>
+        </ContentWrapper>
+      );
+    }
+  };
+
+  // Helper function to render JSON with syntax highlighting and guaranteed wrapping
+  const renderJsonWithHighlighting = (jsonObj) => {
+    // Convert JSON to a vertical display format that won't overflow
+    const renderJsonAsTable = (obj, depth = 0) => {
+      // For primitive values, just return them formatted
+      if (typeof obj !== 'object' || obj === null) {
+        return renderPrimitiveValue(obj);
+      }
+      
+      // Recursive table builder
+      const rows = [];
+      
+      // Handle arrays or objects
+      const isArray = Array.isArray(obj);
+      
+      // For each key/index in the object/array
+      Object.entries(obj).forEach(([key, value], index) => {
+        // Create indentation based on depth
+        const indent = '  '.repeat(depth);
+        const displayKey = isArray ? `[${key}]` : key;
+        
+        // If value is an object, recurse, otherwise format the primitive
+        if (typeof value === 'object' && value !== null) {
+          // For objects/arrays, create a row with the key and a placeholder
+          rows.push(
+            `<tr>
+              <td class="json-key-cell">${indent}${displayKey}:</td>
+              <td class="json-value-cell">${isArray ? '[]' : '{'}...</td>
+            </tr>`
+          );
+          
+          // Add the nested object as indented rows
+          rows.push(renderJsonAsTable(value, depth + 1));
+          
+          // Close the object
+          rows.push(
+            `<tr>
+              <td class="json-key-cell">${indent}</td>
+              <td class="json-value-cell">${isArray ? ']' : '}'}</td>
+            </tr>`
+          );
+        } else {
+          // For primitive values, just add a row with the key and value
+          rows.push(
+            `<tr>
+              <td class="json-key-cell">${indent}${displayKey}:</td>
+              <td class="json-value-cell">${renderPrimitiveValue(value)}</td>
+            </tr>`
+          );
+        }
+      });
+      
+      return rows.join('');
+    };
+    
+    // Helper to format primitive values with truncation and highlighting
+    const renderPrimitiveValue = (value) => {
+      // Format and truncate based on type
+      if (typeof value === 'string') {
+        // Truncate long strings
+        const displayValue = value.length > 30 
+          ? `"${value.substring(0, 30)}..."` 
+          : `"${value}"`;
+        return `<span class="json-string">${displayValue}</span>`;
+      } else if (typeof value === 'number') {
+        return `<span class="json-number">${value}</span>`;
+      } else if (typeof value === 'boolean') {
+        return `<span class="json-boolean">${value}</span>`;
+      } else if (value === null) {
+        return `<span class="json-null">null</span>`;
+      } else {
+        return `<span>${String(value)}</span>`;
+      }
+    };
+    
+    // Create the table HTML
+    const tableHtml = `
+      <table class="json-table">
+        <tbody>
+          ${renderJsonAsTable(jsonObj)}
+        </tbody>
+      </table>
+    `;
+    
+    // Return the HTML table with inline styles for containment
+    return (
+      <div 
+        className="content-json-container" 
+        dangerouslySetInnerHTML={{ __html: tableHtml }}
+      />
+    );
+  };
+
+  return (
+    <div className="catalog-detail-view">
+      <div className="catalog-detail-header">
+        <button 
+          className="btn btn-back"
+          onClick={onBack}
+        >
+          Back
+        </button>
+        <h2>{item.name}</h2>
+      </div>
+      
+      <div className="catalog-detail-content">
+        <div className="catalog-detail-info">
+          <div className="info-section">
+            <p><strong>Hash:</strong> {item.hash}</p>
+            <p><strong>Type:</strong> {
+              item.contentType?.mimeType 
+                ? `${getSimpleContentType(item.contentType.mimeType) || item.contentType.mimeType} (${item.contentType.mimeType})` 
+                : 'Unknown'
+            }</p>
+            <p><strong>gtime:</strong> {new Date(item.timestamp).toLocaleString()}</p>
+          </div>
+          
+          <div className="content-section">
+            <h3>Content</h3>
+            <div className="content-container">
+              {renderContent()}
+            </div>
+          </div>
+          
+          <div className="catalog-detail-actions">
+            <button 
+              className="btn btn-danger"
+              onClick={() => onDelete(item.hash)}
+            >
+              Delete
+            </button>
+          </div>
+        </div>
+      </div>
+    </div>
+  );
+};
+
+export default DetailView;
diff --git a/src/components/panels/catalog/views/GridView.jsx b/src/components/panels/catalog/views/GridView.jsx
new file mode 100644
index 0000000..b9fa2e8
--- /dev/null
+++ b/src/components/panels/catalog/views/GridView.jsx
@@ -0,0 +1,142 @@
+import React from 'react';
+import { getSimpleContentType, contentTypeDisplayMap } from '../utils/contentTypeUtils';
+
+/**
+ * GridView component for displaying catalog items in a grid layout
+ */
+const GridView = ({ 
+  items, 
+  isLoading, 
+  error,
+  pagination, 
+  onSelectItem, 
+  onDeleteItem,
+  onPageChange,
+  isSearchMode,
+  searchTerm,
+  searchError
+}) => {
+  if (isLoading) {
+    return <div className="loading-indicator">Loading items...</div>;
+  }
+
+  if (error) {
+    return <div className="error-message">Error: {error}</div>;
+  }
+
+  if (searchError) {
+    return <div className="error-message">Search error: {searchError}</div>;
+  }
+
+  if (items.length === 0) {
+    return (
+      <div className="empty-state">
+        {isSearchMode 
+          ? <p>No results found for "{searchTerm}"</p>
+          : <p>No items available. Add your first item to get started.</p>
+        }
+      </div>
+    );
+  }
+
+  // Get thumbnail for different content types
+  const getCardThumbnail = (item) => {
+    const contentType = item.contentType?.mimeType || 'unknown';
+    const simpleType = getSimpleContentType(contentType);
+    
+    // Image thumbnails for image types
+    if (contentType.startsWith('image/')) {
+      return (
+        <img 
+          src={`/api/card-collection?action=get&hash=${item.id}`} 
+          alt={item.name} 
+          onError={(e) => {
+            e.target.onerror = null;
+            e.target.src = "https://placehold.co/300x300?text=No+Preview";
+          }}
+        />
+      );
+    }
+    
+    // Icons or placeholders for other content types
+    const displayType = simpleType && contentTypeDisplayMap[simpleType] 
+      ? contentTypeDisplayMap[simpleType]
+      : contentType || 'Unknown';
+    
+    return (
+      <div className="image-placeholder">
+        {displayType}
+      </div>
+    );
+  };
+
+  return (
+    <>
+      <div className="catalog-grid-view">
+        {items.map(item => (
+          <div key={item.id} className="grid-item">
+            <div 
+              className="grid-item-card" 
+              onClick={() => onSelectItem(item)}
+            >
+              <div className="grid-item-thumbnail">
+                {getCardThumbnail(item)}
+              </div>
+              <div className="grid-item-info">
+                <h3 className="grid-item-title">{item.name}</h3>
+                <div className="grid-item-meta">
+                  <span className="grid-item-type">
+                    {item.contentType?.mimeType 
+                      ? getSimpleContentType(item.contentType.mimeType) || item.contentType.mimeType 
+                      : 'Unknown'}
+                  </span>
+                  <span className="grid-item-date">
+                    {new Date(item.timestamp).toLocaleDateString()}
+                  </span>
+                </div>
+                <p className="grid-item-description">{item.description}</p>
+              </div>
+              <div className="grid-item-actions">
+                <button 
+                  className="btn btn-small btn-danger"
+                  onClick={(e) => {
+                    e.stopPropagation();
+                    onDeleteItem(item.id);
+                  }}
+                >
+                  Delete
+                </button>
+              </div>
+            </div>
+          </div>
+        ))}
+      </div>
+      
+      {/* Pagination */}
+      {pagination.totalPages > 1 && (
+        <div className="pagination-controls">
+          <button 
+            className="btn btn-pagination" 
+            disabled={pagination.currentPage <= 1}
+            onClick={() => onPageChange(pagination.currentPage - 1)}
+          >
+            Previous
+          </button>
+          <span className="pagination-info">
+            Page {pagination.currentPage} of {pagination.totalPages}
+            {pagination.totalItems && ` (${pagination.totalItems} total items)`}
+          </span>
+          <button 
+            className="btn btn-pagination" 
+            disabled={pagination.currentPage >= pagination.totalPages}
+            onClick={() => onPageChange(pagination.currentPage + 1)}
+          >
+            Next
+          </button>
+        </div>
+      )}
+    </>
+  );
+};
+
+export default GridView;
diff --git a/src/components/panels/catalog/views/ListView.jsx b/src/components/panels/catalog/views/ListView.jsx
new file mode 100644
index 0000000..c74b29b
--- /dev/null
+++ b/src/components/panels/catalog/views/ListView.jsx
@@ -0,0 +1,148 @@
+import React from 'react';
+import { getSimpleContentType, contentTypeDisplayMap } from '../utils/contentTypeUtils';
+
+/**
+ * ListView component for displaying catalog items in a card-based list format
+ */
+const ListView = ({ 
+  items, 
+  isLoading, 
+  error,
+  pagination, 
+  onSelectItem, 
+  onDeleteItem,
+  onPageChange,
+  isSearchMode,
+  searchTerm,
+  searchError
+}) => {
+  if (isLoading) {
+    return <div className="loading-indicator">Loading items...</div>;
+  }
+
+  if (error) {
+    return <div className="error-message">Error: {error}</div>;
+  }
+
+  if (searchError) {
+    return <div className="error-message">Search error: {searchError}</div>;
+  }
+
+  if (items.length === 0) {
+    return (
+      <div className="empty-state">
+        {isSearchMode 
+          ? <p>No results found for "{searchTerm}"</p>
+          : <p>No items available. Add your first item to get started.</p>
+        }
+      </div>
+    );
+  }
+
+  // Get thumbnail for different content types
+  const getCardThumbnail = (item) => {
+    const contentType = item.contentType?.mimeType || 'unknown';
+    const simpleType = getSimpleContentType(contentType);
+    
+    // Image thumbnails for image types
+    if (contentType.startsWith('image/')) {
+      return (
+        <img 
+          src={`/api/card-collection?action=get&hash=${item.id}`} 
+          alt={item.name} 
+          onError={(e) => {
+            e.target.onerror = null;
+            e.target.src = "https://placehold.co/300x300?text=No+Preview";
+          }}
+        />
+      );
+    }
+    
+    // Icons or placeholders for other content types
+    const displayType = simpleType && contentTypeDisplayMap[simpleType] 
+      ? contentTypeDisplayMap[simpleType]
+      : contentType || 'Unknown';
+    
+    return (
+      <div className="image-placeholder">
+        {displayType}
+      </div>
+    );
+  };
+
+  return (
+    <>
+      <div className="catalog-list-cards">
+        {items.map(item => (
+          <div key={item.id} className="list-card">
+            <div className="list-card-inner" onClick={() => onSelectItem(item)}>
+              <div className="list-card-thumbnail">
+                {getCardThumbnail(item)}
+              </div>
+              <div className="list-card-content">
+                <h3 className="list-card-title">{item.name}</h3>
+                <div className="list-card-meta">
+                  <span className="list-card-type">
+                    {item.contentType?.mimeType 
+                      ? getSimpleContentType(item.contentType.mimeType) || item.contentType.mimeType 
+                      : 'Unknown'}
+                  </span>
+                  <span className="list-card-date">
+                    {new Date(item.timestamp).toLocaleString()}
+                  </span>
+                </div>
+                <p className="list-card-description">{item.description}</p>
+              </div>
+              <div className="list-card-actions">
+                <button 
+                  className="btn btn-small btn-info"
+                  onClick={(e) => {
+                    e.stopPropagation();
+                    onSelectItem(item);
+                  }}
+                >
+                  View
+                </button>
+                <button 
+                  className="btn btn-small btn-danger"
+                  onClick={(e) => {
+                    e.stopPropagation();
+                    onDeleteItem(item.id);
+                  }}
+                >
+                  Delete
+                </button>
+              </div>
+            </div>
+          </div>
+        ))}
+      </div>
+      
+      {/* Pagination */}
+      {pagination.totalPages > 1 && (
+        <div className="pagination-controls">
+          <button 
+            className="btn btn-pagination" 
+            disabled={pagination.currentPage <= 1}
+            onClick={() => onPageChange(pagination.currentPage - 1)}
+          >
+            Previous
+          </button>
+          <span className="pagination-info">
+            Page {pagination.currentPage} of {pagination.totalPages}
+            {pagination.totalItems && ` (${pagination.totalItems} total items)`}
+          </span>
+          <button 
+            className="btn btn-pagination" 
+            disabled={pagination.currentPage >= pagination.totalPages}
+            onClick={() => onPageChange(pagination.currentPage + 1)}
+          >
+            Next
+          </button>
+        </div>
+      )}
+    </>
+  );
+};
+
+export default ListView;

commit 78b7feb1a2fba9bb7c160e2b854c702db667b398
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Tue Apr 8 19:43:22 2025 +0800

    better catalog

diff --git a/Docs/to-do-plan b/Docs/to-do-plan
index eaf55c7..261858e 160000
--- a/Docs/to-do-plan
+++ b/Docs/to-do-plan
@@ -1 +1 @@
-Subproject commit eaf55c718cbe1659d74f6647624de327d2a793b8
+Subproject commit 261858e11e6d1f9258f2fdd4ed37fd9591946075
diff --git a/src/components/panels/CatalogPanel.jsx b/src/components/panels/CatalogPanel.jsx
index bb65280..fdfadec 100644
--- a/src/components/panels/CatalogPanel.jsx
+++ b/src/components/panels/CatalogPanel.jsx
@@ -1,4 +1,4 @@
-import React, { useState, useEffect } from 'react';
+import React, { useState, useEffect, useRef } from 'react';
 import { useDispatch } from 'react-redux';
 import { importCardFromDatabase, selectContent } from '../../features/contentSlice';
 import { selectItem } from '../../features/selectedItemSlice';
@@ -54,6 +54,10 @@ const CatalogPanel = () => {
     file: null
   });
   
+  // Drag and drop states
+  const [isDragging, setIsDragging] = useState(false);
+  const dropZoneRef = useRef(null);
+  
   // Category list derived from items
   const [categories, setCategories] = useState(['all']);
 
@@ -100,8 +104,8 @@ const CatalogPanel = () => {
     }
   }, [items]);
 
-  // Initial fetch on component mount
-  useEffect(() => {
+  // Fetch catalog items
+  const fetchCatalogItems = () => {
     setLoading(true);
     setError(null);
     
@@ -159,6 +163,30 @@ const CatalogPanel = () => {
       .finally(() => {
         setLoading(false);
       });
+  };
+
+  // Handle refresh button click
+  const handleRefresh = () => {
+    // Clear search if in search mode
+    if (isSearchMode) {
+      setIsSearchMode(false);
+      setSearchResults({
+        items: [],
+        currentPage: 1,
+        totalPages: 1,
+        totalItems: 0,
+        searchTerm: ''
+      });
+      setSearchTerm('');
+    }
+    
+    // Fetch items again
+    fetchCatalogItems();
+  };
+
+  // Initial fetch on component mount
+  useEffect(() => {
+    fetchCatalogItems();
   }, []);
 
   // Helper function to extract a simple content type from MIME type
@@ -494,8 +522,19 @@ const CatalogPanel = () => {
       // File upload
       const formData = new FormData();
       formData.append('file', newItem.file);
-      formData.append('name', newItem.name);
-      formData.append('description', newItem.description || '');
+      
+      // Create the metadata object as required by the API
+      const metadata = {
+        fileName: newItem.name,
+        mimeType: newItem.contentType || 'application/octet-stream',
+        size: newItem.file.size,
+        description: newItem.description || ''
+      };
+      
+      // Append metadata as a JSON string
+      formData.append('metadata', JSON.stringify(metadata));
+      // Append action to formData (since it's multipart form)
+      formData.append('action', 'add');
       
       setLoading(true);
       setError(null);
@@ -504,7 +543,14 @@ const CatalogPanel = () => {
         method: 'POST',
         body: formData
       })
-        .then(response => response.json())
+        .then(response => {
+          if (!response.ok) {
+            return response.json().then(data => {
+              throw new Error(data.error || `Server responded with ${response.status}`);
+            });
+          }
+          return response.json();
+        })
         .then(data => {
           if (data.success) {
             // Add new item to the state
@@ -535,7 +581,7 @@ const CatalogPanel = () => {
         })
         .catch(error => {
           console.error('Error adding catalog item:', error);
-          setError('Failed to add item. Please try again.');
+          setError(`Failed to add item: ${error.message}`);
         })
         .finally(() => {
           setLoading(false);
@@ -549,12 +595,21 @@ const CatalogPanel = () => {
         method: 'POST',
         headers: { 'Content-Type': 'application/json' },
         body: JSON.stringify({
-          name: newItem.name,
-          content: newItem.description,
-          contentType: { mimeType: newItem.contentType || 'text/plain' }
+          action: 'add',
+          card: {
+            content: newItem.description,
+            hash_algorithm: 'sha256'
+          }
         })
       })
-        .then(response => response.json())
+        .then(response => {
+          if (!response.ok) {
+            return response.json().then(data => {
+              throw new Error(data.error || `Server responded with ${response.status}`);
+            });
+          }
+          return response.json();
+        })
         .then(data => {
           if (data.success) {
             // Add new item to state
@@ -584,7 +639,7 @@ const CatalogPanel = () => {
         })
         .catch(error => {
           console.error('Error adding catalog item:', error);
-          setError('Failed to add item. Please try again.');
+          setError(`Failed to add item: ${error.message}`);
         })
         .finally(() => {
           setLoading(false);
@@ -621,6 +676,54 @@ const CatalogPanel = () => {
     }
   };
 
+  // Drag and drop handlers
+  const handleDragEnter = (e) => {
+    e.preventDefault();
+    e.stopPropagation();
+    setIsDragging(true);
+  };
+
+  const handleDragOver = (e) => {
+    e.preventDefault();
+    e.stopPropagation();
+    if (!isDragging) {
+      setIsDragging(true);
+    }
+  };
+
+  const handleDragLeave = (e) => {
+    e.preventDefault();
+    e.stopPropagation();
+    
+    // Only set dragging to false if leaving the drop zone itself, not its children
+    if (dropZoneRef.current && !dropZoneRef.current.contains(e.relatedTarget)) {
+      setIsDragging(false);
+    }
+  };
+
+  const handleDrop = (e) => {
+    e.preventDefault();
+    e.stopPropagation();
+    setIsDragging(false);
+    
+    const files = e.dataTransfer.files;
+    if (files && files.length > 0) {
+      const file = files[0]; // Take only the first file if multiple are dropped
+      setFileInput(file);
+      setNewItem({
+        ...newItem,
+        name: file.name,
+        contentType: file.type || 'application/octet-stream',
+        file: file
+      });
+      
+      // If not in the add view mode, switch to it
+      if (viewMode !== 'add') {
+        setViewMode('add');
+      }
+    }
+  };
+
   // Handle form input changes
   const handleInputChange = (e) => {
     const { name, value } = e.target;
@@ -889,149 +992,131 @@ const CatalogPanel = () => {
       return <div className="error-message">Item not found</div>;
     }
     
-    // Determine content display method based on content type
+    // Process and display content based on type
     const renderContent = () => {
-      // If content is not loaded yet
-      if (!selectedItem.content) {
-        return <div className="content-placeholder">Content not available</div>;
+      if (!selectedItem?.content) {
+        return <div className="empty-content">No content available</div>;
       }
       
-      const content = selectedItem.content;
-      const contentType = selectedItem.contentType?.mimeType || 'text/plain';
-      const simpleType = getSimpleContentType(contentType);
+      const contentType = selectedItem.contentType || { mimeType: 'text/plain' };
       
-      // Handle string content directly
-      if (typeof content === 'string') {
-        // JSON formatting
-        if (simpleType === 'json') {
-          try {
-            const json = JSON.parse(content);
-            return (
-              <pre className="content-json">
-                {JSON.stringify(json, null, 2)}
-              </pre>
-            );
-          } catch (e) {
-            // If parsing fails, display as plain text
-            console.error("Failed to parse JSON:", e);
-          }
-        }
-        
-        // HTML content
-        if (simpleType === 'html') {
-          return (
-            <div className="html-content">
-              <div dangerouslySetInnerHTML={{ __html: content }} />
+      // Universal content wrapper to enforce containment
+      const ContentWrapper = ({ children, className = '' }) => (
+        <div className={`universal-content-wrapper ${className}`}>
+          {children}
+        </div>
+      );
+      
+      // Handle different content types
+      if (contentType.mimeType?.startsWith('image/')) {
+        return (
+          <ContentWrapper className="image-wrapper">
+            <img src={`data:${contentType.mimeType};base64,${selectedItem.content}`} alt="Content Preview" className="content-image" />
+          </ContentWrapper>
+        );
+      } else if (contentType.mimeType === 'application/pdf') {
+        return (
+          <ContentWrapper className="pdf-wrapper">
+            <div className="pdf-container">
+              <iframe src={`data:${contentType.mimeType};base64,${selectedItem.content}`} className="pdf-frame" title="PDF Viewer"></iframe>
             </div>
-          );
-        }
-        
-        // Default text display
+          </ContentWrapper>
+        );
+      } else if (contentType.mimeType?.startsWith('audio/')) {
         return (
-          <pre className="content-text">
-            {content}
-          </pre>
+          <ContentWrapper className="audio-wrapper">
+            <audio controls className="content-audio">
+              <source src={`data:${contentType.mimeType};base64,${selectedItem.content}`} type={contentType.mimeType} />
+              Your browser does not support the audio element.
+            </audio>
+          </ContentWrapper>
         );
-      }
-      
-      // Handle base64 object format from the API
-      if (typeof content === 'object' && content !== null) {
-        // String data inside an object wrapper
-        if (content.type === 'string' && content.data) {
+      } else if (contentType.mimeType?.startsWith('video/')) {
+        return (
+          <ContentWrapper className="video-wrapper">
+            <video controls className="content-video">
+              <source src={`data:${contentType.mimeType};base64,${selectedItem.content}`} type={contentType.mimeType} />
+              Your browser does not support the video element.
+            </video>
+          </ContentWrapper>
+        );
+      } else if (contentType.mimeType === 'text/html') {
+        return (
+          <ContentWrapper className="html-wrapper">
+            <div className="html-content" dangerouslySetInnerHTML={{ __html: selectedItem.content }}></div>
+          </ContentWrapper>
+        );
+      } else if (contentType.mimeType === 'application/json' || 
+                 (typeof selectedItem.content === 'string' && selectedItem.content.trim().startsWith('{'))) {
+        // Parse JSON if it's not already an object
+        let jsonContent;
+        try {
+          jsonContent = typeof selectedItem.content === 'string' 
+            ? JSON.parse(selectedItem.content) 
+            : selectedItem.content;
+        } catch (e) {
+          console.error('Error parsing JSON:', e);
           return (
-            <pre className="content-text">
-              {content.data}
-            </pre>
+            <ContentWrapper className="text-wrapper">
+              <pre className="content-text">
+                {typeof selectedItem.content === 'string' 
+                  ? selectedItem.content 
+                  : JSON.stringify(selectedItem.content, null, 2)}
+              </pre>
+            </ContentWrapper>
           );
         }
         
-        // Base64 encoded content
-        if (content.type === 'base64' && content.data) {
-          const mimeType = content.originalType || contentType;
-          const simpleMimeType = getSimpleContentType(mimeType);
-          
-          // Images
-          if (mimeType.startsWith('image/')) {
-            return (
-              <img 
-                src={`data:${mimeType};base64,${content.data}`} 
-                alt={selectedItem.name}
-                className="content-image"
-              />
-            );
-          }
-          
-          // Audio
-          if (mimeType.startsWith('audio/')) {
-            return (
-              <audio controls className="content-audio">
-                <source src={`data:${mimeType};base64,${content.data}`} type={mimeType} />
-                Your browser does not support the audio element.
-              </audio>
-            );
-          }
-          
-          // Video
-          if (mimeType.startsWith('video/')) {
-            return (
-              <video controls className="content-video">
-                <source src={`data:${mimeType};base64,${content.data}`} type={mimeType} />
-                Your browser does not support the video element.
-              </video>
-            );
-          }
-          
-          // PDF
-          if (mimeType === 'application/pdf') {
-            return (
-              <div className="pdf-container">
-                <iframe 
-                  src={`data:${mimeType};base64,${content.data}`} 
-                  className="pdf-frame"
-                  title="PDF Document"
-                />
-              </div>
-            );
-          }
-          
-          // Binary file (download link)
-          return (
-            <div className="binary-content">
-              <p>Binary content: {mimeType || 'unknown type'}</p>
-              <p>Detection method: {content.detectionMethod || 'unknown'}</p>
-              <a 
-                href={`data:${mimeType};base64,${content.data}`}
-                download={selectedItem.name || 'download'}
-                className="btn btn-primary"
-              >
-                Download File
-              </a>
+        return (
+          <ContentWrapper className="json-wrapper">
+            {renderJsonWithHighlighting(jsonContent)}
+          </ContentWrapper>
+        );
+      } else if (contentType.mimeType === 'text/csv' || contentType.extension === 'csv') {
+        return (
+          <ContentWrapper className="csv-wrapper">
+            <div className="csv-content">
+              <table className="csv-table">
+                <tbody>
+                  {typeof selectedItem.content === 'string' && 
+                    selectedItem.content.split('\n').map((row, rowIndex) => (
+                      <tr key={rowIndex}>
+                        {row.split(',').map((cell, cellIndex) => (
+                          <td key={cellIndex} className="csv-cell">
+                            {cell.length > 50 ? cell.substring(0, 47) + '...' : cell}
+                          </td>
+                        ))}
+                      </tr>
+                    ))}
+                </tbody>
+              </table>
             </div>
-          );
-        }
-        
-        // Buffer format
-        if (content.type === 'Buffer' && Array.isArray(content.data)) {
-          return (
-            <div className="binary-content">
-              <p>Binary Buffer Data</p>
-              <p>Size: {content.data.length} bytes</p>
-              <p>(Buffer preview not available)</p>
+          </ContentWrapper>
+        );
+      } else {
+        // Default text display
+        return (
+          <ContentWrapper className="text-wrapper">
+            <div className="content-controls">
+              <div className="text-content-options">
+                <label>
+                  <input 
+                    type="checkbox" 
+                    checked={!wordWrap} 
+                    onChange={() => setWordWrap(!wordWrap)} 
+                  />
+                  Disable word wrap
+                </label>
+              </div>
+              <pre className={`content-text ${!wordWrap ? 'wrap-text' : 'nowrap-text'}`}>
+                {typeof selectedItem.content === 'string' 
+                  ? selectedItem.content 
+                  : JSON.stringify(selectedItem.content, null, 2)}
+              </pre>
             </div>
-          );
-        }
+          </ContentWrapper>
+        );
       }
-      
-      // Fallback for unknown content
-      return (
-        <div className="content-unknown">
-          <p>Content preview not available</p>
-          <p>Content type: {contentType || 'unknown'}</p>
-          <pre className="content-debug">
-            {JSON.stringify(content, null, 2)}
-          </pre>
-        </div>
-      );
     };
     
     return (
@@ -1049,15 +1134,13 @@ const CatalogPanel = () => {
         <div className="catalog-detail-content">
           <div className="catalog-detail-info">
             <div className="info-section">
-              <p><strong>ID:</strong> {selectedItem.id}</p>
+              <p><strong>Hash:</strong> {selectedItem.hash}</p>
               <p><strong>Type:</strong> {
                 selectedItem.contentType?.mimeType 
                   ? `${getSimpleContentType(selectedItem.contentType.mimeType) || selectedItem.contentType.mimeType} (${selectedItem.contentType.mimeType})` 
                   : 'Unknown'
               }</p>
-              <p><strong>Created:</strong> {new Date(selectedItem.timestamp).toLocaleString()}</p>
-              <p><strong>Description:</strong></p>
-              <div className="catalog-description">{selectedItem.description}</div>
+              <p><strong>gtime:</strong> {new Date(selectedItem.timestamp).toLocaleString()}</p>
             </div>
             
             <div className="content-section">
@@ -1070,7 +1153,7 @@ const CatalogPanel = () => {
             <div className="catalog-detail-actions">
               <button 
                 className="btn btn-danger"
-                onClick={() => handleDeleteItem(selectedItem.id)}
+                onClick={() => handleDeleteItem(selectedItem.hash)}
               >
                 Delete
               </button>
@@ -1081,12 +1164,112 @@ const CatalogPanel = () => {
     );
   };
 
+  // Helper function to render JSON with syntax highlighting and guaranteed wrapping
+  const renderJsonWithHighlighting = (jsonObj) => {
+    // Convert JSON to a vertical display format that won't overflow
+    const renderJsonAsTable = (obj, depth = 0) => {
+      // For primitive values, just return them formatted
+      if (typeof obj !== 'object' || obj === null) {
+        return renderPrimitiveValue(obj);
+      }
+      
+      // Recursive table builder
+      const rows = [];
+      
+      // Handle arrays or objects
+      const isArray = Array.isArray(obj);
+      
+      // For each key/index in the object/array
+      Object.entries(obj).forEach(([key, value], index) => {
+        // Create indentation based on depth
+        const indent = '  '.repeat(depth);
+        const displayKey = isArray ? `[${key}]` : key;
+        
+        // If value is an object, recurse, otherwise format the primitive
+        if (typeof value === 'object' && value !== null) {
+          // For objects/arrays, create a row with the key and a placeholder
+          rows.push(
+            `<tr>
+              <td class="json-key-cell">${indent}${displayKey}:</td>
+              <td class="json-value-cell">${isArray ? '[]' : '{'}...</td>
+            </tr>`
+          );
+          
+          // Add the nested object as indented rows
+          rows.push(renderJsonAsTable(value, depth + 1));
+          
+          // Close the object
+          rows.push(
+            `<tr>
+              <td class="json-key-cell">${indent}</td>
+              <td class="json-value-cell">${isArray ? ']' : '}'}</td>
+            </tr>`
+          );
+        } else {
+          // For primitive values, just add a row with the key and value
+          rows.push(
+            `<tr>
+              <td class="json-key-cell">${indent}${displayKey}:</td>
+              <td class="json-value-cell">${renderPrimitiveValue(value)}</td>
+            </tr>`
+          );
+        }
+      });
+      
+      return rows.join('');
+    };
+    
+    // Helper to format primitive values with truncation and highlighting
+    const renderPrimitiveValue = (value) => {
+      // Format and truncate based on type
+      if (typeof value === 'string') {
+        // Truncate long strings
+        const displayValue = value.length > 30 
+          ? `"${value.substring(0, 30)}..."` 
+          : `"${value}"`;
+        return `<span class="json-string">${displayValue}</span>`;
+      } else if (typeof value === 'number') {
+        return `<span class="json-number">${value}</span>`;
+      } else if (typeof value === 'boolean') {
+        return `<span class="json-boolean">${value}</span>`;
+      } else if (value === null) {
+        return `<span class="json-null">null</span>`;
+      } else {
+        return `<span>${String(value)}</span>`;
+      }
+    };
+    
+    // Create the table HTML
+    const tableHtml = `
+      <table class="json-table">
+        <tbody>
+          ${renderJsonAsTable(jsonObj)}
+        </tbody>
+      </table>
+    `;
+    
+    // Return the HTML table with inline styles for containment
+    return (
+      <div 
+        className="content-json-container" 
+        dangerouslySetInnerHTML={{ __html: tableHtml }}
+      />
+    );
+  };
+
   // Panel header with search and controls
   const renderHeader = () => (
     <>
       <div className="panel-header">
         <h2>Card Catalog</h2>
         <div className="panel-controls">
+          <button 
+            className="btn-refresh" 
+            onClick={handleRefresh}
+            title="Refresh catalog"
+          >
+            ‚Üª
+          </button>
           <div className="view-toggles">
             <button
               className={`btn-toggle ${viewMode === 'list' ? 'active' : ''}`}
@@ -1176,13 +1359,44 @@ const CatalogPanel = () => {
           />
         </div>
         
-        <div className="form-group">
-          <label htmlFor="file">Upload File (optional)</label>
+        <div 
+          className={`form-group drop-zone ${isDragging ? 'dropping' : ''}`}
+          ref={dropZoneRef}
+          onDragEnter={handleDragEnter}
+          onDragOver={handleDragOver}
+          onDragLeave={handleDragLeave}
+          onDrop={handleDrop}
+        >
+          <label htmlFor="file">
+            {isDragging 
+              ? "Drop file here" 
+              : (newItem.file 
+                ? `Selected: ${newItem.file.name}` 
+                : "Drag & drop a file here, or click to browse")}
+          </label>
           <input
             type="file"
             id="file"
             onChange={handleFileChange}
+            style={{ opacity: newItem.file ? 0 : 0.01 }}
           />
+          {!newItem.file && <div className="drop-icon">üìÅ</div>}
+          {newItem.file && (
+            <div className="file-info">
+              <span className="file-name">{newItem.file.name}</span>
+              <span className="file-size">({Math.round(newItem.file.size / 1024)} KB)</span>
+              <button 
+                type="button" 
+                className="btn-clear-file"
+                onClick={() => {
+                  setFileInput(null);
+                  setNewItem({...newItem, file: null});
+                }}
+              >
+                ‚úï
+              </button>
+            </div>
+          )}
         </div>
         
         <div className="form-group">
@@ -1200,12 +1414,22 @@ const CatalogPanel = () => {
         
         <div className="form-actions">
           <button type="submit" className="btn btn-primary">
-            Add Item
+            {newItem.file ? 'Upload File' : 'Add Content'}
           </button>
           <button 
             type="button" 
             className="btn btn-secondary" 
-            onClick={() => setViewMode('list')}
+            onClick={() => {
+              // Reset form
+              setNewItem({
+                name: '',
+                description: '',
+                contentType: 'text/plain',
+                file: null
+              });
+              setFileInput(null);
+              setViewMode('list');
+            }}
           >
             Cancel
           </button>
diff --git a/src/styles/CatalogPanel.css b/src/styles/CatalogPanel.css
index 83c163f..f33a810 100644
--- a/src/styles/CatalogPanel.css
+++ b/src/styles/CatalogPanel.css
@@ -33,6 +33,26 @@
   align-items: center;
 }
 
+.btn-refresh {
+  background-color: var(--btn-secondary-bg, #3a3a3a);
+  color: var(--text-color, #e0e0e0);
+  border: 1px solid var(--border-color, #4e4e4e);
+  border-radius: 50%;
+  width: 32px;
+  height: 32px;
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  font-size: 16px;
+  cursor: pointer;
+  transition: all 0.2s ease;
+}
+
+.btn-refresh:hover {
+  background-color: var(--primary-color, #4a7bab);
+  transform: rotate(180deg);
+}
+
 .view-toggles {
   display: flex;
   border-radius: 4px;
@@ -62,6 +82,9 @@
   background-color: var(--panel-subheader-bg, #262626);
   border-bottom: 1px solid var(--border-color, #3e3e3e);
   flex-wrap: wrap;
+  overflow-x: hidden !important; /* Force no horizontal overflow */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .search-container {
@@ -69,6 +92,9 @@
   display: flex;
   gap: 8px;
   min-width: 200px;
+  overflow-x: hidden !important; /* Force no horizontal overflow */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .search-input {
@@ -78,10 +104,16 @@
   border: 1px solid var(--border-color, #3e3e3e);
   border-radius: 4px;
   color: var(--text-color, #e0e0e0);
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .search-button {
   white-space: nowrap;
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .filter-select {
@@ -90,6 +122,9 @@
   border: 1px solid var(--border-color, #3e3e3e);
   border-radius: 4px;
   color: var(--text-color, #e0e0e0);
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .search-status {
@@ -98,23 +133,32 @@
   border-bottom: 1px solid var(--info-border, rgba(43, 108, 176, 0.3));
   color: var(--text-color, #e0e0e0);
   font-size: 0.9rem;
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .catalog-content {
   flex: 1;
   overflow-y: auto;
+  overflow-x: hidden !important; /* Force no horizontal overflow */
   padding: 15px;
   width: 100%;
   position: relative;
   display: flex;
   flex-direction: column;
   min-height: 300px; /* Ensure minimum height */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .catalog-list-view {
   width: 100%;
   overflow-x: auto;
   min-height: 300px;
+  overflow-x: hidden !important; /* Force no horizontal overflow */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .catalog-grid-view {
@@ -124,6 +168,9 @@
   padding: 15px;
   width: 100%;
   min-height: 300px;
+  overflow-x: hidden !important; /* Force no horizontal overflow */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .catalog-detail-view {
@@ -132,6 +179,9 @@
   height: 100%;
   display: flex;
   flex-direction: column;
+  overflow-x: hidden !important; /* Force no horizontal overflow */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .catalog-detail-header {
@@ -139,24 +189,36 @@
   align-items: center;
   gap: 12px;
   margin-bottom: 16px;
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .catalog-detail-header h2 {
   margin: 0;
   overflow: hidden;
   text-overflow: ellipsis;
+  white-space: nowrap;
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .catalog-detail-content {
   display: flex;
   flex-direction: column;
   gap: 24px;
+  overflow-x: hidden !important; /* Force no horizontal overflow */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .catalog-detail-info {
   display: flex;
   flex-direction: column;
   gap: 20px;
+  overflow-x: hidden !important; /* Force no horizontal overflow */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .info-section {
@@ -164,6 +226,9 @@
   padding: 16px;
   border-radius: 8px;
   border: 1px solid var(--border-color, #3e3e3e);
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .content-section {
@@ -171,6 +236,9 @@
   padding: 16px;
   border-radius: 8px;
   border: 1px solid var(--border-color, #3e3e3e);
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .content-section h3 {
@@ -178,6 +246,9 @@
   margin-bottom: 16px;
   font-size: 1.1rem;
   color: var(--text-secondary, #a0aec0);
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .content-container {
@@ -185,63 +256,103 @@
   max-height: 500px;
   background-color: var(--content-bg, #252525);
   border-radius: 4px;
+  max-width: 100%;
+  width: 100%;
+  position: relative;
+  box-sizing: border-box;
+  overflow-x: hidden !important; /* Force no horizontal overflow */
 }
 
 .content-text, .content-json {
   margin: 0;
   padding: 12px;
-  white-space: pre-wrap;
-  word-break: break-word;
+  white-space: pre-wrap !important;
+  word-break: break-all !important; /* Force break for extremely long strings */
   font-family: monospace;
   font-size: 0.9rem;
   line-height: 1.5;
-  overflow-x: auto;
+  overflow-wrap: break-word !important;
+  overflow-x: hidden !important; /* Force no horizontal overflow */
+  overflow: hidden !important; /* Force no overflow at all */
+  max-width: 100% !important;
+  width: 100%;
+  box-sizing: border-box;
+  display: block;
+  table-layout: fixed !important; /* For very large tables */
+  position: relative;
 }
 
-.content-json {
-  color: var(--json-color, #e6e6e6);
+.json-key, .json-string, .json-number, .json-boolean, .json-null {
+  word-break: break-all !important;
+  max-width: 100% !important;
+  display: inline-block;
+  overflow: hidden;
 }
 
 .content-image {
   max-width: 100%;
   display: block;
   margin: 0 auto;
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .content-audio, .content-video {
   width: 100%;
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .pdf-container {
   width: 100%;
   height: 500px;
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .pdf-frame {
   width: 100%;
   height: 100%;
   border: none;
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .html-content {
   padding: 12px;
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .binary-content {
   padding: 16px;
   text-align: center;
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .catalog-description {
   line-height: 1.5;
   margin-top: 4px;
   white-space: pre-line;
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .catalog-detail-actions {
   display: flex;
   gap: 12px;
   margin-top: 8px;
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .loading-indicator, .error-message, .empty-state {
@@ -250,6 +361,9 @@
   display: flex;
   justify-content: center;
   align-items: center;
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .pagination-controls {
@@ -259,11 +373,17 @@
   gap: 16px;
   padding: 16px;
   border-top: 1px solid var(--border-color, #3e3e3e);
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .pagination-info {
   color: var(--text-muted, #888);
   font-size: 0.9rem;
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .catalog-form {
@@ -275,55 +395,162 @@
   border-radius: 8px;
   margin: 16px;
   border: 1px solid var(--border-color, #3e3e3e);
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .form-group {
   display: flex;
   flex-direction: column;
-  gap: 4px;
-}
-
-.form-row {
-  display: grid;
-  grid-template-columns: 1fr 1fr;
-  gap: 16px;
+  gap: 8px;
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .form-group label {
-  font-size: 0.9rem;
+  font-weight: 500;
   color: var(--text-secondary, #a0aec0);
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .form-group input,
 .form-group textarea,
 .form-group select {
-  padding: 8px 12px;
+  padding: 10px 12px;
+  border-radius: 4px;
   background-color: var(--input-bg, #333);
   border: 1px solid var(--border-color, #3e3e3e);
-  border-radius: 4px;
   color: var(--text-color, #e0e0e0);
+  font-size: 14px;
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
-.form-group input[type="file"] {
-  padding: 6px;
+.drop-zone {
+  border: 2px dashed var(--border-color, #3e3e3e);
+  border-radius: 8px;
+  padding: 20px;
+  text-align: center;
+  position: relative;
+  min-height: 150px;
+  display: flex;
+  flex-direction: column;
+  align-items: center;
+  justify-content: center;
+  transition: all 0.3s ease;
+  background-color: var(--input-bg, #333);
+  cursor: pointer;
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
-.form-group textarea {
-  resize: vertical;
-  min-height: 80px;
+.drop-zone.dropping {
+  border-color: var(--primary-color, #4a7bab);
+  background-color: rgba(74, 123, 171, 0.1);
+  box-shadow: 0 0 10px rgba(74, 123, 171, 0.3);
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
-.form-group input:disabled,
-.form-group textarea:disabled {
-  background-color: var(--disabled-bg, #2a2a2a);
-  color: var(--disabled-color, #666);
-  cursor: not-allowed;
+.drop-zone label {
+  cursor: pointer;
+  margin-bottom: 12px;
+  font-weight: 500;
+  color: var(--text-secondary, #a0aec0);
+  width: 100%;
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
-.form-actions {
+.drop-zone input {
+  position: absolute;
+  width: 100%;
+  height: 100%;
+  top: 0;
+  left: 0;
+  cursor: pointer;
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
+}
+
+.drop-icon {
+  font-size: 40px;
+  opacity: 0.5;
+  margin: 10px 0;
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
+}
+
+.file-info {
   display: flex;
-  gap: 12px;
-  margin-top: 16px;
+  flex-wrap: wrap;
+  align-items: center;
+  gap: 8px;
+  background-color: rgba(255, 255, 255, 0.1);
+  padding: 10px;
+  border-radius: 4px;
+  width: 100%;
+  margin-top: 10px;
+  position: relative;
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
+}
+
+.file-name {
+  font-weight: 500;
+  flex: 1;
+  overflow: hidden;
+  text-overflow: ellipsis;
+  white-space: nowrap;
+  max-width: 100%;
+  box-sizing: border-box;
+}
+
+.file-size {
+  color: var(--text-secondary, #a0aec0);
+  font-size: 0.8rem;
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
+}
+
+.btn-clear-file {
+  background: rgba(255, 50, 50, 0.2);
+  border: none;
+  color: var(--text-color, #e0e0e0);
+  border-radius: 50%;
+  width: 22px;
+  height: 22px;
+  font-size: 12px;
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  cursor: pointer;
+  transition: all 0.2s;
+  position: absolute;
+  top: 5px;
+  right: 5px;
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
+}
+
+.btn-clear-file:hover {
+  background: rgba(255, 50, 50, 0.4);
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .catalog-list-cards {
@@ -333,10 +560,16 @@
   width: 100%;
   min-height: 300px;
   padding: 10px;
+  overflow-x: hidden !important; /* Force no horizontal overflow */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .list-card {
   width: 100%;
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .list-card-inner {
@@ -348,11 +581,17 @@
   background-color: var(--card-bg, #2c2c2c);
   cursor: pointer;
   box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
+  overflow-x: hidden !important; /* Force no horizontal overflow */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .list-card-inner:hover {
   transform: translateY(-3px);
   box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .list-card-thumbnail {
@@ -363,12 +602,18 @@
   align-items: center;
   justify-content: center;
   background-color: var(--card-image-bg, #333);
+  overflow-x: hidden !important; /* Force no horizontal overflow */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .list-card-thumbnail img {
   width: 100%;
   height: 100%;
   object-fit: cover;
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .list-card-content {
@@ -377,6 +622,9 @@
   display: flex;
   flex-direction: column;
   overflow: hidden;
+  overflow-x: hidden !important; /* Force no horizontal overflow */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .list-card-title {
@@ -385,6 +633,8 @@
   white-space: nowrap;
   overflow: hidden;
   text-overflow: ellipsis;
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .list-card-meta {
@@ -393,6 +643,9 @@
   margin-bottom: 8px;
   font-size: 0.85rem;
   color: var(--text-secondary, #a0aec0);
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .list-card-description {
@@ -405,6 +658,9 @@
   line-clamp: 2;
   -webkit-box-orient: vertical;
   max-height: 3em;
+  overflow-x: hidden !important; /* Force no horizontal overflow */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .list-card-actions {
@@ -414,11 +670,17 @@
   gap: 8px;
   padding: 0 15px;
   border-left: 1px solid var(--border-color, #3e3e3e);
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .grid-item {
   width: 100%;
   height: 100%;
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .grid-item-card {
@@ -432,11 +694,17 @@
   cursor: pointer;
   background-color: var(--card-bg, #2c2c2c);
   box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
+  overflow-x: hidden !important; /* Force no horizontal overflow */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .grid-item-card:hover {
   transform: translateY(-5px);
   box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .grid-item-thumbnail {
@@ -447,17 +715,26 @@
   justify-content: center;
   background-color: var(--card-image-bg, #333);
   border-bottom: 1px solid var(--border-color, #3e3e3e);
+  overflow-x: hidden !important; /* Force no horizontal overflow */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .grid-item-thumbnail img {
   width: 100%;
   height: 100%;
   object-fit: cover;
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .grid-item-thumbnail .file-icon {
   font-size: 3rem;
   color: var(--text-secondary, #a0aec0);
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .grid-item-info {
@@ -465,6 +742,10 @@
   flex: 1;
   display: flex;
   flex-direction: column;
+  overflow: hidden;
+  overflow-x: hidden !important; /* Force no horizontal overflow */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .grid-item-title {
@@ -474,6 +755,8 @@
   overflow: hidden;
   text-overflow: ellipsis;
   font-weight: 500;
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .grid-item-meta {
@@ -482,6 +765,9 @@
   margin-bottom: 10px;
   font-size: 0.85rem;
   color: var(--text-secondary, #a0aec0);
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .grid-item-description {
@@ -493,8 +779,11 @@
   -webkit-line-clamp: 3;
   line-clamp: 3;
   -webkit-box-orient: vertical;
-  max-height: 4.5em; /* Fallback for non-WebKit browsers: 3 lines √ó 1.5 line height */
+  max-height: 4.5em;
   flex: 1;
+  overflow-x: hidden !important; /* Force no horizontal overflow */
+  max-width: 100%;
+  box-sizing: border-box;
 }
 
 .grid-item-actions {
@@ -503,6 +792,136 @@
   display: flex;
   justify-content: flex-end;
   gap: 8px;
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
+}
+
+.form-actions {
+  display: flex;
+  gap: 12px;
+  margin-top: 20px;
+  justify-content: flex-end;
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
+}
+
+.form-actions .btn {
+  min-width: 120px;
+  padding: 10px 16px;
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
+}
+
+.content-controls {
+  display: flex;
+  flex-direction: column;
+  width: 100%;
+  max-width: 100%;
+  overflow: hidden;
+  overflow-x: hidden !important; /* Force no horizontal overflow */
+  max-width: 100%;
+  box-sizing: border-box;
+}
+
+.text-content-options {
+  display: flex;
+  padding: 8px 12px;
+  background-color: var(--card-bg, #2c2c2c);
+  border-bottom: 1px solid var(--border-color, #3e3e3e);
+  font-size: 0.85rem;
+  align-items: center;
+  z-index: 5;
+  position: sticky;
+  top: 0;
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
+}
+
+.text-content-options label {
+  display: flex;
+  align-items: center;
+  gap: 6px;
+  cursor: pointer;
+  user-select: none;
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
+}
+
+.text-content-options input[type="checkbox"] {
+  margin: 0;
+  cursor: pointer;
+  overflow: hidden; /* Contain all content */
+  max-width: 100%;
+  box-sizing: border-box;
+}
+
+.json-table {
+  width: 100%;
+  max-width: 100%;
+  border-collapse: collapse;
+  font-family: monospace;
+  font-size: 0.9rem;
+  line-height: 1.5;
+  table-layout: fixed; /* Critical for width control */
+  margin: 0;
+  padding: 0;
+}
+
+.json-key-cell {
+  width: 40%;
+  padding: 2px 4px;
+  vertical-align: top;
+  overflow: hidden;
+  text-overflow: ellipsis;
+  white-space: nowrap;
+  color: var(--json-key-color, #9cdcfe);
+  border-right: 1px solid rgba(255, 255, 255, 0.1);
+  text-align: left;
+}
+
+.json-value-cell {
+  width: 60%;
+  padding: 2px 4px;
+  vertical-align: top;
+  overflow: hidden;
+  text-overflow: ellipsis;
+  word-break: break-all;
+  white-space: normal;
+  text-align: left;
+}
+
+.content-json-container {
+  padding: 12px;
+  background-color: var(--content-bg, #252525);
+  overflow: auto;
+  max-width: 100%;
+  width: 100%;
+  box-sizing: border-box;
+}
+
+.json-table tr:hover {
+  background-color: rgba(255, 255, 255, 0.05);
+}
+
+.json-string {
+  color: var(--json-string-color, #ce9178);
+}
+
+.json-number {
+  color: var(--json-number-color, #b5cea8);
+}
+
+.json-boolean {
+  color: var(--json-boolean-color, #569cd6);
+}
+
+.json-null {
+  color: var(--json-null-color, #569cd6);
 }
 
 @media (max-width: 768px) {
@@ -533,3 +952,119 @@
     flex-wrap: wrap;
   }
 }
+
+/* Universal content wrapper - ultimate overflow prevention */
+.universal-content-wrapper {
+  width: 100%;
+  max-width: 100%;
+  overflow: hidden !important;
+  position: relative;
+  box-sizing: border-box;
+  display: block;
+  table-layout: fixed;
+}
+
+/* CSV table styles */
+.csv-table {
+  width: 100%;
+  max-width: 100%;
+  border-collapse: collapse;
+  font-family: monospace;
+  font-size: 0.9rem;
+  line-height: 1.5;
+  table-layout: fixed; /* Critical for width control */
+  margin: 0;
+  padding: 0;
+  overflow: hidden;
+}
+
+.csv-cell {
+  padding: 4px 8px;
+  border: 1px solid var(--border-color, #3e3e3e);
+  overflow: hidden;
+  text-overflow: ellipsis;
+  white-space: nowrap;
+  max-width: 250px; /* Limit cell width */
+}
+
+/* Striped rows for better readability */
+.csv-table tr:nth-child(even) {
+  background-color: rgba(255, 255, 255, 0.05);
+}
+
+/* Force content wrapping */
+.wrap-text {
+  white-space: pre-wrap !important;
+  word-break: break-all !important;
+}
+
+.nowrap-text {
+  white-space: pre !important;
+  overflow-x: auto !important;
+}
+
+/* Reset default browser styles for multi-line elements */
+pre, code, textarea {
+  max-width: 100% !important;
+  white-space: pre-wrap !important;
+  word-break: break-all !important;
+  overflow-wrap: break-word !important;
+  overflow: hidden !important;
+}
+
+/* Fix for all content containers */
+.content-container, 
+.content-text, 
+.content-json, 
+.content-json-container,
+.json-table,
+.csv-content,
+.html-content,
+.pdf-container,
+.binary-content,
+.image-wrapper,
+.audio-wrapper,
+.video-wrapper,
+.html-wrapper,
+.json-wrapper,
+.csv-wrapper,
+.text-wrapper {
+  max-width: 100% !important;
+  width: 100% !important;
+  overflow: hidden !important;
+  overflow-x: hidden !important;
+  word-break: break-all !important;
+  white-space: normal !important;
+  box-sizing: border-box !important;
+  display: block !important;
+}
+
+/* Fix for image content */
+.content-image {
+  max-width: 100% !important;
+  height: auto !important;
+  display: block !important;
+  margin: 0 auto !important;
+}
+
+/* Specific fixes for the catalog detail view panel */
+.catalog-detail-view {
+  position: relative !important;
+  overflow: hidden !important;
+  max-width: 100% !important;
+  display: flex !important;
+  flex-direction: column !important;
+}
+
+/* Make sure all content sections have containment */
+.catalog-detail-content {
+  overflow: hidden !important;
+  max-width: 100% !important;
+  width: 100% !important;
+  box-sizing: border-box !important;
+}
+
+/* Apply containment context to all elements */
+* {
+  contain: content !important;
+}
```
