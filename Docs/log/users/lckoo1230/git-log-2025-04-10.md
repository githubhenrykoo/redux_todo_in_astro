# Git Activity Log - Henry Koo
Generated at: Thu Apr 10 00:43:06 UTC 2025
## Changes by Henry Koo
```diff
commit f2f3c62e2b5c32d148f279fe8c3a522a28cd2851
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Wed Apr 9 20:28:28 2025 +0800

    new video viewer

diff --git a/package.json b/package.json
index c91aa4e..4232409 100644
--- a/package.json
+++ b/package.json
@@ -50,6 +50,7 @@
     "lucide-react": "^0.284.0",
     "mqtt": "^5.10.4",
     "node-pty": "^1.0.0",
+    "pdfjs-dist": "^5.1.91",
     "puppeteer": "^24.4.0",
     "react": "^18.2.0",
     "react-dom": "^18.2.0",
diff --git a/src/components/panels/CatalogPanel.jsx b/src/components/panels/CatalogPanel.jsx
index fa825f5..b1e1e23 100644
--- a/src/components/panels/CatalogPanel.jsx
+++ b/src/components/panels/CatalogPanel.jsx
@@ -505,3 +505,6 @@ const CatalogPanel = () => {
 };
 
 export default CatalogPanel;
+
+// Also export as a named export to support different import strategies
+export { CatalogPanel };
diff --git a/src/components/panels/catalog/GridItemPreview.jsx b/src/components/panels/catalog/GridItemPreview.jsx
index 29d142c..5c9041b 100644
--- a/src/components/panels/catalog/GridItemPreview.jsx
+++ b/src/components/panels/catalog/GridItemPreview.jsx
@@ -1,4 +1,4 @@
-import React, { useState, useEffect } from 'react';
+import React, { useState, useEffect, useRef } from 'react';
 import { getSimpleContentType, getContentTypeDisplay, getFormattedContentType, determineCorrectContentType } from './utils';
 import { ContentService } from '../../../services/content-service';
 import { isImageType } from '../../../utils/content-utils';
@@ -13,6 +13,10 @@ const GridItemPreview = ({ item }) => {
   const [dataUrl, setDataUrl] = useState(null);
   const [textPreview, setTextPreview] = useState(null);
   const [loading, setLoading] = useState(false);
+  const [videoThumbnail, setVideoThumbnail] = useState(null);
+  const [pdfThumbnail, setPdfThumbnail] = useState(null);
+  const videoRef = useRef(null);
+  const pdfRef = useRef(null);
   const contentType = item.contentType?.mimeType || 'unknown';
   
   // Process content based on type
@@ -54,6 +58,54 @@ const GridItemPreview = ({ item }) => {
           setImageError(true);
           setLoading(false);
         });
+    } else if (contentType.startsWith('video/')) {
+      // Handle video content - generate thumbnail
+      ContentService.fetchContent(item.hash, { maxRetries: 1 })
+        .then(result => {
+          setLoading(false);
+          if (result.error) {
+            console.error(`Error loading video preview for ${item.hash}:`, result.error);
+            return;
+          }
+          
+          // Create a blob URL for the video to capture a thumbnail
+          if (result.processed && result.processed.type === 'dataUrl') {
+            generateVideoThumbnail(result.processed.url);
+          } else if (result.raw?.content) {
+            const dataUrl = ContentService.getDataUrl(result.raw);
+            if (dataUrl) {
+              generateVideoThumbnail(dataUrl);
+            }
+          }
+        })
+        .catch(error => {
+          console.error("Error loading video preview:", error);
+          setLoading(false);
+        });
+    } else if (contentType === 'application/pdf') {
+      // Handle PDF content - generate thumbnail
+      ContentService.fetchContent(item.hash, { maxRetries: 1 })
+        .then(result => {
+          setLoading(false);
+          if (result.error) {
+            console.error(`Error loading PDF preview for ${item.hash}:`, result.error);
+            return;
+          }
+          
+          // Create a data URL for the PDF to generate a thumbnail
+          if (result.processed && result.processed.type === 'dataUrl') {
+            generatePdfThumbnail(result.processed.url);
+          } else if (result.raw?.content) {
+            const dataUrl = ContentService.getDataUrl(result.raw);
+            if (dataUrl) {
+              generatePdfThumbnail(dataUrl);
+            }
+          }
+        })
+        .catch(error => {
+          console.error("Error loading PDF preview:", error);
+          setLoading(false);
+        });
     } else if (contentType.startsWith('text/') || 
                contentType === 'application/json' || 
                contentType === 'application/xml') {
@@ -109,6 +161,128 @@ const GridItemPreview = ({ item }) => {
     return lines.map(line => line.trim().substring(0, 100)).join('\n');
   };
   
+  // Generate a thumbnail for a video
+  const generateVideoThumbnail = (url) => {
+    console.log('Generating video thumbnail from URL:', url);
+    
+    // Create a video element to capture the thumbnail
+    const video = document.createElement('video');
+    video.crossOrigin = 'anonymous'; // Handle potential CORS issues
+    video.src = url;
+    video.muted = true;
+    video.playsInline = true;
+    
+    // Add event listeners
+    video.onloadeddata = () => {
+      console.log('Video loaded data, duration:', video.duration);
+      try {
+        // Seek to the middle of the video to capture a more representative frame
+        const seekTime = video.duration / 2;
+        console.log(`Seeking to middle of video: ${seekTime.toFixed(2)}s`);
+        video.currentTime = seekTime;
+      } catch (err) {
+        console.error('Error seeking video:', err);
+        // Try to extract thumbnail without seeking
+        captureFrame();
+      }
+    };
+    
+    video.onerror = (e) => {
+      console.error('Error loading video for thumbnail:', e);
+      setLoading(false);
+    };
+    
+    video.onseeked = () => {
+      console.log('Video seeked to timestamp for thumbnail capture');
+      captureFrame();
+    };
+    
+    // Helper function to capture a frame
+    const captureFrame = () => {
+      try {
+        // Capture the thumbnail
+        const canvas = document.createElement('canvas');
+        canvas.width = video.videoWidth || 320;
+        canvas.height = video.videoHeight || 240;
+        const ctx = canvas.getContext('2d');
+        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
+        const thumbnailUrl = canvas.toDataURL('image/jpeg', 0.8);
+        console.log('Successfully captured video thumbnail');
+        setVideoThumbnail(thumbnailUrl);
+        
+        // Clean up
+        video.pause();
+        URL.revokeObjectURL(video.src);
+      } catch (err) {
+        console.error('Error capturing video frame:', err);
+      }
+    };
+    
+    // Load and play the video to trigger events
+    video.load();
+    
+    // Some browsers need a manual play to trigger events
+    const playPromise = video.play();
+    if (playPromise !== undefined) {
+      playPromise.catch(error => {
+        console.error('Auto-play prevented:', error);
+        // Try to capture frame anyway
+        setTimeout(captureFrame, 300);
+      });
+    }
+  };
+  
+  // Generate a thumbnail for a PDF - fallback method without using PDF.js
+  const generatePdfThumbnail = async (url) => {
+    console.log('Generating PDF thumbnail using fallback method');
+    
+    try {
+      // Instead of using PDF.js which requires DOMMatrix, use a simple icon approach
+      setLoading(false);
+      
+      // Create a canvas with a PDF icon or placeholder
+      const canvas = document.createElement('canvas');
+      canvas.width = 320;
+      canvas.height = 240;
+      const ctx = canvas.getContext('2d');
+      
+      // Fill with light gray background
+      ctx.fillStyle = '#f5f5f5';
+      ctx.fillRect(0, 0, canvas.width, canvas.height);
+      
+      // Draw PDF icon or text
+      ctx.fillStyle = '#e74c3c';
+      ctx.font = 'bold 24px Arial';
+      ctx.textAlign = 'center';
+      ctx.textBaseline = 'middle';
+      ctx.fillText('PDF', canvas.width / 2, canvas.height / 2 - 40);
+      
+      // Add a page representation
+      ctx.strokeStyle = '#e74c3c';
+      ctx.lineWidth = 2;
+      const pageWidth = 100;
+      const pageHeight = 130;
+      const pageX = (canvas.width - pageWidth) / 2;
+      const pageY = (canvas.height - pageHeight) / 2;
+      ctx.strokeRect(pageX, pageY, pageWidth, pageHeight);
+      
+      // Add some dummy lines to represent text
+      ctx.fillStyle = '#777777';
+      for (let i = 0; i < 5; i++) {
+        const lineWidth = 70 * (0.5 + Math.random() * 0.5);
+        ctx.fillRect(pageX + 15, pageY + 30 + i * 20, lineWidth, 5);
+      }
+      
+      // Convert to data URL
+      const thumbnailUrl = canvas.toDataURL('image/png');
+      console.log('Successfully created PDF thumbnail placeholder');
+      setPdfThumbnail(thumbnailUrl);
+    } catch (error) {
+      console.error('Error generating PDF thumbnail:', error);
+      setLoading(false);
+    }
+  };
+  
   // Image previews
   if (contentType.startsWith('image/')) {
     if (imageError) {
@@ -140,6 +314,82 @@ const GridItemPreview = ({ item }) => {
     );
   }
   
+  // For videos without thumbnails yet, show icon with loading state
+  if (contentType.startsWith('video/') && !videoThumbnail) {
+    return (
+      <div className="grid-item-preview default-preview video-fallback">
+        {loading ? (
+          <div className="loading-indicator">
+            <i className="fa fa-spinner fa-spin" />
+          </div>
+        ) : (
+          <div className="preview-icon">
+            <i className="fa fa-file-video" />
+            <div className="content-type-label">
+              {item.contentType?.mimeType === 'video/quicktime' ? 
+                'MP4 (video/mp4)' : 
+                getFormattedContentType(item.contentType?.mimeType)}
+            </div>
+          </div>
+        )}
+      </div>
+    );
+  }
+  
+  // Video previews
+  if (contentType.startsWith('video/') && videoThumbnail) {
+    return (
+      <div className="grid-item-preview video-preview">
+        <img 
+          src={videoThumbnail} 
+          alt={item.name || 'Video preview'} 
+          className="preview-image"
+        />
+        <div className="video-type-label">
+          {item.contentType?.mimeType === 'video/quicktime' ? 
+            'MP4 (video/mp4)' : 
+            getFormattedContentType(item.contentType?.mimeType)}
+        </div>
+      </div>
+    );
+  }
+  
+  // PDF previews
+  if (contentType === 'application/pdf' && pdfThumbnail) {
+    return (
+      <div className="grid-item-preview pdf-preview">
+        <img 
+          src={pdfThumbnail} 
+          alt={item.name || 'PDF preview'} 
+          className="preview-image"
+        />
+        <div className="pdf-type-label">
+          {getFormattedContentType('application/pdf')}
+        </div>
+      </div>
+    );
+  }
+  
+  // For PDFs without thumbnails yet, show icon with loading state
+  if (contentType === 'application/pdf' && !pdfThumbnail) {
+    return (
+      <div className="grid-item-preview default-preview pdf-fallback">
+        {loading ? (
+          <div className="loading-indicator">
+            <i className="fa fa-spinner fa-spin" />
+          </div>
+        ) : (
+          <div className="preview-icon">
+            <i className="fa fa-file-pdf" />
+            <div className="content-type-label">
+              {getFormattedContentType('application/pdf')}
+            </div>
+          </div>
+        )}
+      </div>
+    );
+  }
+  
   // Text previews (CSV, JSON, etc.)
   if ((contentType.startsWith('text/') || 
        contentType === 'application/json' || 
diff --git a/src/components/panels/catalog/grid-item-preview.css b/src/components/panels/catalog/grid-item-preview.css
index 6c77fa2..acb4662 100644
--- a/src/components/panels/catalog/grid-item-preview.css
+++ b/src/components/panels/catalog/grid-item-preview.css
@@ -164,7 +164,51 @@
 
 /* Video preview styles */
 .video-preview {
-  background-color: #000;
+  position: relative;
+  height: 100%;
+  width: 100%;
+  overflow: hidden;
+  display: flex;
+  align-items: center;
+  justify-content: center;
+}
+
+.video-preview .preview-image {
+  width: 100%;
+  height: 100%;
+  object-fit: cover;
+  border-radius: 4px;
+}
+
+.video-preview::before {
+  content: '▶';
+  position: absolute;
+  top: 50%;
+  left: 50%;
+  transform: translate(-50%, -50%);
+  width: 40px;
+  height: 40px;
+  background-color: rgba(0, 0, 0, 0.6);
+  border-radius: 50%;
+  color: white;
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  font-size: 18px;
+  z-index: 2;
+}
+
+.video-type-label {
+  position: absolute;
+  bottom: 0;
+  left: 0;
+  right: 0;
+  background-color: rgba(0, 0, 0, 0.7);
+  color: white;
+  padding: 4px 8px;
+  font-size: 12px;
+  text-align: center;
+  z-index: 2;
 }
 
 .video-thumbnail {
@@ -197,6 +241,57 @@
   z-index: 2;
 }
 
+/* PDF preview specific styling */
+.pdf-preview {
+  position: relative;
+  height: 100%;
+  width: 100%;
+  overflow: hidden;
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  background-color: #f5f5f5;
+}
+
+.pdf-preview .preview-image {
+  width: 100%;
+  height: auto;
+  object-fit: contain;
+  border-radius: 4px;
+}
+
+.pdf-preview::before {
+  content: '\f1c1'; /* PDF icon */
+  font-family: 'Font Awesome 5 Free';
+  font-weight: 900;
+  position: absolute;
+  top: 8px;
+  right: 8px;
+  width: 24px;
+  height: 24px;
+  background-color: rgba(0, 0, 0, 0.6);
+  border-radius: 50%;
+  color: white;
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  font-size: 12px;
+  z-index: 2;
+}
+
+.pdf-type-label {
+  position: absolute;
+  bottom: 0;
+  left: 0;
+  right: 0;
+  background-color: rgba(0, 0, 0, 0.7);
+  color: white;
+  padding: 4px 8px;
+  font-size: 12px;
+  text-align: center;
+  z-index: 2;
+}
+
 /* Audio preview styles */
 .audio-preview {
   background-color: #2c3e50;
diff --git a/src/layouts/PanelGroupLayout.jsx b/src/layouts/PanelGroupLayout.jsx
index 7839358..b6a10da 100644
--- a/src/layouts/PanelGroupLayout.jsx
+++ b/src/layouts/PanelGroupLayout.jsx
@@ -5,6 +5,8 @@ import { store } from '../store';
 
 // Map of panel types to their components
 const panelComponents = {
+  // Add direct component mapping for CatalogPanel
+  'CatalogPanel': React.lazy(() => import('../components/panels/CatalogPanel.jsx')),
   // Other components can be added here
 };
 

commit 7ebdfea8ed98a633e6ef9e5967e06d148463f694
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Wed Apr 9 20:02:03 2025 +0800

    better video

diff --git a/src/components/panels/catalog/DetailView.jsx b/src/components/panels/catalog/DetailView.jsx
index 0e2d638..800112b 100644
--- a/src/components/panels/catalog/DetailView.jsx
+++ b/src/components/panels/catalog/DetailView.jsx
@@ -173,6 +173,31 @@ const DetailView = ({
     return `${(size / (1024 * 1024 * 1024)).toFixed(2)} GB`;
   };
 
+  // Get correct content type for display
+  const getDisplayContentType = () => {
+    if (!selectedItem?.contentType?.mimeType) return 'Unknown';
+    
+    // Handle special case for QuickTime videos that are actually MP4s
+    if (selectedItem.contentType.mimeType === 'video/quicktime') {
+      console.log('Converting QuickTime content type display to MP4');
+      return 'MP4 (video/mp4)';
+    }
+    
+    // Use the standard formatting function for all other content types
+    return getFormattedContentType(selectedItem.contentType.mimeType);
+  };
+
+  // Render item details section
+  const renderItemDetails = () => {
+    return (
+      <div className="info-section">
+        <p><strong>Hash:</strong> {selectedItem.hash}</p>
+        <p><strong>Type:</strong> {getDisplayContentType()}</p>
+        <p><strong>Date:</strong> {selectedItem.timestamp || 'Unknown'}</p>
+      </div>
+    );
+  };
+
   if (itemLoading) {
     return <div className="loading-indicator">Loading item details...</div>;
   }
@@ -529,13 +554,7 @@ const DetailView = ({
       
       <div className="catalog-detail-content">
         <div className="catalog-detail-info">
-          <div className="info-section">
-            <p><strong>Hash:</strong> {selectedItem.hash}</p>
-            <p><strong>Type:</strong> {
-              determineCorrectContentType(selectedItem)
-            }</p>
-            <p><strong>Date:</strong> {selectedItem.timestamp || 'Unknown'}</p>
-          </div>
+          {renderItemDetails()}
           
           <div className="content-section">
             <h3>Content</h3>
diff --git a/src/components/panels/catalog/GridItemPreview.jsx b/src/components/panels/catalog/GridItemPreview.jsx
index 6d28e31..29d142c 100644
--- a/src/components/panels/catalog/GridItemPreview.jsx
+++ b/src/components/panels/catalog/GridItemPreview.jsx
@@ -1,5 +1,5 @@
 import React, { useState, useEffect } from 'react';
-import { getSimpleContentType, getContentTypeDisplay, getFormattedContentType } from './utils';
+import { getSimpleContentType, getContentTypeDisplay, getFormattedContentType, determineCorrectContentType } from './utils';
 import { ContentService } from '../../../services/content-service';
 import { isImageType } from '../../../utils/content-utils';
 
@@ -157,7 +157,9 @@ const GridItemPreview = ({ item }) => {
               <pre>{textPreview}</pre>
             </div>
             <div className="text-type-label">
-              {getFormattedContentType(item.contentType?.mimeType)}
+              {item.contentType?.mimeType === 'video/quicktime' ? 
+                'MP4 (video/mp4)' : 
+                getFormattedContentType(item.contentType?.mimeType)}
             </div>
           </>
         )}
@@ -182,7 +184,9 @@ const GridItemPreview = ({ item }) => {
       <div className="preview-icon">
         <i className={getIconClass()} />
         <div className="content-type-label">
-          {getFormattedContentType(item.contentType?.mimeType)}
+          {item.contentType?.mimeType === 'video/quicktime' ? 
+            'MP4 (video/mp4)' : 
+            getFormattedContentType(item.contentType?.mimeType)}
         </div>
       </div>
     </div>

commit fd293e505f407852fe49f83d0dc4b5fb81fa3788
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Wed Apr 9 19:45:18 2025 +0800

    correct content type

diff --git a/src/components/panels/catalog/GridItemPreview.jsx b/src/components/panels/catalog/GridItemPreview.jsx
index 90931f9..6d28e31 100644
--- a/src/components/panels/catalog/GridItemPreview.jsx
+++ b/src/components/panels/catalog/GridItemPreview.jsx
@@ -1,5 +1,5 @@
 import React, { useState, useEffect } from 'react';
-import { getSimpleContentType, getContentTypeDisplay } from './utils';
+import { getSimpleContentType, getContentTypeDisplay, getFormattedContentType } from './utils';
 import { ContentService } from '../../../services/content-service';
 import { isImageType } from '../../../utils/content-utils';
 
@@ -157,7 +157,7 @@ const GridItemPreview = ({ item }) => {
               <pre>{textPreview}</pre>
             </div>
             <div className="text-type-label">
-              {ContentService.getContentTypeDisplay(item.contentType)}
+              {getFormattedContentType(item.contentType?.mimeType)}
             </div>
           </>
         )}
@@ -182,7 +182,7 @@ const GridItemPreview = ({ item }) => {
       <div className="preview-icon">
         <i className={getIconClass()} />
         <div className="content-type-label">
-          {ContentService.getContentTypeDisplay(item.contentType)}
+          {getFormattedContentType(item.contentType?.mimeType)}
         </div>
       </div>
     </div>
diff --git a/src/components/viewers/VideoPlayer.jsx b/src/components/viewers/VideoPlayer.jsx
index 2386552..b94cc60 100644
--- a/src/components/viewers/VideoPlayer.jsx
+++ b/src/components/viewers/VideoPlayer.jsx
@@ -27,6 +27,7 @@ const VideoPlayer = ({ content, contentType, hash }) => {
   const videoRef = useRef(null);
   const videoContainerRef = useRef(null);
   const seekBarRef = useRef(null);
+  const progressIntervalRef = useRef(null);
   
   useEffect(() => {
     setLoading(true);
@@ -203,6 +204,39 @@ const VideoPlayer = ({ content, contentType, hash }) => {
     };
   }, [content, contentType, hash, retry]);
   
+  // Use a manual interval to update the progress bar more frequently
+  useEffect(() => {
+    const startProgressTracking = () => {
+      if (progressIntervalRef.current) {
+        clearInterval(progressIntervalRef.current);
+      }
+      
+      progressIntervalRef.current = setInterval(() => {
+        if (videoRef.current && !isDraggingSeeker && isPlaying) {
+          setCurrentTime(videoRef.current.currentTime);
+        }
+      }, 60); // Update roughly every 60ms for smoother updates
+    };
+    
+    const stopProgressTracking = () => {
+      if (progressIntervalRef.current) {
+        clearInterval(progressIntervalRef.current);
+        progressIntervalRef.current = null;
+      }
+    };
+    
+    if (isPlaying) {
+      startProgressTracking();
+    } else {
+      stopProgressTracking();
+    }
+    
+    // Clean up on unmount
+    return () => {
+      stopProgressTracking();
+    };
+  }, [isPlaying, isDraggingSeeker]);
+  
   // Toggle play/pause 
   const togglePlay = () => {
     if (videoRef.current) {
@@ -412,8 +446,8 @@ const VideoPlayer = ({ content, contentType, hash }) => {
   };
   
   const getVideoTitle = () => {
-    // This could be expanded to extract metadata from the video
-    return "Soldier falling down to knees Meme template";
+    // Use the item name if available, otherwise default to hash
+    return hash ? `Video ${hash.substring(0, 8)}` : "Video";
   };
 
   const formatFileSize = (bytes) => {
@@ -425,8 +459,12 @@ const VideoPlayer = ({ content, contentType, hash }) => {
   };
 
   const getVideoFileSize = () => {
-    // This is a placeholder - would need to be implemented to get actual size
-    return 2.5 * 1024 * 1024; // Assume 2.5MB as an example
+    // Try to get actual file size from content if available
+    if (content && content.content && content.content.data) {
+      return content.content.data.length || 0;
+    }
+    // Fallback size
+    return 0;
   };
 
   return (

commit 96ef9b1de5057c2584328de25793aa3facd672bd
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Wed Apr 9 19:35:01 2025 +0800

    better video display

diff --git a/src/components/panels/catalog/detail-view.css b/src/components/panels/catalog/detail-view.css
index d0ee00b..d9a0eac 100644
--- a/src/components/panels/catalog/detail-view.css
+++ b/src/components/panels/catalog/detail-view.css
@@ -105,48 +105,51 @@
   width: 100%;
 }
 
-/* Video Display Container - new direct container */
+/* Video Display Container - YouTube-like layout */
 .video-display-container {
   width: 100%;
   padding: 0;
   margin: 0 auto 20px;
-  background-color: transparent;
+  background-color: #121212;
   display: flex;
-  justify-content: center;
+  flex-direction: column;
   align-items: center;
-  overflow: visible;
+  overflow: hidden;
+  border-radius: 8px;
+  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
 }
 
 .video-display-container .video-player-container {
   width: 100%;
-  max-width: 800px;
+  max-width: 900px;
   padding: 0;
   margin: 0 auto;
   background-color: #000;
-  border-radius: 4px;
-  overflow: visible;
+  border-radius: 0;
+  overflow: hidden;
+  position: relative;
 }
 
 .video-display-container .video-wrapper {
   width: 100%;
   max-width: 100%;
   height: auto;
-  border-radius: 4px;
-  overflow: visible;
+  aspect-ratio: 16/9;
+  overflow: hidden;
   background-color: #000;
   display: flex;
   justify-content: center;
   align-items: center;
+  position: relative;
 }
 
 .video-display-container .video-player {
-  max-width: 100%;
+  width: 100% !important;
+  height: 100% !important;
   max-height: 70vh;
-  height: auto !important;
-  width: auto !important;
   display: block;
-  border-radius: 4px;
-  margin: 0 auto;
+  margin: 0;
+  object-fit: contain;
 }
 
 /* Video Content Styles */
diff --git a/src/components/viewers/VideoPlayer.jsx b/src/components/viewers/VideoPlayer.jsx
index 785bb3e..2386552 100644
--- a/src/components/viewers/VideoPlayer.jsx
+++ b/src/components/viewers/VideoPlayer.jsx
@@ -1,6 +1,7 @@
 import React, { useState, useEffect, useRef } from 'react';
 import { ContentService } from '../../services/content-service';
 import './video-player.css';
+import { getFormattedContentType } from '../panels/catalog/utils';
 
 /**
  * VideoPlayer component for handling various video formats including QuickTime
@@ -293,9 +294,11 @@ const VideoPlayer = ({ content, contentType, hash }) => {
     if (!seekBarRef.current || !videoRef.current || duration === 0) return;
     
     const rect = seekBarRef.current.getBoundingClientRect();
-    const position = (e.clientX - rect.left) / rect.width;
+    const position = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
     const newTime = position * duration;
     
+    console.log(`Updating video seek position: ${position.toFixed(2)} (${newTime.toFixed(2)}s)`);
+    
     // Update video current time
     videoRef.current.currentTime = newTime;
     setCurrentTime(newTime);
@@ -309,11 +312,33 @@ const VideoPlayer = ({ content, contentType, hash }) => {
     
     const handleTimeUpdate = () => {
       if (!isDraggingSeeker) {
-        setCurrentTime(videoElement.currentTime);
+        const newTime = videoElement.currentTime;
+        console.log(`Video time updated: ${newTime.toFixed(2)}s / ${videoElement.duration.toFixed(2)}s`);
+        setCurrentTime(newTime);
       }
     };
     
     const handleDurationChange = () => {
+      const newDuration = videoElement.duration;
+      console.log(`Video duration updated: ${newDuration.toFixed(2)}s`);
+      setDuration(newDuration);
+    };
+    
+    const handleLoadedMetadata = () => {
+      const newDuration = videoElement.duration;
+      console.log(`Video metadata loaded. Duration: ${newDuration.toFixed(2)}s`);
+      setDuration(newDuration);
+      
+      // Some browsers only set duration properly on loadedmetadata
+      if (isNaN(duration) || duration === 0) {
+        setDuration(newDuration);
+      }
+    };
+    
+    const handleLoadedData = () => {
+      console.log('Video data loaded. Ready to play.');
+      // Force a UI update once the video is loaded
+      setCurrentTime(videoElement.currentTime);
       setDuration(videoElement.duration);
     };
     
@@ -337,6 +362,8 @@ const VideoPlayer = ({ content, contentType, hash }) => {
     // Add event listeners
     videoElement.addEventListener('timeupdate', handleTimeUpdate);
     videoElement.addEventListener('durationchange', handleDurationChange);
+    videoElement.addEventListener('loadedmetadata', handleLoadedMetadata);
+    videoElement.addEventListener('loadeddata', handleLoadedData);
     videoElement.addEventListener('play', handlePlay);
     videoElement.addEventListener('pause', handlePause);
     videoElement.addEventListener('volumechange', handleVolumeUpdate);
@@ -349,6 +376,8 @@ const VideoPlayer = ({ content, contentType, hash }) => {
     return () => {
       videoElement.removeEventListener('timeupdate', handleTimeUpdate);
       videoElement.removeEventListener('durationchange', handleDurationChange);
+      videoElement.removeEventListener('loadedmetadata', handleLoadedMetadata);
+      videoElement.removeEventListener('loadeddata', handleLoadedData);
       videoElement.removeEventListener('play', handlePlay);
       videoElement.removeEventListener('pause', handlePause);
       videoElement.removeEventListener('volumechange', handleVolumeUpdate);
@@ -382,6 +411,24 @@ const VideoPlayer = ({ content, contentType, hash }) => {
     return 'mov';
   };
   
+  const getVideoTitle = () => {
+    // This could be expanded to extract metadata from the video
+    return "Soldier falling down to knees Meme template";
+  };
+
+  const formatFileSize = (bytes) => {
+    if (!bytes || isNaN(bytes)) return '0 B';
+    
+    const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
+    const i = Math.floor(Math.log(bytes) / Math.log(1024));
+    return `${(bytes / Math.pow(1024, i)).toFixed(2)} ${sizes[i]}`;
+  };
+
+  const getVideoFileSize = () => {
+    // This is a placeholder - would need to be implemented to get actual size
+    return 2.5 * 1024 * 1024; // Assume 2.5MB as an example
+  };
+
   return (
     <div className="video-player-container">
       {loading ? (
@@ -453,14 +500,13 @@ const VideoPlayer = ({ content, contentType, hash }) => {
               onClick={handleSeekBarClick}
               onMouseDown={handleSeekBarMouseDown}
             >
-              <div className="video-progress-background"></div>
               <div 
                 className="video-progress-bar" 
-                style={{ width: `${(currentTime / duration) * 100}%` }}
+                style={{ width: duration > 0 ? `${(currentTime / duration * 100).toFixed(2)}%` : '0%' }}
               ></div>
               <div 
                 className="video-progress-handle"
-                style={{ left: `${(currentTime / duration) * 100}%` }}
+                style={{ left: duration > 0 ? `${(currentTime / duration * 100).toFixed(2)}%` : '0%' }}
               ></div>
             </div>
             
@@ -519,6 +565,21 @@ const VideoPlayer = ({ content, contentType, hash }) => {
           </div>
         </div>
       )}
+      {!isQuickTime && !loading && !error && (
+        <div className="video-title-area">
+          <h3 className="video-title">{getVideoTitle()}</h3>
+          <div className="video-info">
+            <div className="video-metadata">
+              <span className="video-format">
+                {contentType?.mimeType ? 
+                  `${getFormattedContentType(contentType.mimeType)}` : 
+                  'Video'}
+              </span>
+              <span>{formatFileSize(getVideoFileSize())}</span>
+            </div>
+          </div>
+        </div>
+      )}
     </div>
   );
 };
diff --git a/src/components/viewers/video-player.css b/src/components/viewers/video-player.css
index c9da415..944ecd5 100644
--- a/src/components/viewers/video-player.css
+++ b/src/components/viewers/video-player.css
@@ -178,7 +178,7 @@ video::-webkit-media-controls-play-button {
   color: white;
 }
 
-/* Custom Video Controls */
+/* Custom Video Controls - YouTube Style */
 .video-wrapper {
   position: relative;
   width: 100%;
@@ -208,34 +208,32 @@ video::-webkit-media-controls-play-button {
   bottom: 0;
   left: 0;
   right: 0;
-  background: linear-gradient(to top, rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0));
-  padding: 10px;
+  background: linear-gradient(to top, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0));
+  padding: 8px 12px;
   opacity: 0;
   transition: opacity 0.3s ease;
+  z-index: 10;
 }
 
 .video-wrapper:hover .custom-video-controls,
-.custom-video-controls:hover {
+.custom-video-controls:hover,
+.custom-video-controls:focus-within {
   opacity: 1;
 }
 
 .video-progress-container {
   width: 100%;
-  height: 10px;
+  height: 5px;
   background-color: rgba(255, 255, 255, 0.2);
-  border-radius: 5px;
+  border-radius: 2px;
   margin-bottom: 10px;
   position: relative;
   cursor: pointer;
+  transition: height 0.2s ease;
 }
 
-.video-progress-background {
-  position: absolute;
-  top: 0;
-  left: 0;
-  width: 100%;
-  height: 100%;
-  border-radius: 5px;
+.video-progress-container:hover {
+  height: 8px;
 }
 
 .video-progress-bar {
@@ -243,8 +241,8 @@ video::-webkit-media-controls-play-button {
   top: 0;
   left: 0;
   height: 100%;
-  background-color: #007bff;
-  border-radius: 5px;
+  background-color: #ff0000; /* YouTube red */
+  border-radius: 2px;
   transition: width 0.1s ease-out;
 }
 
@@ -252,19 +250,21 @@ video::-webkit-media-controls-play-button {
   position: absolute;
   top: 50%;
   transform: translate(-50%, -50%);
-  width: 16px;
-  height: 16px;
-  background-color: white;
+  width: 12px;
+  height: 12px;
+  background-color: #ff0000;
+  border: 2px solid white;
   border-radius: 50%;
   box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
   cursor: pointer;
   z-index: 2;
   opacity: 0;
-  transition: opacity 0.2s ease;
+  transition: opacity 0.2s ease, transform 0.2s ease;
 }
 
 .video-progress-container:hover .video-progress-handle {
   opacity: 1;
+  transform: translate(-50%, -50%) scale(1.2);
 }
 
 .video-controls-bottom {
@@ -279,7 +279,7 @@ video::-webkit-media-controls-play-button {
 .video-controls-right {
   display: flex;
   align-items: center;
-  gap: 10px;
+  gap: 12px;
 }
 
 .video-control-button {
@@ -297,7 +297,7 @@ video::-webkit-media-controls-play-button {
 }
 
 .video-control-button:hover {
-  background-color: rgba(255, 255, 255, 0.1);
+  background-color: rgba(255, 255, 255, 0.2);
 }
 
 .control-icon {
@@ -307,7 +307,7 @@ video::-webkit-media-controls-play-button {
 .video-volume-control {
   display: flex;
   align-items: center;
-  gap: 5px;
+  gap: 8px;
 }
 
 .volume-slider {
@@ -315,10 +315,11 @@ video::-webkit-media-controls-play-button {
   cursor: pointer;
   -webkit-appearance: none;
   appearance: none;
-  height: 4px;
-  background: rgba(255, 255, 255, 0.3);
+  height: 3px;
+  background: rgba(255, 255, 255, 0.5);
   border-radius: 2px;
   outline: none;
+  transition: width 0.2s ease;
 }
 
 .volume-slider::-webkit-slider-thumb {
@@ -329,7 +330,7 @@ video::-webkit-media-controls-play-button {
   background: white;
   border-radius: 50%;
   cursor: pointer;
-  transition: background-color 0.2s;
+  transition: background-color 0.2s, transform 0.2s;
 }
 
 .volume-slider::-moz-range-thumb {
@@ -339,21 +340,24 @@ video::-webkit-media-controls-play-button {
   border-radius: 50%;
   cursor: pointer;
   border: none;
-  transition: background-color 0.2s;
+  transition: background-color 0.2s, transform 0.2s;
 }
 
 .volume-slider:hover::-webkit-slider-thumb {
-  background: #007bff;
+  background: #ff0000;
+  transform: scale(1.2);
 }
 
 .volume-slider:hover::-moz-range-thumb {
-  background: #007bff;
+  background: #ff0000;
+  transform: scale(1.2);
 }
 
 .video-time-display {
-  font-size: 14px;
-  margin-left: 10px;
-  color: rgba(255, 255, 255, 0.8);
+  font-size: 13px;
+  font-family: 'Roboto', Arial, sans-serif;
+  color: rgba(255, 255, 255, 0.9);
+  letter-spacing: 0.2px;
 }
 
 .video-time-display span {
@@ -361,7 +365,7 @@ video::-webkit-media-controls-play-button {
   vertical-align: middle;
 }
 
-/* Styles for download link in control bar */
+/* Styles for download link in control bar - YouTube style */
 .video-controls-right .download-link {
   background-color: transparent;
   padding: 5px;
@@ -372,10 +376,49 @@ video::-webkit-media-controls-play-button {
   justify-content: center;
   width: 32px;
   height: 32px;
+  color: white;
+  text-decoration: none;
 }
 
 .video-controls-right .download-link:hover {
+  background-color: rgba(255, 255, 255, 0.2);
+}
+
+/* YouTube-style title area */
+.video-title-area {
+  width: 100%;
+  padding: 12px 16px;
+  background-color: #121212;
+  color: white;
+  border-top: 1px solid #2a2a2a;
+  font-family: 'Roboto', Arial, sans-serif;
+}
+
+.video-title {
+  font-size: 18px;
+  font-weight: 500;
+  margin: 0 0 8px 0;
+}
+
+.video-info {
+  display: flex;
+  justify-content: space-between;
+  align-items: center;
+  font-size: 14px;
+  color: #aaa;
+}
+
+.video-metadata {
+  display: flex;
+  align-items: center;
+  gap: 12px;
+}
+
+.video-format {
+  padding: 2px 8px;
   background-color: rgba(255, 255, 255, 0.1);
+  border-radius: 3px;
+  font-size: 12px;
 }
 
 /* Fullscreen adjustments */

commit 4d89cea62079c228aefdc410e385b1b99dfbb94f
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Wed Apr 9 19:28:04 2025 +0800

    better video display

diff --git a/src/components/panels/catalog/DetailView.jsx b/src/components/panels/catalog/DetailView.jsx
index d8d9e2a..0e2d638 100644
--- a/src/components/panels/catalog/DetailView.jsx
+++ b/src/components/panels/catalog/DetailView.jsx
@@ -186,8 +186,8 @@ const DetailView = ({
   }
   
   // Universal content wrapper to enforce containment
-  const ContentWrapper = ({ children, className = '' }) => (
-    <div className={`universal-content-wrapper ${className}`}>
+  const ContentWrapper = ({ children, className = '', fullWidth = false }) => (
+    <div className={`universal-content-wrapper ${className} ${fullWidth ? 'full-width' : ''}`}>
       {children}
     </div>
   );
@@ -404,6 +404,17 @@ const DetailView = ({
           )}
         </ContentWrapper>
       );
+    } else if (contentType.mimeType?.startsWith('video/')) {
+      console.log('Rendering video content:', contentType.mimeType);
+      return (
+        <div className="video-display-container">
+          <VideoPlayer 
+            hash={selectedItem.hash} 
+            contentType={contentType} 
+            content={contentData?.raw?.content || contentData?.raw}
+          />
+        </div>
+      );
     } else if (contentType.mimeType?.startsWith('audio/')) {
       return (
         <ContentWrapper className="audio-wrapper">
@@ -415,17 +426,6 @@ const DetailView = ({
           />
         </ContentWrapper>
       );
-    } else if (contentType.mimeType.startsWith('video/') || contentType.mimeType === 'video/quicktime') {
-      // Use our new VideoPlayer component for video content
-      return (
-        <ContentWrapper className="video-wrapper">
-          <VideoPlayer 
-            hash={selectedItem.hash} 
-            contentType={contentType.mimeType} 
-            content={selectedItem.content}
-          />
-        </ContentWrapper>
-      );
     } else if (contentType.mimeType === 'text/html') {
       // For HTML content, we'll fetch it and then render it
       return (
diff --git a/src/components/panels/catalog/detail-view.css b/src/components/panels/catalog/detail-view.css
index 05856ee..d0ee00b 100644
--- a/src/components/panels/catalog/detail-view.css
+++ b/src/components/panels/catalog/detail-view.css
@@ -100,6 +100,78 @@
   position: relative;
 }
 
+.universal-content-wrapper.full-width {
+  max-width: 100%;
+  width: 100%;
+}
+
+/* Video Display Container - new direct container */
+.video-display-container {
+  width: 100%;
+  padding: 0;
+  margin: 0 auto 20px;
+  background-color: transparent;
+  display: flex;
+  justify-content: center;
+  align-items: center;
+  overflow: visible;
+}
+
+.video-display-container .video-player-container {
+  width: 100%;
+  max-width: 800px;
+  padding: 0;
+  margin: 0 auto;
+  background-color: #000;
+  border-radius: 4px;
+  overflow: visible;
+}
+
+.video-display-container .video-wrapper {
+  width: 100%;
+  max-width: 100%;
+  height: auto;
+  border-radius: 4px;
+  overflow: visible;
+  background-color: #000;
+  display: flex;
+  justify-content: center;
+  align-items: center;
+}
+
+.video-display-container .video-player {
+  max-width: 100%;
+  max-height: 70vh;
+  height: auto !important;
+  width: auto !important;
+  display: block;
+  border-radius: 4px;
+  margin: 0 auto;
+}
+
+/* Video Content Styles */
+.video-content-wrapper {
+  padding: 0;
+  background-color: #000;
+  display: flex;
+  justify-content: center;
+  align-items: center;
+  margin-bottom: 20px;
+  width: 100%;
+  overflow: visible;
+  height: auto;
+  min-height: 300px;
+  border: none;
+}
+
+.video-content-wrapper .video-player-container {
+  width: 100%;
+  height: auto;
+  max-width: 100%;
+  min-height: 300px;
+  overflow: visible;
+}
+
 /* Image Content Styles */
 .image-wrapper {
   display: flex;
diff --git a/src/components/viewers/VideoPlayer.jsx b/src/components/viewers/VideoPlayer.jsx
index 989176f..785bb3e 100644
--- a/src/components/viewers/VideoPlayer.jsx
+++ b/src/components/viewers/VideoPlayer.jsx
@@ -1,5 +1,6 @@
 import React, { useState, useEffect, useRef } from 'react';
 import { ContentService } from '../../services/content-service';
+import './video-player.css';
 
 /**
  * VideoPlayer component for handling various video formats including QuickTime
@@ -12,7 +13,19 @@ const VideoPlayer = ({ content, contentType, hash }) => {
   const [retry, setRetry] = useState(0);
   const [downloadUrl, setDownloadUrl] = useState(null);
   const [isQuickTime, setIsQuickTime] = useState(false);
+  
+  // Video playback state
+  const [isPlaying, setIsPlaying] = useState(false);
+  const [currentTime, setCurrentTime] = useState(0);
+  const [duration, setDuration] = useState(0);
+  const [volume, setVolume] = useState(1);
+  const [isMuted, setIsMuted] = useState(false);
+  const [isFullscreen, setIsFullscreen] = useState(false);
+  const [isDraggingSeeker, setIsDraggingSeeker] = useState(false);
+  
   const videoRef = useRef(null);
+  const videoContainerRef = useRef(null);
+  const seekBarRef = useRef(null);
   
   useEffect(() => {
     setLoading(true);
@@ -189,6 +202,163 @@ const VideoPlayer = ({ content, contentType, hash }) => {
     };
   }, [content, contentType, hash, retry]);
   
+  // Toggle play/pause 
+  const togglePlay = () => {
+    if (videoRef.current) {
+      if (isPlaying) {
+        videoRef.current.pause();
+      } else {
+        videoRef.current.play();
+      }
+      setIsPlaying(!isPlaying);
+    }
+  };
+
+  // Toggle mute
+  const toggleMute = () => {
+    if (videoRef.current) {
+      videoRef.current.muted = !isMuted;
+      setIsMuted(!isMuted);
+    }
+  };
+
+  // Handle volume change
+  const handleVolumeChange = (e) => {
+    const newVolume = parseFloat(e.target.value);
+    if (videoRef.current) {
+      videoRef.current.volume = newVolume;
+      setVolume(newVolume);
+      setIsMuted(newVolume === 0);
+    }
+  };
+
+  // Handle fullscreen toggle
+  const toggleFullscreen = () => {
+    if (!document.fullscreenElement) {
+      if (videoContainerRef.current.requestFullscreen) {
+        videoContainerRef.current.requestFullscreen();
+      } else if (videoContainerRef.current.webkitRequestFullscreen) {
+        videoContainerRef.current.webkitRequestFullscreen();
+      } else if (videoContainerRef.current.msRequestFullscreen) {
+        videoContainerRef.current.msRequestFullscreen();
+      }
+      setIsFullscreen(true);
+    } else {
+      if (document.exitFullscreen) {
+        document.exitFullscreen();
+      } else if (document.webkitExitFullscreen) {
+        document.webkitExitFullscreen();
+      } else if (document.msExitFullscreen) {
+        document.msExitFullscreen();
+      }
+      setIsFullscreen(false);
+    }
+  };
+
+  // Format time to MM:SS
+  const formatTime = (timeInSeconds) => {
+    if (isNaN(timeInSeconds)) return '00:00';
+    
+    const minutes = Math.floor(timeInSeconds / 60);
+    const seconds = Math.floor(timeInSeconds % 60);
+    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
+  };
+
+  // Handle seeking when user drags the progress bar
+  const handleSeekBarMouseDown = (e) => {
+    setIsDraggingSeeker(true);
+    updateSeekPosition(e);
+  };
+
+  const handleSeekBarMouseMove = (e) => {
+    if (isDraggingSeeker) {
+      updateSeekPosition(e);
+    }
+  };
+
+  const handleSeekBarMouseUp = (e) => {
+    if (isDraggingSeeker) {
+      updateSeekPosition(e);
+      setIsDraggingSeeker(false);
+    }
+  };
+
+  // Handle clicks directly on the progress bar
+  const handleSeekBarClick = (e) => {
+    updateSeekPosition(e);
+  };
+
+  // Update video position based on seekbar interaction
+  const updateSeekPosition = (e) => {
+    if (!seekBarRef.current || !videoRef.current || duration === 0) return;
+    
+    const rect = seekBarRef.current.getBoundingClientRect();
+    const position = (e.clientX - rect.left) / rect.width;
+    const newTime = position * duration;
+    
+    // Update video current time
+    videoRef.current.currentTime = newTime;
+    setCurrentTime(newTime);
+  };
+
+  // Listen for video events to update UI state
+  useEffect(() => {
+    const videoElement = videoRef.current;
+    
+    if (!videoElement) return;
+    
+    const handleTimeUpdate = () => {
+      if (!isDraggingSeeker) {
+        setCurrentTime(videoElement.currentTime);
+      }
+    };
+    
+    const handleDurationChange = () => {
+      setDuration(videoElement.duration);
+    };
+    
+    const handlePlay = () => {
+      setIsPlaying(true);
+    };
+    
+    const handlePause = () => {
+      setIsPlaying(false);
+    };
+    
+    const handleVolumeUpdate = () => {
+      setVolume(videoElement.volume);
+      setIsMuted(videoElement.muted);
+    };
+    
+    const handleFullscreenChange = () => {
+      setIsFullscreen(!!document.fullscreenElement);
+    };
+    
+    // Add event listeners
+    videoElement.addEventListener('timeupdate', handleTimeUpdate);
+    videoElement.addEventListener('durationchange', handleDurationChange);
+    videoElement.addEventListener('play', handlePlay);
+    videoElement.addEventListener('pause', handlePause);
+    videoElement.addEventListener('volumechange', handleVolumeUpdate);
+    document.addEventListener('fullscreenchange', handleFullscreenChange);
+    document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
+    document.addEventListener('mousemove', handleSeekBarMouseMove);
+    document.addEventListener('mouseup', handleSeekBarMouseUp);
+    
+    // Clean up event listeners
+    return () => {
+      videoElement.removeEventListener('timeupdate', handleTimeUpdate);
+      videoElement.removeEventListener('durationchange', handleDurationChange);
+      videoElement.removeEventListener('play', handlePlay);
+      videoElement.removeEventListener('pause', handlePause);
+      videoElement.removeEventListener('volumechange', handleVolumeUpdate);
+      document.removeEventListener('fullscreenchange', handleFullscreenChange);
+      document.removeEventListener('webkitfullscreenchange', handleFullscreenChange);
+      document.removeEventListener('mousemove', handleSeekBarMouseMove);
+      document.removeEventListener('mouseup', handleSeekBarMouseUp);
+    };
+  }, [isDraggingSeeker]);
+  
   // Handle video playback errors
   const handleVideoError = (e) => {
     console.error('Video playback error:', e);
@@ -257,25 +427,95 @@ const VideoPlayer = ({ content, contentType, hash }) => {
           </div>
         </div>
       ) : (
-        <div className="video-wrapper">
+        <div className="video-wrapper" ref={videoContainerRef}>
           <video 
             ref={videoRef}
             src={videoUrl} 
-            controls 
-            autoPlay={false}
+            onClick={togglePlay}
             onError={handleVideoError}
             className="video-player"
+            width="auto"
+            height="auto"
+            style={{
+              maxWidth: "100%", 
+              width: "auto",
+              height: "auto",
+              maxHeight: "70vh",
+              margin: "0 auto",
+              display: "block"
+            }}
           />
-          <div className="video-controls">
-            {downloadUrl && (
-              <a 
-                href={downloadUrl} 
-                download={`video-${hash?.substring(0, 8) || 'download'}.${getVideoExtension(contentType)}`} 
-                className="download-link"
-              >
-                Download Video
-              </a>
-            )}
+          
+          <div className="custom-video-controls">
+            <div 
+              className="video-progress-container" 
+              ref={seekBarRef}
+              onClick={handleSeekBarClick}
+              onMouseDown={handleSeekBarMouseDown}
+            >
+              <div className="video-progress-background"></div>
+              <div 
+                className="video-progress-bar" 
+                style={{ width: `${(currentTime / duration) * 100}%` }}
+              ></div>
+              <div 
+                className="video-progress-handle"
+                style={{ left: `${(currentTime / duration) * 100}%` }}
+              ></div>
+            </div>
+            
+            <div className="video-controls-bottom">
+              <div className="video-controls-left">
+                <button className="video-control-button" onClick={togglePlay}>
+                  {isPlaying ? (
+                    <span className="control-icon">❚❚</span>
+                  ) : (
+                    <span className="control-icon">▶</span>
+                  )}
+                </button>
+                
+                <div className="video-volume-control">
+                  <button className="video-control-button" onClick={toggleMute}>
+                    {isMuted ? (
+                      <span className="control-icon">🔇</span>
+                    ) : (
+                      <span className="control-icon">🔊</span>
+                    )}
+                  </button>
+                  <input 
+                    type="range" 
+                    min="0" 
+                    max="1" 
+                    step="0.1" 
+                    value={isMuted ? 0 : volume}
+                    onChange={handleVolumeChange}
+                    className="volume-slider"
+                  />
+                </div>
+                
+                <div className="video-time-display">
+                  <span>{formatTime(currentTime)}</span>
+                  <span> / </span>
+                  <span>{formatTime(duration)}</span>
+                </div>
+              </div>
+              
+              <div className="video-controls-right">
+                <button className="video-control-button" onClick={toggleFullscreen}>
+                  <span className="control-icon">{isFullscreen ? '⤓' : '⤒'}</span>
+                </button>
+                
+                {downloadUrl && (
+                  <a 
+                    href={downloadUrl} 
+                    download={`video-${hash?.substring(0, 8) || 'download'}.${getVideoExtension(contentType)}`} 
+                    className="download-link"
+                  >
+                    <span className="control-icon">⬇</span>
+                  </a>
+                )}
+              </div>
+            </div>
           </div>
         </div>
       )}
diff --git a/src/components/viewers/video-player.css b/src/components/viewers/video-player.css
index c3f0bc5..c9da415 100644
--- a/src/components/viewers/video-player.css
+++ b/src/components/viewers/video-player.css
@@ -1,6 +1,6 @@
 /* Video Player Component Styles */
 
-.video-container {
+.video-player-container {
   width: 100%;
   position: relative;
   background-color: #000;
@@ -8,13 +8,20 @@
   overflow: hidden;
   box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
   margin-bottom: 16px;
+  display: flex;
+  flex-direction: column;
+  align-items: center;
+  justify-content: center;
 }
 
 .video-player {
-  width: 100%;
+  max-width: 100%;
+  width: auto !important;
   max-height: 70vh;
   display: block;
   background-color: #000;
+  object-fit: contain;
+  margin: 0 auto;
 }
 
 .video-loading,
@@ -99,131 +106,315 @@ video::-webkit-media-controls-play-button {
   display: flex;
   align-items: center;
   justify-content: center;
-  background-color: #21252b;
   padding: 20px;
+  background-color: #1a1a1a;
+  border-radius: 4px;
+  color: white;
+  text-align: center;
 }
 
 .quicktime-message {
-  max-width: 600px;
-  background-color: #2c313a;
-  border-radius: 8px;
-  border: 1px solid #3a3f4b;
-  padding: 25px;
-  color: #e0e0e0;
-  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
+  max-width: 500px;
+  padding: 20px;
+  background-color: rgba(0, 0, 0, 0.3);
+  border-radius: 6px;
 }
 
 .quicktime-message h3 {
-  font-size: 1.3rem;
-  font-weight: 600;
-  margin: 0 0 15px 0;
-  color: #e6e6e6;
+  color: #f8f9fa;
+  margin-bottom: 15px;
 }
 
 .quicktime-note {
-  color: #bbb;
   font-style: italic;
-  font-size: 0.9rem;
-  margin-bottom: 20px;
+  color: #adb5bd;
+  margin: 10px 0;
+  font-size: 0.9em;
 }
 
 .quicktime-options {
   margin-top: 20px;
+  text-align: left;
 }
 
 .quicktime-options h4 {
-  font-size: 1.1rem;
   margin-bottom: 10px;
+  color: #f8f9fa;
 }
 
 .quicktime-options ol {
   padding-left: 20px;
-  margin: 0;
 }
 
 .quicktime-options li {
   margin-bottom: 15px;
 }
 
-.quicktime-options li strong {
-  color: #e0e0e0;
-  display: block;
-  margin-bottom: 5px;
-}
-
 .quicktime-options p {
   margin: 5px 0;
-  color: #bbb;
-  font-size: 0.9rem;
+  color: #ced4da;
+  font-size: 0.9em;
 }
 
-.download-button {
+.download-button,
+.download-link {
   display: inline-block;
-  background-color: #0366d6;
+  padding: 8px 16px;
+  background-color: #007bff;
   color: white;
   text-decoration: none;
-  padding: 8px 16px;
   border-radius: 4px;
   margin-top: 10px;
-  font-size: 0.9rem;
+  font-weight: 500;
+  border: none;
+  cursor: pointer;
   transition: background-color 0.2s;
 }
 
-.download-button:hover {
-  background-color: #0078ff;
+.download-button:hover,
+.download-link:hover {
+  background-color: #0069d9;
   text-decoration: none;
+  color: white;
 }
 
-/* Standard video player styling */
-.video-player-container {
+/* Custom Video Controls */
+.video-wrapper {
+  position: relative;
   width: 100%;
-  height: 100%;
+  background-color: #000;
+  overflow: hidden;
+  border-radius: 4px;
   display: flex;
-  flex-direction: column;
   justify-content: center;
   align-items: center;
+  height: auto;
+  min-height: 300px;
+  max-height: 70vh;
 }
 
-.video-wrapper {
+.video-player {
   width: 100%;
-  max-width: 800px;
   height: auto;
-  margin: 0 auto;
+  display: block;
+  cursor: pointer;
+  object-fit: contain;
+  max-width: 100%;
+  max-height: 100%;
 }
 
-.video-player {
+.custom-video-controls {
+  position: absolute;
+  bottom: 0;
+  left: 0;
+  right: 0;
+  background: linear-gradient(to top, rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0));
+  padding: 10px;
+  opacity: 0;
+  transition: opacity 0.3s ease;
+}
+
+.video-wrapper:hover .custom-video-controls,
+.custom-video-controls:hover {
+  opacity: 1;
+}
+
+.video-progress-container {
   width: 100%;
-  height: auto;
-  max-height: 80vh;
-  border-radius: 4px;
+  height: 10px;
+  background-color: rgba(255, 255, 255, 0.2);
+  border-radius: 5px;
+  margin-bottom: 10px;
+  position: relative;
+  cursor: pointer;
 }
 
-.video-controls {
-  margin-top: 10px;
-  text-align: center;
+.video-progress-background {
+  position: absolute;
+  top: 0;
+  left: 0;
+  width: 100%;
+  height: 100%;
+  border-radius: 5px;
 }
 
-.download-link {
-  color: #0366d6;
-  text-decoration: none;
-  font-size: 0.9rem;
+.video-progress-bar {
+  position: absolute;
+  top: 0;
+  left: 0;
+  height: 100%;
+  background-color: #007bff;
+  border-radius: 5px;
+  transition: width 0.1s ease-out;
 }
 
-.download-link:hover {
-  text-decoration: underline;
+.video-progress-handle {
+  position: absolute;
+  top: 50%;
+  transform: translate(-50%, -50%);
+  width: 16px;
+  height: 16px;
+  background-color: white;
+  border-radius: 50%;
+  box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
+  cursor: pointer;
+  z-index: 2;
+  opacity: 0;
+  transition: opacity 0.2s ease;
+}
+
+.video-progress-container:hover .video-progress-handle {
+  opacity: 1;
 }
 
-.video-loading {
+.video-controls-bottom {
+  display: flex;
+  justify-content: space-between;
+  align-items: center;
+  color: white;
+  padding: 5px 0;
+}
+
+.video-controls-left, 
+.video-controls-right {
+  display: flex;
+  align-items: center;
+  gap: 10px;
+}
+
+.video-control-button {
+  background: transparent;
+  border: none;
+  color: white;
+  cursor: pointer;
+  width: 32px;
+  height: 32px;
   display: flex;
   align-items: center;
   justify-content: center;
-  flex-direction: column;
-  height: 100%;
-  color: #ccc;
+  border-radius: 50%;
+  transition: background-color 0.2s;
 }
 
-.video-error {
-  color: #e24c4c;
-  padding: 20px;
-  text-align: center;
+.video-control-button:hover {
+  background-color: rgba(255, 255, 255, 0.1);
+}
+
+.control-icon {
+  font-size: 18px;
+}
+
+.video-volume-control {
+  display: flex;
+  align-items: center;
+  gap: 5px;
+}
+
+.volume-slider {
+  width: 70px;
+  cursor: pointer;
+  -webkit-appearance: none;
+  appearance: none;
+  height: 4px;
+  background: rgba(255, 255, 255, 0.3);
+  border-radius: 2px;
+  outline: none;
+}
+
+.volume-slider::-webkit-slider-thumb {
+  -webkit-appearance: none;
+  appearance: none;
+  width: 12px;
+  height: 12px;
+  background: white;
+  border-radius: 50%;
+  cursor: pointer;
+  transition: background-color 0.2s;
+}
+
+.volume-slider::-moz-range-thumb {
+  width: 12px;
+  height: 12px;
+  background: white;
+  border-radius: 50%;
+  cursor: pointer;
+  border: none;
+  transition: background-color 0.2s;
+}
+
+.volume-slider:hover::-webkit-slider-thumb {
+  background: #007bff;
+}
+
+.volume-slider:hover::-moz-range-thumb {
+  background: #007bff;
+}
+
+.video-time-display {
+  font-size: 14px;
+  margin-left: 10px;
+  color: rgba(255, 255, 255, 0.8);
+}
+
+.video-time-display span {
+  display: inline-block;
+  vertical-align: middle;
+}
+
+/* Styles for download link in control bar */
+.video-controls-right .download-link {
+  background-color: transparent;
+  padding: 5px;
+  margin: 0;
+  border-radius: 50%;
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  width: 32px;
+  height: 32px;
+}
+
+.video-controls-right .download-link:hover {
+  background-color: rgba(255, 255, 255, 0.1);
+}
+
+/* Fullscreen adjustments */
+:fullscreen .video-wrapper {
+  width: 100vw;
+  height: 100vh;
+}
+
+:fullscreen .video-player {
+  height: 100vh;
+  object-fit: contain;
+}
+
+:-webkit-full-screen .video-wrapper {
+  width: 100vw;
+  height: 100vh;
+}
+
+:-webkit-full-screen .video-player {
+  height: 100vh;
+  object-fit: contain;
+}
+
+/* Handle small screens */
+@media (max-width: 576px) {
+  .video-volume-control {
+    display: none;
+  }
+  
+  .video-time-display {
+    font-size: 12px;
+  }
+  
+  .control-icon {
+    font-size: 16px;
+  }
+  
+  .video-control-button {
+    width: 28px;
+    height: 28px;
+  }
 }

commit b746e7f9fb3908b146b079222f70f6c3f9babc73
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Wed Apr 9 19:06:06 2025 +0800

    new video viewer

diff --git a/src/components/panels/catalog/DetailView.jsx b/src/components/panels/catalog/DetailView.jsx
index b465315..d8d9e2a 100644
--- a/src/components/panels/catalog/DetailView.jsx
+++ b/src/components/panels/catalog/DetailView.jsx
@@ -1,5 +1,5 @@
 import React, { useState, useEffect, useRef } from 'react';
-import { getSimpleContentType, getContentTypeDisplay } from './utils';
+import { getSimpleContentType, getContentTypeDisplay, determineCorrectContentType } from './utils';
 import { ContentService } from '../../../services/content-service';
 import { processContent, isImageType } from '../../../utils/content-utils';
 import VideoPlayer from '../../viewers/VideoPlayer';
@@ -532,9 +532,7 @@ const DetailView = ({
           <div className="info-section">
             <p><strong>Hash:</strong> {selectedItem.hash}</p>
             <p><strong>Type:</strong> {
-              selectedItem.contentType?.mimeType 
-                ? getFormattedContentType(selectedItem.contentType.mimeType)
-                : 'Unknown'
+              determineCorrectContentType(selectedItem)
             }</p>
             <p><strong>Date:</strong> {selectedItem.timestamp || 'Unknown'}</p>
           </div>
diff --git a/src/components/panels/catalog/utils.js b/src/components/panels/catalog/utils.js
index 4b1bdeb..2819450 100644
--- a/src/components/panels/catalog/utils.js
+++ b/src/components/panels/catalog/utils.js
@@ -43,3 +43,48 @@ export const getContentTypeDisplay = () => ({
   'css': 'CSS',
   'svg': 'SVG'
 });
+
+// Format content type for display in the consistent "TYPE (mime/type)" format
+export const getFormattedContentType = (mimeType) => {
+  const simpleType = getSimpleContentType(mimeType);
+  
+  // Special case for quicktime - check if it's actually an MP4
+  if (mimeType === 'video/quicktime' && simpleType === 'quicktime') {
+    // Display MP4 for any quicktime content that looks like it should be MP4
+    return `MP4 (video/mp4)`;
+  }
+  
+  const typeDisplay = getContentTypeDisplay()[simpleType] || simpleType?.toUpperCase() || 'UNKNOWN';
+  return `${typeDisplay} (${mimeType})`;
+};
+
+// Special function to determine the correct content type for display
+// This handles special cases like MP4 files being mistakenly labeled as QuickTime
+export const determineCorrectContentType = (item) => {
+  if (!item?.contentType?.mimeType) {
+    return 'Unknown';
+  }
+  
+  const mimeType = item.contentType.mimeType;
+  const filename = item.name || '';
+  const hash = item.hash || '';
+  
+  // Special handling for QuickTime videos that are actually MP4s
+  if (mimeType === 'video/quicktime') {
+    // Check if filename suggests MP4
+    if ((filename && filename.toLowerCase().includes('.mp4')) ||
+        (hash && hash.toLowerCase().includes('mp4'))) {
+      console.log(`Correcting content type from QuickTime to MP4 for item: ${filename || hash}`);
+      return 'MP4 (video/mp4)';
+    }
+  }
+  
+  // If it's already MP4, ensure it displays as MP4
+  if (mimeType === 'video/mp4' || 
+      (filename && filename.toLowerCase().endsWith('.mp4'))) {
+    return 'MP4 (video/mp4)';
+  }
+  
+  // For all other content types, use the standard formatting
+  return getFormattedContentType(mimeType);
+};
diff --git a/src/components/viewers/VideoPlayer.jsx b/src/components/viewers/VideoPlayer.jsx
index 57a2488..989176f 100644
--- a/src/components/viewers/VideoPlayer.jsx
+++ b/src/components/viewers/VideoPlayer.jsx
@@ -52,6 +52,35 @@ const VideoPlayer = ({ content, contentType, hash }) => {
     };
     
     const processVideoContent = (videoContent, vidContentType = contentType) => {
+      console.log('Processing video with content type:', vidContentType);
+      
+      // Check if filename suggests MP4 format regardless of content type
+      let isMp4ByFilename = false;
+      if (hash && hash.toLowerCase().includes('mp4')) {
+        isMp4ByFilename = true;
+        console.log('MP4 detected by filename reference in hash');
+      }
+      
+      // Force MP4 detection for filenames explicitly containing MP4
+      if (isMp4ByFilename) {
+        setIsQuickTime(false);
+        
+        // For Buffer JSON content
+        if (videoContent && videoContent.type === 'Buffer' && Array.isArray(videoContent.data)) {
+          try {
+            const array = new Uint8Array(videoContent.data);
+            const blob = new Blob([array], { type: 'video/mp4' });
+            const url = URL.createObjectURL(blob);
+            setVideoUrl(url);
+            setDownloadUrl(url);
+            setLoading(false);
+            return;
+          } catch (err) {
+            console.error('Error processing MP4 video buffer:', err);
+          }
+        }
+      }
+      
       // Check if this is a QuickTime video
       const isQuickTimeVideo = 
         (vidContentType?.mimeType?.includes('quicktime') || 
@@ -61,18 +90,58 @@ const VideoPlayer = ({ content, contentType, hash }) => {
            vidContentType.includes('mov')
          )));
       
-      setIsQuickTime(isQuickTimeVideo);
+      // Override for MP4 files incorrectly detected as QuickTime
+      const isMp4Video = 
+        (vidContentType?.mimeType?.includes('mp4') || 
+         vidContentType?.extension?.toLowerCase() === 'mp4' ||
+         (typeof vidContentType === 'string' && (
+           vidContentType.includes('mp4')
+         )));
+      
+      // Set QuickTime flag only if we're sure it's not an MP4
+      setIsQuickTime(isQuickTimeVideo && !isMp4Video && !isMp4ByFilename);
       
       // For Buffer JSON content
       if (videoContent && videoContent.type === 'Buffer' && Array.isArray(videoContent.data)) {
         try {
           const array = new Uint8Array(videoContent.data);
           
-          // Always create download URL for QuickTime videos as a fallback
-          if (isQuickTimeVideo) {
-            const blob = new Blob([array], { type: 'video/quicktime' });
-            const downloadUrl = URL.createObjectURL(blob);
-            setDownloadUrl(downloadUrl);
+          // Check for MP4 signatures
+          let isMp4BySignature = false;
+          if (array.length > 12) {
+            // Check for ftyp box which indicates MP4 format
+            for (let i = 0; i < Math.min(50, array.length - 8); i++) {
+              if (array[i] === 0x66 && array[i+1] === 0x74 && array[i+2] === 0x79 && array[i+3] === 0x70) {
+                console.log('MP4 signature detected in video data at position', i);
+                isMp4BySignature = true;
+                break;
+              }
+            }
+          }
+          
+          // If we detected an MP4 signature, override QuickTime setting
+          if (isMp4BySignature) {
+            setIsQuickTime(false);
+          }
+          
+          // Create the appropriate content type for the blob
+          let blobType = 'video/mp4';
+          if (isQuickTimeVideo && !isMp4BySignature && !isMp4Video && !isMp4ByFilename) {
+            blobType = 'video/quicktime';
+          }
+          
+          // Always create download URL for videos as a fallback
+          const blob = new Blob([array], { type: blobType });
+          const downloadUrl = URL.createObjectURL(blob);
+          setDownloadUrl(downloadUrl);
+          
+          // Use MP4 content type if we have evidence it's an MP4
+          if (isMp4BySignature || isMp4Video || isMp4ByFilename) {
+            const mp4Blob = new Blob([array], { type: 'video/mp4' });
+            const mp4Url = URL.createObjectURL(mp4Blob);
+            setVideoUrl(mp4Url);
+            setLoading(false);
+            return;
           }
           
           const url = ContentService.getDataUrl({ 
@@ -131,65 +200,83 @@ const VideoPlayer = ({ content, contentType, hash }) => {
     }
   };
   
-  if (loading) {
-    return (
-      <div className="video-loading">
-        <div className="spinner"></div>
-        <p>Loading video...</p>
-      </div>
-    );
-  }
+  const getVideoExtension = (contentType) => {
+    if (contentType?.extension) {
+      return contentType.extension;
+    } else if (contentType?.mimeType) {
+      const mimeTypeParts = contentType.mimeType.split('/');
+      if (mimeTypeParts.length > 1) {
+        return mimeTypeParts[1];
+      }
+    }
+    return 'mov';
+  };
   
-  if (error) {
-    return (
-      <div className="video-error">
-        <p>{error}</p>
-        {isQuickTime && downloadUrl && (
-          <div className="mt-4">
-            <p className="text-sm mt-2">QuickTime videos require specific codecs which may not be available in all browsers.</p>
-            <a 
-              href={downloadUrl} 
-              download={`video-${Date.now()}.mov`}
-              className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 inline-block mt-2"
-            >
-              Download Video File
+  return (
+    <div className="video-player-container">
+      {loading ? (
+        <div className="video-loading">Loading video...</div>
+      ) : error ? (
+        <div className="video-error">
+          <p>{error}</p>
+          {downloadUrl && (
+            <a href={downloadUrl} download className="download-link">
+              Download Video
             </a>
-            <p className="text-xs mt-2">You can download the file and play it in a media player that supports QuickTime format.</p>
+          )}
+        </div>
+      ) : isQuickTime ? (
+        <div className="quicktime-container">
+          <div className="quicktime-message">
+            <h3>QuickTime Video Format</h3>
+            <p>This QuickTime video could not be played in the browser. The format may not be supported by your browser.</p>
+            <p className="quicktime-note">QuickTime videos require specific codecs which may not be available in all browsers.</p>
+            
+            <div className="quicktime-options">
+              <h4>Options:</h4>
+              <ol>
+                <li>
+                  <strong>Download and Play Locally</strong>
+                  <p>You can download the file and play it in a media player that supports QuickTime format.</p>
+                  {downloadUrl && (
+                    <a 
+                      href={downloadUrl} 
+                      download={`video-${hash?.substring(0, 8) || 'download'}.mov`} 
+                      className="download-button"
+                    >
+                      Download Video File
+                    </a>
+                  )}
+                </li>
+                <li>
+                  <strong>Try Another Browser</strong>
+                  <p>Some browsers may have better support for QuickTime videos.</p>
+                </li>
+              </ol>
+            </div>
+          </div>
+        </div>
+      ) : (
+        <div className="video-wrapper">
+          <video 
+            ref={videoRef}
+            src={videoUrl} 
+            controls 
+            autoPlay={false}
+            onError={handleVideoError}
+            className="video-player"
+          />
+          <div className="video-controls">
+            {downloadUrl && (
+              <a 
+                href={downloadUrl} 
+                download={`video-${hash?.substring(0, 8) || 'download'}.${getVideoExtension(contentType)}`} 
+                className="download-link"
+              >
+                Download Video
+              </a>
+            )}
           </div>
-        )}
-        <button 
-          className="btn btn-small mt-3" 
-          onClick={() => setRetry(prev => prev + 1)}
-        >
-          Retry
-        </button>
-      </div>
-    );
-  }
-  
-  return (
-    <div className="video-container">
-      <video 
-        ref={videoRef}
-        src={videoUrl}
-        controls
-        autoPlay={false}
-        className="video-player"
-        onError={handleVideoError}
-      >
-        Your browser does not support the video tag.
-      </video>
-      
-      {isQuickTime && downloadUrl && (
-        <div className="download-button-container mt-2">
-          <a 
-            href={downloadUrl} 
-            download={`video-${Date.now()}.mov`}
-            className="download-button"
-            title="Download video file"
-          >
-            ⬇️ Download
-          </a>
         </div>
       )}
     </div>
diff --git a/src/components/viewers/video-player.css b/src/components/viewers/video-player.css
index 6b0d8f0..c3f0bc5 100644
--- a/src/components/viewers/video-player.css
+++ b/src/components/viewers/video-player.css
@@ -91,3 +91,139 @@ video::-webkit-media-controls-play-button {
   font-weight: bold;
   margin-right: 8px;
 }
+
+/* QuickTime specific styling */
+.quicktime-container {
+  width: 100%;
+  height: 100%;
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  background-color: #21252b;
+  padding: 20px;
+}
+
+.quicktime-message {
+  max-width: 600px;
+  background-color: #2c313a;
+  border-radius: 8px;
+  border: 1px solid #3a3f4b;
+  padding: 25px;
+  color: #e0e0e0;
+  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
+}
+
+.quicktime-message h3 {
+  font-size: 1.3rem;
+  font-weight: 600;
+  margin: 0 0 15px 0;
+  color: #e6e6e6;
+}
+
+.quicktime-note {
+  color: #bbb;
+  font-style: italic;
+  font-size: 0.9rem;
+  margin-bottom: 20px;
+}
+
+.quicktime-options {
+  margin-top: 20px;
+}
+
+.quicktime-options h4 {
+  font-size: 1.1rem;
+  margin-bottom: 10px;
+}
+
+.quicktime-options ol {
+  padding-left: 20px;
+  margin: 0;
+}
+
+.quicktime-options li {
+  margin-bottom: 15px;
+}
+
+.quicktime-options li strong {
+  color: #e0e0e0;
+  display: block;
+  margin-bottom: 5px;
+}
+
+.quicktime-options p {
+  margin: 5px 0;
+  color: #bbb;
+  font-size: 0.9rem;
+}
+
+.download-button {
+  display: inline-block;
+  background-color: #0366d6;
+  color: white;
+  text-decoration: none;
+  padding: 8px 16px;
+  border-radius: 4px;
+  margin-top: 10px;
+  font-size: 0.9rem;
+  transition: background-color 0.2s;
+}
+
+.download-button:hover {
+  background-color: #0078ff;
+  text-decoration: none;
+}
+
+/* Standard video player styling */
+.video-player-container {
+  width: 100%;
+  height: 100%;
+  display: flex;
+  flex-direction: column;
+  justify-content: center;
+  align-items: center;
+}
+
+.video-wrapper {
+  width: 100%;
+  max-width: 800px;
+  height: auto;
+  margin: 0 auto;
+}
+
+.video-player {
+  width: 100%;
+  height: auto;
+  max-height: 80vh;
+  border-radius: 4px;
+}
+
+.video-controls {
+  margin-top: 10px;
+  text-align: center;
+}
+
+.download-link {
+  color: #0366d6;
+  text-decoration: none;
+  font-size: 0.9rem;
+}
+
+.download-link:hover {
+  text-decoration: underline;
+}
+
+.video-loading {
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  flex-direction: column;
+  height: 100%;
+  color: #ccc;
+}
+
+.video-error {
+  color: #e24c4c;
+  padding: 20px;
+  text-align: center;
+}
diff --git a/src/utils/content_type_detector.js b/src/utils/content_type_detector.js
index 24b2b69..b676bff 100644
--- a/src/utils/content_type_detector.js
+++ b/src/utils/content_type_detector.js
@@ -30,7 +30,16 @@ const SIGNATURES = new Map([
     [new Uint8Array([0x52, 0x49, 0x46, 0x46]), 'audio/wav'], // WAV (RIFF header)
     [new Uint8Array([0x66, 0x4C, 0x61, 0x43]), 'audio/flac'], // FLAC
     [new Uint8Array([0x4F, 0x67, 0x67, 0x53]), 'audio/ogg'], // OGG
-    [new Uint8Array([0x4D, 0x34, 0x41, 0x20]), 'audio/m4a'] // M4A
+    [new Uint8Array([0x4D, 0x34, 0x41, 0x20]), 'audio/m4a'], // M4A
+    // Video file signatures
+    [new Uint8Array([0x00, 0x00, 0x00, 0x18, 0x66, 0x74, 0x79, 0x70]), 'video/mp4'], // MP4 (ftyp box)
+    [new Uint8Array([0x00, 0x00, 0x00, 0x1C, 0x66, 0x74, 0x79, 0x70]), 'video/mp4'], // MP4 variant
+    [new Uint8Array([0x00, 0x00, 0x00, 0x20, 0x66, 0x74, 0x79, 0x70]), 'video/mp4'], // MP4 variant
+    [new Uint8Array([0x66, 0x74, 0x79, 0x70, 0x6D, 0x70, 0x34]), 'video/mp4'], // MP4 (ftyp with mp4 in name)
+    [new Uint8Array([0x66, 0x74, 0x79, 0x70, 0x69, 0x73, 0x6F, 0x6D]), 'video/mp4'], // MP4 ISO Base Media
+    [new Uint8Array([0x66, 0x74, 0x79, 0x70, 0x4D, 0x53, 0x4E, 0x56]), 'video/mp4'], // MP4 variant
+    [new Uint8Array([0x1A, 0x45, 0xDF, 0xA3]), 'video/webm'], // WebM
+    [new Uint8Array([0x00, 0x00, 0x00, 0x14, 0x66, 0x74, 0x79, 0x70, 0x71, 0x74]), 'video/quicktime'] // QuickTime
   ]);
 
   // Audio tag patterns for text-based content detection
@@ -75,7 +84,10 @@ const SIGNATURES = new Map([
     'audio/x-m4a': 'm4a',
     'audio/mp4': 'm4a',
     'audio/aac': 'aac',
-    'audio/x-aac': 'aac'
+    'audio/x-aac': 'aac',
+    'video/mp4': 'mp4',
+    'video/webm': 'webm',
+    'video/quicktime': 'mov'
   };
 
   function startsWith(content, signature) {
@@ -93,11 +105,97 @@ const SIGNATURES = new Map([
       : 'application/octet-stream';
   }
 
+  function isBinaryContent(content) {
+    // Check if content is a binary format
+    if (content instanceof Uint8Array || content instanceof ArrayBuffer) {
+      return true;
+    }
+    
+    // Check Buffer-like objects (Node.js Buffer JSON format)
+    if (typeof content === 'object' && content !== null) {
+      // Check for Node.js Buffer JSON format
+      if (content.type === 'Buffer' && Array.isArray(content.data)) {
+        return true;
+      }
+      
+      // Check for buffer property (ArrayBuffer view objects)
+      if (content.buffer instanceof ArrayBuffer) {
+        return true;
+      }
+    }
+    
+    // Check for stringified Buffer JSON
+    if (typeof content === 'string') {
+      try {
+        // Only try to parse if it looks like a potential Buffer JSON
+        if (content.includes('"type":"Buffer"') && content.includes('"data":[')) {
+          const parsed = JSON.parse(content);
+          if (parsed && parsed.type === 'Buffer' && Array.isArray(parsed.data)) {
+            return true;
+          }
+        }
+      } catch (e) {
+        // Ignore parsing errors
+      }
+    }
+    
+    return false;
+  }
+
+  // Special detection for MP4 files that might be misidentified
+  function detectVideoFormat(content) {
+    // For Buffer JSON objects with sufficient data for analysis
+    if (typeof content === 'object' && content !== null && 
+        content.type === 'Buffer' && Array.isArray(content.data) && 
+        content.data.length > 12) {
+      
+      const data = content.data;
+      
+      // Check for MP4 ftyp box markers
+      // These can appear at different offsets, so we scan the first few bytes
+      for (let i = 0; i < Math.min(32, data.length - 8); i++) {
+        // Check for 'ftyp' marker which indicates an MP4 container
+        if (data[i] === 0x66 && data[i+1] === 0x74 && data[i+2] === 0x79 && data[i+3] === 0x70) {
+          // Check for specific MP4 types in the next 4 bytes
+          // Common values: mp42, isom, avc1, dash
+          if (i + 7 < data.length) {
+            const fourCC = String.fromCharCode(data[i+4], data[i+5], data[i+6], data[i+7]);
+            
+            if (fourCC === 'mp42' || fourCC === 'mp41' || fourCC === 'avc1' || 
+                fourCC === 'isom' || fourCC === 'iso2' || fourCC === 'dash') {
+              return {
+                mimeType: 'video/mp4',
+                extension: 'mp4',
+                isValid: true,
+                isBlob: true,
+                detectionMethod: 'ftyp-detection'
+              };
+            }
+            
+            // Check for QuickTime markers
+            if (fourCC === 'qt  ' || fourCC === 'moov') {
+              return {
+                mimeType: 'video/quicktime',
+                extension: 'mov',
+                isValid: true,
+                isBlob: true,
+                detectionMethod: 'ftyp-detection'
+              };
+            }
+          }
+        }
+      }
+    }
+    
+    return null;
+  }
+
   function detectContentType(content) {
     if (!content) return { 
       mimeType: 'application/octet-stream', 
       extension: '', 
-      isValid: false 
+      isValid: false,
+      detectionMethod: 'unknown'
     };
 
     if (typeof content === 'string') {
@@ -108,7 +206,8 @@ const SIGNATURES = new Map([
         return { 
           mimeType: 'text/x-mermaid', 
           extension: 'mmd', 
-          isValid: true 
+          isValid: true,
+          detectionMethod: 'mermaid'
         };
       }
       
@@ -117,7 +216,8 @@ const SIGNATURES = new Map([
         return { 
           mimeType: 'text/vnd.graphviz', 
           extension: 'dot', 
-          isValid: true 
+          isValid: true,
+          detectionMethod: 'graphviz'
         };
       }
       
@@ -126,7 +226,8 @@ const SIGNATURES = new Map([
         return { 
           mimeType: 'text/x-plantuml', 
           extension: 'puml', 
-          isValid: true 
+          isValid: true,
+          detectionMethod: 'plantuml'
         };
       }
       
@@ -137,13 +238,15 @@ const SIGNATURES = new Map([
           return { 
             mimeType: 'application/json', 
             extension: 'json', 
-            isValid: true 
+            isValid: true,
+            detectionMethod: 'json'
           };
         } catch {
           return { 
             mimeType: 'text/plain', 
             extension: 'txt', 
-            isValid: false 
+            isValid: false,
+            detectionMethod: 'unknown'
           };
         }
       }
@@ -153,7 +256,8 @@ const SIGNATURES = new Map([
         return { 
           mimeType: 'application/xml', 
           extension: 'xml', 
-          isValid: true 
+          isValid: true,
+          detectionMethod: 'xml'
         };
       }
       
@@ -163,7 +267,8 @@ const SIGNATURES = new Map([
           return { 
             mimeType: pattern.mimeType, 
             extension: EXTENSION_MAP[pattern.mimeType], 
-            isValid: true 
+            isValid: true,
+            detectionMethod: 'audio-text'
           };
         }
       }
@@ -172,23 +277,96 @@ const SIGNATURES = new Map([
       return { 
         mimeType: 'text/plain', 
         extension: 'txt', 
-        isValid: trimmedContent.length > 0 
+        isValid: trimmedContent.length > 0,
+        detectionMethod: 'plain-text'
       };
     }
 
     if (content instanceof Uint8Array) {
       const mimeType = detectBySignature(content);
+      console.log(`Detected by signature: ${mimeType || 'unknown'}`);
+      
+      let extension = EXTENSION_MAP[mimeType];
+      let isValid = true;
+      let isBlob = false;
+      let detectionMethod = 'signature';
+      
+      // For binary content that couldn't be identified by signature
+      if (mimeType === null || mimeType === undefined) {
+        // First check if it's a common binary format
+        if (isBinaryContent(content)) {
+          isBlob = true;
+          
+          // Special video format detection with extension-based approach
+          if (typeof content === 'object' && content.name) {
+            const filenameLower = content.name.toLowerCase();
+            const extMatch = filenameLower.match(/\.([a-z0-9]+)$/);
+            
+            if (extMatch) {
+              const ext = extMatch[1];
+              
+              // Check for video extensions
+              if (ext === 'mp4') {
+                detectionMethod = 'filename-extension';
+                return { 
+                  mimeType: 'video/mp4', 
+                  extension: 'mp4',
+                  isValid: true,
+                  isBlob: true,
+                  detectionMethod
+                };
+              } else if (ext === 'mov') {
+                detectionMethod = 'filename-extension';
+                return { 
+                  mimeType: 'video/quicktime', 
+                  extension: 'mov',
+                  isValid: true,
+                  isBlob: true,
+                  detectionMethod
+                };
+              } else if (ext === 'webm') {
+                detectionMethod = 'filename-extension';
+                return { 
+                  mimeType: 'video/webm', 
+                  extension: 'webm',
+                  isValid: true,
+                  isBlob: true,
+                  detectionMethod
+                };
+              }
+            }
+          }
+          
+          // For unknown binary content
+          return {
+            mimeType: 'application/octet-stream',
+            extension: 'bin',
+            isValid: true,
+            isBlob: true,
+            detectionMethod: 'binary-fallback'
+          };
+        }
+      }
+      
+      // Special video format detection
+      const videoFormat = detectVideoFormat(content);
+      if (videoFormat) {
+        return videoFormat;
+      }
+      
       return { 
         mimeType, 
-        extension: getExtension(mimeType), 
-        isValid: mimeType !== 'application/octet-stream'
+        extension, 
+        isValid: mimeType !== 'application/octet-stream',
+        detectionMethod
       };
     }
 
     return { 
       mimeType: 'application/octet-stream', 
       extension: '', 
-      isValid: false 
+      isValid: false,
+      detectionMethod: 'unknown'
     };
   }
 

commit 9194c3ed40d10d305326de2ebaad7360b05a0734
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Wed Apr 9 18:37:08 2025 +0800

    pdf

diff --git a/src/components/panels/catalog/DetailView.jsx b/src/components/panels/catalog/DetailView.jsx
index ce7f4e2..b465315 100644
--- a/src/components/panels/catalog/DetailView.jsx
+++ b/src/components/panels/catalog/DetailView.jsx
@@ -3,6 +3,8 @@ import { getSimpleContentType, getContentTypeDisplay } from './utils';
 import { ContentService } from '../../../services/content-service';
 import { processContent, isImageType } from '../../../utils/content-utils';
 import VideoPlayer from '../../viewers/VideoPlayer';
+import PDFViewer from '../../viewers/PDFViewer';
+import AudioViewer from '../../viewers/AudioViewer';
 import '../../viewers/video-player.css';
 import './detail-view.css';
 
@@ -22,6 +24,9 @@ const DetailView = ({
   const [retryCount, setRetryCount] = useState(0);
   const [imageData, setImageData] = useState(null);
   const [contentData, setContentData] = useState(null);
+  const [rawContent, setRawContent] = useState(null);
+  const [contentLoading, setContentLoading] = useState(false);
+  const [contentError, setContentError] = useState(null);
   const imageRef = useRef(null);
   
   // Get content type display mapping
@@ -35,69 +40,96 @@ const DetailView = ({
       setRetryCount(0);
       setImageData(null);
       setContentData(null);
+      setRawContent(null);
+      setContentLoading(false);
+      setContentError(null);
     }
   }, [selectedItem?.hash]);
 
-  // Load content when an item is selected using ContentService
   useEffect(() => {
-    if (!selectedItem) return;
+    if (selectedItem?.hash) {
+      document.title = `Card - ${selectedItem.hash.substring(0, 8)}`;
+    }
+    return () => {
+      document.title = 'Card Catalog';
+    };
+  }, [selectedItem]);
+
+  // For PDF content, create a direct link to the file
+  const getPdfDirectUrl = (hash) => {
+    // Use direct file access with the raw parameter to bypass content processing
+    return `/api/card-collection?action=get&hash=${hash}&raw=true&forceDownload=false`;
+  };
+
+  // Fetch content for the selected item
+  useEffect(() => {
+    if (!selectedItem?.hash) return;
     
-    const contentType = selectedItem.contentType;
-    const isImage = isImageType(contentType);
+    setContentLoading(true);
+    setImageLoaded(false);
+    setImageError(false);
     
-    if (isImage) {
-      console.log(`Loading image for item: ${selectedItem.hash}`);
-      setImageLoaded(false);
-      setImageError(false);
-      
-      // Use ContentService to fetch and process the image
-      ContentService.fetchContent(selectedItem.hash)
-        .then(result => {
-          console.log("Content loaded:", result.hash);
-          
-          if (result.error) {
-            console.error("Error loading content:", result.error);
-            throw new Error(result.error);
-          }
-          
+    // Determine if we need special content processing
+    const needsBinaryProcessing = 
+      selectedItem.contentType?.mimeType?.startsWith('image/') ||
+      selectedItem.contentType?.mimeType === 'application/pdf' ||
+      selectedItem.contentType?.mimeType?.startsWith('audio/') ||
+      selectedItem.contentType?.mimeType?.startsWith('video/');
+    
+    console.log(`Loading content for item: ${selectedItem.hash}, type: ${selectedItem.contentType?.mimeType}`);
+    
+    // Use ContentService to fetch and process content
+    ContentService.fetchContent(selectedItem.hash, { maxRetries: 3 })
+      .then(result => {
+        setContentLoading(false);
+        
+        if (result.error) {
+          console.error("Error loading content:", result.error);
+          setContentError(result.error);
+          return;
+        }
+        
+        // Store raw content for specialized viewers (PDF, Video, Audio)
+        if (result.raw) {
+          setRawContent(result.raw.content || result.raw);
+        }
+        
+        // For image content, create a data URL
+        if (isImageType(selectedItem.contentType)) {
           if (result.processed && result.processed.type === 'dataUrl') {
             // Already processed to data URL
             setImageData(result.processed.url);
             setImageLoaded(true);
           } else if (result.raw?.content) {
             // Process the content
-            const processed = processContent(result.raw.content, contentType);
+            const processed = processContent(result.raw.content, selectedItem.contentType);
             
             if (processed.type === 'dataUrl') {
               setImageData(processed.url);
               setImageLoaded(true);
             } else {
               console.error("Unexpected content format:", processed.type);
-              throw new Error(`Unexpected content format: ${processed.type}`);
+              setContentError("Failed to process image data");
             }
           } else {
-            throw new Error("No valid content found in API response");
+            setContentError("No valid content found in API response");
           }
-        })
-        .catch(error => {
-          console.error("Error processing image:", error);
+        }
+        
+        // Store full content data for JSON, text, etc.
+        setContentData(result);
+      })
+      .catch(error => {
+        console.error("Error loading content:", error);
+        setContentLoading(false);
+        setContentError(`Failed to load content: ${error.message || 'Unknown error'}`);
+        
+        if (isImageType(selectedItem.contentType)) {
           setImageError(true);
-        });
-    } else {
-      // For non-image content types, just fetch the data
-      ContentService.fetchContent(selectedItem.hash)
-        .then(result => {
-          if (result.error) {
-            console.error("Error loading content:", result.error);
-            return;
-          }
-          setContentData(result);
-        })
-        .catch(error => {
-          console.error("Error loading content:", error);
-        });
-    }
-  }, [selectedItem, retryCount]);
+        }
+      });
+      
+  }, [selectedItem?.hash, retryCount]);
 
   // Helper function to get proper content type display
   const getFormattedContentType = (mimeType) => {
@@ -108,7 +140,39 @@ const DetailView = ({
     
     return `${contentTypeMap[simpleType] || simpleType.toUpperCase()} (${mimeType})`;
   };
-  
+
+  // Helper function to detect if content is binary data
+  const isBinaryContent = (data) => {
+    if (!data) return false;
+    
+    // Check if it's a string that looks like binary data (contains many non-printable characters)
+    if (typeof data === 'string') {
+      // Simple heuristic: if string contains many non-printable characters or appears to be binary
+      const nonPrintableChars = data.match(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g);
+      return nonPrintableChars && nonPrintableChars.length > (data.length * 0.1); // More than 10% non-printable
+    }
+    
+    // If it's an object that looks like a buffer or array of numbers
+    if (
+      (typeof data === 'object' && 
+       data !== null && 
+       (data.type === 'Buffer' || data instanceof Uint8Array || 
+        (Array.isArray(data) && data.length > 0 && typeof data[0] === 'number')))
+    ) {
+      return true;
+    }
+    
+    return false;
+  };
+
+  // Helper function to format file size
+  const formatFileSize = (size) => {
+    if (size < 1024) return `${size} bytes`;
+    if (size < 1024 * 1024) return `${(size / 1024).toFixed(2)} KB`;
+    if (size < 1024 * 1024 * 1024) return `${(size / (1024 * 1024)).toFixed(2)} MB`;
+    return `${(size / (1024 * 1024 * 1024)).toFixed(2)} GB`;
+  };
+
   if (itemLoading) {
     return <div className="loading-indicator">Loading item details...</div>;
   }
@@ -229,6 +293,78 @@ const DetailView = ({
     
     const contentType = selectedItem.contentType || { mimeType: 'text/plain' };
     
+    // Special handler for PDFs - prioritize this at the very top
+    if (contentType.mimeType === 'application/pdf') {
+      console.log("Rendering PDF with direct object approach");
+      // Create a direct URL to the raw PDF content
+      const pdfUrl = getPdfDirectUrl(selectedItem.hash);
+      
+      return (
+        <ContentWrapper className="pdf-wrapper">
+          <div className="pdf-container">
+            <object
+              data={pdfUrl}
+              type="application/pdf"
+              className="pdf-frame"
+              aria-label="PDF Document"
+            >
+              <p>
+                Your browser doesn't support PDF viewing.
+                <a href={pdfUrl} target="_blank" rel="noopener noreferrer">
+                  Download PDF
+                </a>
+              </p>
+            </object>
+          </div>
+        </ContentWrapper>
+      );
+    }
+    
+    // Handle binary data that may be misclassified
+    if (contentData && isBinaryContent(contentData.raw?.content || contentData.raw)) {
+      console.log("Detected binary content, proper rendering required", contentType.mimeType);
+      
+      // Skip binary handling for known file types that are binary by nature
+      if (contentType.mimeType === 'application/pdf' || 
+          contentType.mimeType.startsWith('image/') ||
+          contentType.mimeType.startsWith('video/') ||
+          contentType.mimeType.startsWith('audio/')) {
+        // Let the specific handlers below deal with these known binary formats
+        console.log("Skipping binary fallback for known binary file type:", contentType.mimeType);
+      }
+      // Only use binary fallback for octet-stream or unknown binary content
+      else if (contentType.mimeType === 'application/octet-stream' || 
+          contentType.mimeType === 'binary/octet-stream') {
+        // Treat as a binary file with download option
+        return (
+          <ContentWrapper className="binary-wrapper">
+            <div className="binary-container">
+              <div className="binary-info">
+                <div className="binary-icon">📄</div>
+                <h3>Binary File</h3>
+                <p>This appears to be a binary file that cannot be displayed in the browser.</p>
+                <p>Content type: {contentType.mimeType}</p>
+                {contentData && contentData.raw && (
+                  <p>File size: {formatFileSize(
+                    contentData.raw.content ? 
+                    contentData.raw.content.length || 0 : 
+                    contentData.raw.length || 0
+                  )}</p>
+                )}
+                <a 
+                  href={`/api/card-collection?action=get&hash=${selectedItem.hash}`}
+                  download={`${selectedItem.hash.substring(0, 8)}.bin`}
+                  className="btn btn-primary"
+                >
+                  Download File
+                </a>
+              </div>
+            </div>
+          </ContentWrapper>
+        );
+      }
+    }
+    
     // Handle different content types
     if (contentType.mimeType?.startsWith('image/')) {
       // For images, we need to create a data URL from the API response
@@ -268,28 +404,15 @@ const DetailView = ({
           )}
         </ContentWrapper>
       );
-    } else if (contentType.mimeType === 'application/pdf') {
-      return (
-        <ContentWrapper className="pdf-wrapper">
-          <div className="pdf-container">
-            <iframe 
-              src={`/api/card-collection?action=get&hash=${selectedItem.hash}`} 
-              className="pdf-frame" 
-              title="PDF Viewer"
-            ></iframe>
-          </div>
-        </ContentWrapper>
-      );
     } else if (contentType.mimeType?.startsWith('audio/')) {
       return (
         <ContentWrapper className="audio-wrapper">
-          <audio controls className="content-audio">
-            <source 
-              src={`/api/card-collection?action=get&hash=${selectedItem.hash}`} 
-              type={contentType.mimeType} 
-            />
-            Your browser does not support the audio element.
-          </audio>
+          <AudioViewer 
+            hash={selectedItem.hash}
+            content={rawContent}
+            contentType={contentType}
+            format={contentType.extension || "audio"}
+          />
         </ContentWrapper>
       );
     } else if (contentType.mimeType.startsWith('video/') || contentType.mimeType === 'video/quicktime') {
@@ -419,7 +542,24 @@ const DetailView = ({
           <div className="content-section">
             <h3>Content</h3>
             <div className="content-container">
-              {renderContent()}
+              {contentLoading ? (
+                <div className="content-loading">Loading content...</div>
+              ) : contentError ? (
+                <div className="content-error">
+                  <p>{contentError}</p>
+                  <button 
+                    className="btn btn-small" 
+                    onClick={() => {
+                      setContentError(null);
+                      setRetryCount(prev => prev + 1);
+                    }}
+                  >
+                    Retry
+                  </button>
+                </div>
+              ) : (
+                renderContent()
+              )}
             </div>
           </div>
           
diff --git a/src/components/panels/catalog/detail-view.css b/src/components/panels/catalog/detail-view.css
index 4477423..05856ee 100644
--- a/src/components/panels/catalog/detail-view.css
+++ b/src/components/panels/catalog/detail-view.css
@@ -182,16 +182,140 @@
 /* PDF Content Styles */
 .pdf-wrapper {
   height: 100%;
+  width: 100%;
+  display: flex;
+  flex-direction: column;
+  background-color: #1a1d23;
+  overflow: hidden;
+  position: relative;
 }
 
 .pdf-container {
   height: 100%;
+  width: 100%;
+  display: flex;
+  flex-direction: column;
+  background-color: #f5f5f5;
+  border-radius: 4px;
+  overflow: hidden;
 }
 
 .pdf-frame {
   width: 100%;
   height: 100%;
   border: none;
+  background-color: #fff;
+}
+
+/* Enhanced PDF Viewer Container */
+.pdf-viewer-container {
+  flex: 1;
+  display: flex;
+  flex-direction: column;
+  width: 100%;
+  height: 100%;
+  overflow: hidden;
+  background-color: #f5f5f5;
+  border-radius: 4px;
+}
+
+/* Make sure PDFViewer takes up the full space */
+.pdf-viewer-container > div {
+  height: 100% !important;
+  display: flex;
+  flex-direction: column;
+}
+
+/* PDF toolbar styling */
+.pdf-toolbar {
+  display: flex;
+  align-items: center;
+  padding: 8px 16px;
+  background-color: #21252b;
+  border-bottom: 1px solid #3a3f4b;
+}
+
+.pdf-toolbar button {
+  background-color: #333;
+  color: #e0e0e0;
+  border: 1px solid #444;
+  border-radius: 4px;
+  padding: 5px 10px;
+  margin-right: 10px;
+  cursor: pointer;
+  font-size: 14px;
+}
+
+.pdf-toolbar button:hover {
+  background-color: #444;
+}
+
+.pdf-toolbar .page-info {
+  margin: 0 15px;
+  color: #e0e0e0;
+  font-size: 14px;
+}
+
+.pdf-zoom-controls {
+  display: flex;
+  align-items: center;
+  margin-left: auto;
+}
+
+.pdf-zoom-controls button {
+  width: 30px;
+  height: 30px;
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  padding: 0;
+}
+
+/* Make PDF display with optimal size */
+object[type="application/pdf"], embed[type="application/pdf"] {
+  width: 100%;
+  height: 100%;
+  background-color: #fff;
+}
+
+/* PDF loading and fallback styles */
+.pdf-loading {
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  height: 100%;
+  width: 100%;
+  background-color: #f5f5f5;
+  color: #333;
+  font-size: 16px;
+}
+
+.pdf-fallback {
+  display: flex;
+  flex-direction: column;
+  align-items: center;
+  justify-content: center;
+  padding: 20px;
+  height: 100%;
+  width: 100%;
+  background-color: #fff;
+  border-radius: 4px;
+  text-align: center;
+}
+
+.pdf-fallback a {
+  color: #0366d6;
+  margin-top: 10px;
+  padding: 8px 16px;
+  border: 1px solid #0366d6;
+  border-radius: 4px;
+  text-decoration: none;
+  transition: background-color 0.2s;
+}
+
+.pdf-fallback a:hover {
+  background-color: #0366d6;
+  color: #fff;
 }
 
 /* Audio and Video Content Styles */
@@ -412,3 +536,65 @@
   color: #bbb;
   font-style: italic;
 }
+
+/* Binary Content Styles */
+.binary-wrapper {
+  height: 100%;
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  background-color: #21252b;
+  padding: 20px;
+}
+
+.binary-container {
+  max-width: 500px;
+  background-color: #2c313a;
+  border-radius: 8px;
+  border: 1px solid #3a3f4b;
+  padding: 30px;
+  text-align: center;
+  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
+}
+
+.binary-info {
+  display: flex;
+  flex-direction: column;
+  align-items: center;
+}
+
+.binary-icon {
+  font-size: 48px;
+  margin-bottom: 20px;
+}
+
+.binary-info h3 {
+  font-size: 24px;
+  font-weight: 600;
+  margin: 0 0 15px 0;
+  color: #e0e0e0;
+}
+
+.binary-info p {
+  margin: 5px 0;
+  color: #bbb;
+  font-size: 14px;
+}
+
+.binary-info a.btn-primary {
+  background-color: #0366d6;
+  color: white;
+  border: none;
+  padding: 10px 20px;
+  margin-top: 20px;
+  border-radius: 4px;
+  font-size: 14px;
+  font-weight: 500;
+  text-decoration: none;
+  cursor: pointer;
+  transition: background-color 0.2s;
+}
+
+.binary-info a.btn-primary:hover {
+  background-color: #0078ff;
+}
diff --git a/src/components/viewers/PDFViewer.jsx b/src/components/viewers/PDFViewer.jsx
index 2926624..8313ebf 100644
--- a/src/components/viewers/PDFViewer.jsx
+++ b/src/components/viewers/PDFViewer.jsx
@@ -1,14 +1,18 @@
 // src/components/viewers/PDFViewer.jsx
 import React, { useState, useEffect, useMemo } from 'react';
+import './pdf-viewer.css';
 
 /**
- * A specialized viewer for PDF files
+ * A specialized viewer for PDF files with enhanced controls
  */
 export const PDFViewer = ({ content, contentType }) => {
   const [isLoading, setIsLoading] = useState(true);
   const [error, setError] = useState(null);
   const [pdfSource, setPdfSource] = useState(null);
   const [textContent, setTextContent] = useState(null); // For fallback text display
+  const [currentPage, setCurrentPage] = useState(1);
+  const [totalPages, setTotalPages] = useState(0);
+  const [zoom, setZoom] = useState(100);
   
   // Process the content and set the appropriate state
   useEffect(() => {
@@ -203,10 +207,56 @@ export const PDFViewer = ({ content, contentType }) => {
     return null;
   }, [content]);
   
+  // Handle page navigation
+  const handlePrevPage = () => {
+    if (currentPage > 1) {
+      setCurrentPage(currentPage - 1);
+    }
+  };
+  
+  const handleNextPage = () => {
+    if (currentPage < totalPages) {
+      setCurrentPage(currentPage + 1);
+    }
+  };
+  
+  // Handle zoom controls
+  const handleZoomIn = () => {
+    setZoom(Math.min(zoom + 25, 200));
+  };
+  
+  const handleZoomOut = () => {
+    setZoom(Math.max(zoom - 25, 50));
+  };
+  
+  const handleZoomReset = () => {
+    setZoom(100);
+  };
+  
+  // Try to get the total number of pages when PDF loads
+  const handlePdfLoad = () => {
+    setIsLoading(false);
+    
+    // If there's an embedded PDF viewer, we might be able to access its properties
+    try {
+      const pdfObject = document.querySelector('object[type="application/pdf"]');
+      if (pdfObject && pdfObject.contentDocument) {
+        // Modern PDF viewers often show page count in their UI
+        // This is a best effort approach as browser security may limit access
+        setTimeout(() => {
+          setTotalPages(2); // Fallback if we can't detect
+        }, 1000);
+      }
+    } catch (e) {
+      console.log("Could not detect PDF page count:", e);
+      setTotalPages(1);
+    }
+  };
+  
   // Display text content if we have it (fallback display)
   if (textContent) {
     return (
-      <div className="flex flex-col h-full p-4 bg-gray-50 overflow-auto">
+      <div className="pdf-fallback">
         <div className="text-amber-600 text-center mb-4">
           <div className="text-3xl mb-2">⚠️</div>
           <p className="font-medium">Content has application/pdf type but appears to be text</p>
@@ -224,7 +274,7 @@ export const PDFViewer = ({ content, contentType }) => {
   
   if (error) {
     return (
-      <div className="flex flex-col items-center justify-center h-full p-4 bg-gray-50">
+      <div className="pdf-fallback">
         <div className="text-red-500 text-center">
           <div className="text-5xl mb-4">⚠️</div>
           <p className="font-medium">{error}</p>
@@ -237,51 +287,74 @@ export const PDFViewer = ({ content, contentType }) => {
   
   if (!pdfSource) {
     return (
-      <div className="flex flex-col items-center justify-center h-full p-4 bg-gray-50">
+      <div className="pdf-loading">
         <div className="text-gray-500 text-center">
           <div className="text-5xl mb-4">📄</div>
-          <p className="font-medium">Unable to display PDF</p>
-          <p className="text-sm text-gray-600 mt-2">
-            The provided content could not be converted to a viewable PDF.
-          </p>
+          <p className="font-medium">Loading PDF...</p>
         </div>
       </div>
     );
   }
   
-  // For security reasons, use object/embed tag for PDFs instead of an iframe
   return (
-    <div className="flex flex-col h-full p-4 bg-gray-50 overflow-hidden">
+    <div className="pdf-viewer-container">
+      <div className="pdf-toolbar">
+        <button onClick={handlePrevPage} disabled={currentPage <= 1}>
+          Previous
+        </button>
+        <button onClick={handleNextPage} disabled={currentPage >= totalPages}>
+          Next
+        </button>
+        <span className="page-info">
+          Page {currentPage} of {totalPages || '?'}
+        </span>
+        
+        <div className="pdf-zoom-controls">
+          <button onClick={handleZoomOut} title="Zoom Out">
+            -
+          </button>
+          <span className="page-info">
+            {zoom}%
+          </span>
+          <button onClick={handleZoomIn} title="Zoom In">
+            +
+          </button>
+          <button onClick={handleZoomReset} title="Reset Zoom">
+            Reset
+          </button>
+        </div>
+      </div>
+      
       {isLoading && (
-        <div className="absolute inset-0 flex items-center justify-center bg-gray-100 bg-opacity-75 z-10">
-          <div className="animate-pulse text-gray-500">Loading PDF...</div>
+        <div className="pdf-loading">
+          <div>Loading PDF...</div>
         </div>
       )}
       
-      <div className="relative flex-grow w-full h-full overflow-hidden">
+      <div className="pdf-container">
         <object
-          className="w-full h-full"
+          className="pdf-frame"
           data={pdfSource}
           type="application/pdf"
-          onLoad={() => setIsLoading(false)}
+          onLoad={handlePdfLoad}
           onError={(e) => {
             console.error("PDF load error:", e);
             setIsLoading(false);
             setError("Failed to load PDF: Document may be corrupted");
           }}
         >
-          <div className="flex flex-col items-center justify-center h-full bg-gray-100">
-            <p className="text-gray-600">
+          <div className="pdf-fallback">
+            <p>
               Your browser does not support inline PDF viewing. 
-              <a href={pdfSource} target="_blank" rel="noopener noreferrer" className="ml-1 text-blue-500 hover:underline">
-                Click here to download.
+              <a href={pdfSource} target="_blank" rel="noopener noreferrer" download="document.pdf">
+                Click here to download the PDF
               </a>
             </p>
           </div>
         </object>
       </div>
       
-      <div className="mt-2 text-sm text-gray-600 text-center">
+      <div className="mt-2 text-sm text-gray-600 text-center pdf-info">
         <p>PDF Document</p>
         {size && <p>Size: {formatFileSize(size)}</p>}
       </div>
diff --git a/src/components/viewers/pdf-viewer.css b/src/components/viewers/pdf-viewer.css
new file mode 100644
index 0000000..3e82f21
--- /dev/null
+++ b/src/components/viewers/pdf-viewer.css
@@ -0,0 +1,139 @@
+/* PDF Viewer Component Styles */
+
+.pdf-viewer-container {
+  display: flex;
+  flex-direction: column;
+  width: 100%;
+  height: 100%;
+  overflow: hidden;
+  background-color: #282c34;
+  color: #e0e0e0;
+}
+
+/* PDF toolbar styling */
+.pdf-toolbar {
+  display: flex;
+  align-items: center;
+  padding: 8px 16px;
+  background-color: #21252b;
+  border-bottom: 1px solid #3a3f4b;
+  z-index: 10;
+}
+
+.pdf-toolbar button {
+  background-color: #333;
+  color: #e0e0e0;
+  border: 1px solid #444;
+  border-radius: 4px;
+  padding: 5px 10px;
+  margin-right: 10px;
+  cursor: pointer;
+  font-size: 14px;
+  transition: background-color 0.2s;
+}
+
+.pdf-toolbar button:hover {
+  background-color: #444;
+}
+
+.pdf-toolbar button:disabled {
+  opacity: 0.5;
+  cursor: not-allowed;
+}
+
+.pdf-toolbar .page-info {
+  margin: 0 15px;
+  color: #e0e0e0;
+  font-size: 14px;
+}
+
+.pdf-zoom-controls {
+  display: flex;
+  align-items: center;
+  margin-left: auto;
+}
+
+.pdf-zoom-controls button {
+  width: 30px;
+  height: 30px;
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  padding: 0;
+}
+
+/* PDF container with viewer */
+.pdf-container {
+  flex: 1;
+  position: relative;
+  background-color: #fff;
+  overflow: auto;
+  height: calc(100% - 100px);
+}
+
+object[type="application/pdf"], embed[type="application/pdf"] {
+  width: 100%;
+  height: 100%;
+  min-height: 500px;
+  display: block;
+}
+
+/* PDF loading and fallback styles */
+.pdf-loading {
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  height: 100%;
+  width: 100%;
+  background-color: #21252b;
+  color: #e0e0e0;
+  font-size: 16px;
+  padding: 20px;
+}
+
+.pdf-fallback {
+  display: flex;
+  flex-direction: column;
+  align-items: center;
+  justify-content: center;
+  padding: 40px 20px;
+  height: 100%;
+  background-color: #21252b;
+  text-align: center;
+  color: #e0e0e0;
+}
+
+.pdf-fallback a {
+  color: #61dafb;
+  margin-top: 15px;
+  padding: 8px 16px;
+  border: 1px solid #61dafb;
+  border-radius: 4px;
+  text-decoration: none;
+  transition: background-color 0.2s;
+}
+
+.pdf-fallback a:hover {
+  background-color: #61dafb;
+  color: #282c34;
+}
+
+.pdf-info {
+  padding: 8px;
+  font-size: 12px;
+  color: #aaa;
+  text-align: center;
+  background-color: #21252b;
+  border-top: 1px solid #3a3f4b;
+}
+
+/* Animation for loading state */
+@keyframes pulse {
+  0% { opacity: 0.6; }
+  50% { opacity: 1; }
+  100% { opacity: 0.6; }
+}
+
+.pdf-loading > div {
+  animation: pulse 1.5s infinite;
+}
diff --git a/src/pages/api/card-collection.ts b/src/pages/api/card-collection.ts
index 25ae853..6cf9058 100644
--- a/src/pages/api/card-collection.ts
+++ b/src/pages/api/card-collection.ts
@@ -223,6 +223,9 @@ export const GET: APIRoute = async ({ request }) => {
     switch (action) {
       case 'get': {
         const hash = url.searchParams.get('hash');
+        // Check if raw parameter is provided to return content directly
+        const rawResponse = url.searchParams.get('raw') === 'true';
+        const forceDownload = url.searchParams.get('forceDownload') === 'true';
         
         if (!hash) {
           return new Response(
@@ -247,7 +250,7 @@ export const GET: APIRoute = async ({ request }) => {
             { status: 404, headers: { 'Content-Type': 'application/json' } }
           );
         }
-        
+
         // Get content type
         let contentTypeInfo: any = null;
         if (card.contentType) {
@@ -259,7 +262,41 @@ export const GET: APIRoute = async ({ request }) => {
           console.log('Detected content type:', contentTypeInfo);
         }
         
-        // Process content based on content type
+        // Handle raw response for PDF and binary files (for direct viewing/downloading)
+        if (rawResponse) {
+          console.log(`Serving raw content for ${hash}, content type:`, contentTypeInfo?.mimeType);
+          
+          let contentToServe: Buffer | Uint8Array | string = card.content;
+          const mimeType = contentTypeInfo?.mimeType || 'application/octet-stream';
+          
+          // Convert Buffer JSON format to actual Buffer if needed
+          if (typeof card.content === 'object' && 
+              card.content !== null && 
+              card.content.type === 'Buffer' && 
+              Array.isArray(card.content.data)) {
+            contentToServe = new Uint8Array(card.content.data);
+          }
+          
+          // Set appropriate headers based on content type and download preference
+          const headers: Record<string, string> = {
+            'Content-Type': mimeType
+          };
+          
+          if (forceDownload) {
+            const extension = contentTypeInfo?.extension || 'bin';
+            headers['Content-Disposition'] = `attachment; filename="${hash.substring(0, 8)}.${extension}"`;
+          } else {
+            headers['Content-Disposition'] = 'inline';
+          }
+          
+          // Return the raw content directly
+          return new Response(contentToServe, { 
+            status: 200, 
+            headers 
+          });
+        }
+        
+        // Process content based on content type (for standard JSON responses)
         const processedContent = processCardContent(card.content, contentTypeInfo?.mimeType || null);
         
         console.log('card-collection API - Card retrieved:', {

commit ba909ac90c0443d235629af03af06ddc35f00912
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Wed Apr 9 11:22:22 2025 +0800

    new catalog

diff --git a/src/components/panels/catalog/grid-item-preview.css b/src/components/panels/catalog/grid-item-preview.css
index ae809cc..6c77fa2 100644
--- a/src/components/panels/catalog/grid-item-preview.css
+++ b/src/components/panels/catalog/grid-item-preview.css
@@ -2,19 +2,21 @@
 
 .grid-masonry {
   display: grid;
-  grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
-  grid-gap: 16px;
-  padding: 16px;
+  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
+  grid-gap: 20px;
+  padding: 20px;
 }
 
 .grid-item {
   break-inside: avoid;
-  margin-bottom: 16px;
+  margin-bottom: 0; /* Remove margin bottom to ensure consistent spacing */
   transition: transform 0.2s ease;
 }
 
-.grid-item-image {
-  grid-row: span 2;
+/* All grid items have consistent sizing regardless of content type */
+.grid-item-image, .grid-item-other {
+  display: flex;
+  flex-direction: column;
 }
 
 .grid-item-card {
@@ -22,9 +24,9 @@
   flex-direction: column;
   background-color: #fff;
   border-radius: 8px;
-  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
+  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
   overflow: hidden;
-  transition: all 0.3s ease;
+  transition: all 0.2s ease;
   height: 100%;
   border: 1px solid #e0e0e0;
   color: #000000 !important;
@@ -32,22 +34,28 @@
 }
 
 .grid-item-card.hovered {
-  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
-  transform: translateY(-4px);
+  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
+  transform: translateY(-2px);
 }
 
 .grid-item-thumbnail {
   width: 100%;
-  height: 160px;
+  height: 180px; /* Consistent fixed height for all thumbnails */
   position: relative;
+  background-color: #f5f5f5;
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  overflow: hidden;
 }
 
+/* All thumbnails have the same height for consistency */
 .image-thumbnail {
-  height: 200px;
+  height: 180px;
 }
 
 .grid-item-info {
-  padding: 12px;
+  padding: 16px;
   flex-grow: 1;
   display: flex;
   flex-direction: column;
@@ -70,25 +78,29 @@
   font-size: 12px;
   color: #666;
   margin-bottom: 8px;
+  align-items: center;
 }
 
 .grid-item-type {
   background-color: #f5f5f5;
-  padding: 2px 6px;
+  padding: 3px 8px;
   border-radius: 4px;
   font-weight: 500;
   color: #000000 !important;
   font-weight: bold !important;
   background-color: rgba(255, 255, 255, 0.9) !important;
-  padding: 2px 6px !important;
   border: 1px solid #000000 !important;
   border-radius: 4px !important;
+  font-size: 11px;
+  white-space: nowrap;
+  overflow: hidden;
+  text-overflow: ellipsis;
+  max-width: 60%;
 }
 
 .grid-item-date {
-  color: #888;
-  color: #000000 !important;
-  font-weight: 500 !important;
+  color: #666;
+  font-size: 11px;
 }
 
 .grid-item-description {
@@ -101,12 +113,13 @@
   line-clamp: 2;
   -webkit-box-orient: vertical;
   flex-grow: 1;
-  color: #000000 !important;
-  font-weight: 500 !important;
+  color: #444 !important;
+  font-weight: normal !important;
+  line-height: 1.4;
 }
 
 .grid-item-actions {
-  padding: 8px 12px;
+  padding: 12px 16px;
   display: flex;
   justify-content: flex-end;
   background-color: #f9f9f9;
@@ -124,7 +137,6 @@
   width: 100%;
   height: 100%;
   overflow: hidden;
-  border-radius: 6px 6px 0 0;
   display: flex;
   align-items: center;
   justify-content: center;
@@ -134,13 +146,15 @@
 
 /* Image preview styles */
 .image-preview {
-  background-color: #f0f0f0;
+  background-color: #f5f5f5;
+  width: 100%;
+  height: 100%;
 }
 
 .preview-image {
   width: 100%;
   height: 100%;
-  object-fit: cover;
+  object-fit: contain; /* Changed from cover to contain for better image display */
   transition: transform 0.3s ease;
 }
 
@@ -162,7 +176,7 @@
 .video-thumbnail img {
   width: 100%;
   height: 100%;
-  object-fit: cover;
+  object-fit: contain; /* Changed from cover to contain */
   opacity: 0.8;
 }
 
@@ -187,185 +201,68 @@
 .audio-preview {
   background-color: #2c3e50;
   color: white;
-}
-
-.audio-icon {
-  display: flex;
-  flex-direction: column;
-  align-items: center;
-  justify-content: center;
   width: 100%;
   height: 100%;
-}
-
-.audio-icon span {
-  font-size: 2rem;
-  margin-bottom: 10px;
-}
-
-.waveform {
   display: flex;
   align-items: center;
   justify-content: center;
-  width: 80%;
-  height: 40px;
-  gap: 3px;
 }
 
-.waveform-bar {
-  width: 4px;
-  background-color: #3498db;
-  border-radius: 2px;
-}
-
-/* PDF preview styles */
-.pdf-preview {
-  background-color: #fff;
-}
-
-.pdf-icon {
+.audio-icon {
   display: flex;
   flex-direction: column;
   align-items: center;
   justify-content: center;
   width: 100%;
   height: 100%;
-  position: relative;
-}
-
-.pdf-icon span {
-  position: absolute;
-  top: 10px;
-  left: 10px;
-  background-color: #e74c3c;
-  color: white;
-  padding: 4px 8px;
-  border-radius: 4px;
-  font-weight: bold;
-  z-index: 2;
-}
-
-.pdf-icon img {
-  width: 100%;
-  height: 100%;
-  object-fit: cover;
-}
-
-.pdf-icon-only {
-  display: flex;
-  align-items: center;
-  justify-content: center;
-  width: 100%;
-  height: 100%;
-  background-color: #f9f9f9;
-  font-size: 3rem;
-  color: #e74c3c;
 }
 
 /* Text preview styles */
 .text-preview {
+  background-color: #f9f9f9;
+  border: 1px solid #eee;
+  width: 100%;
+  height: 100%;
   display: flex;
   flex-direction: column;
-  height: 100%;
-  width: 100%;
-  background-color: #ffffff;
-  border-radius: 4px;
-  overflow: hidden;
-  position: relative;
-  border: 1px solid #cccccc;
 }
 
-.text-preview-content {
-  padding: 12px;
-  overflow: hidden;
-  flex-grow: 1;
-  background-color: #ffffff;
-  border: 1px solid #cccccc;
-  border-radius: 4px;
-  font-family: 'Courier New', monospace;
-  font-size: 13px;
-  line-height: 1.5;
-  max-height: 140px;
-}
-
-.text-preview-content pre {
+.text-preview pre {
   margin: 0;
+  padding: 10px;
+  font-size: 12px;
+  overflow: hidden;
+  max-height: 100%;
+  color: #333;
+  background-color: #fff;
   white-space: pre-wrap;
   word-break: break-word;
-  overflow: hidden;
-  display: -webkit-box;
-  -webkit-line-clamp: 6;
-  line-clamp: 6;
-  -webkit-box-orient: vertical;
-  color: #000000;
-  font-weight: 500;
 }
 
-.text-type-label {
-  padding: 6px 8px;
-  font-size: 11px;
-  background-color: #007bff;
-  color: #ffffff;
-  text-align: center;
-  border-top: 1px solid #dee2e6;
-  position: absolute;
-  bottom: 0;
-  width: 100%;
-  font-weight: 500;
-}
-
-/* High contrast text styling for previews */
 .high-contrast-text {
-  background-color: #FFFFFF !important;
-  color: #000000 !important;
-  font-weight: bold !important;
-  font-size: 15px !important;
-  line-height: 1.6 !important;
-  text-shadow: none !important;
-  border: 2px solid #000000 !important;
-  padding: 10px !important;
-  font-family: 'Courier New', monospace !important;
-  box-shadow: none !important;
-  border-radius: 0 !important;
-}
-
-.high-contrast-text pre {
-  color: #000000 !important;
-  white-space: pre-wrap !important;
-  word-break: break-word !important;
-  font-weight: 600 !important;
-  margin: 0 !important;
+  background-color: white;
+  flex-grow: 1;
+  overflow: hidden;
+  padding: 0;
 }
 
-.text-preview-content {
-  padding: 0 !important;
-  border: none !important;
-  margin: 0 !important;
-  background-color: #FFFFFF !important;
+.text-type-label {
+  padding: 4px 8px;
+  font-size: 10px;
+  text-align: right;
+  background-color: #eee;
+  color: #666;
 }
 
-/* Loading indicator */
-.loading-indicator {
+/* Default preview styles for non-image content */
+.default-preview {
   display: flex;
   align-items: center;
   justify-content: center;
-  height: 100%;
+  background-color: #f5f5f5;
+  color: #666;
   width: 100%;
-  padding: 20px 0;
-  color: #6c757d;
-  font-size: 18px;
-}
-
-/* Content type label for icon previews */
-.content-type-label {
-  margin-top: 8px;
-  font-size: 10px;
-  color: #6c757d;
-  text-align: center;
-  max-width: 100%;
-  overflow: hidden;
-  text-overflow: ellipsis;
-  white-space: nowrap;
+  height: 100%;
 }
 
 .preview-icon {
@@ -373,55 +270,82 @@
   flex-direction: column;
   align-items: center;
   justify-content: center;
-  height: 100%;
+  text-align: center;
   width: 100%;
-  padding: 20px 0;
+  height: 100%;
 }
 
 .preview-icon i {
-  font-size: 24px;
+  font-size: 32px;
   margin-bottom: 8px;
-  color: #6c757d;
-}
-
-/* Default preview styles */
-.default-preview {
-  background-color: #ecf0f1;
+  color: #555;
 }
 
-.preview-icon {
-  font-size: 1.8rem;
-  font-weight: bold;
-  color: #7f8c8d;
+.content-type-label {
+  font-size: 12px;
+  margin-top: 8px;
+  color: #666;
+  max-width: 90%;
   text-align: center;
-  display: flex;
-  align-items: center;
-  justify-content: center;
-  width: 100%;
-  height: 100%;
+  overflow: hidden;
+  text-overflow: ellipsis;
+  white-space: nowrap;
 }
 
-/* Loading indicator styles */
-.preview-loading {
+/* Loading indicator */
+.loading-indicator {
   display: flex;
   align-items: center;
   justify-content: center;
   width: 100%;
   height: 100%;
-  background-color: #f5f5f5;
   color: #666;
-  font-size: 14px;
-  animation: pulse 1.5s infinite;
+  font-size: 24px;
 }
 
-@keyframes pulse {
-  0% {
-    opacity: 0.6;
+/* Responsive adjustments */
+@media (max-width: 768px) {
+  .grid-masonry {
+    grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
+    grid-gap: 15px;
+    padding: 15px;
+  }
+  
+  .grid-item-thumbnail {
+    height: 160px;
+  }
+  
+  .image-thumbnail {
+    height: 160px;
+  }
+}
+
+@media (max-width: 480px) {
+  .grid-masonry {
+    grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
+    grid-gap: 10px;
+    padding: 10px;
+  }
+  
+  .grid-item-thumbnail {
+    height: 140px;
+  }
+  
+  .image-thumbnail {
+    height: 140px;
+  }
+  
+  .grid-item-info {
+    padding: 10px;
   }
-  50% {
-    opacity: 1;
+  
+  .grid-item-title {
+    font-size: 14px;
   }
-  100% {
-    opacity: 0.6;
+  
+  .grid-item-description {
+    font-size: 12px;
+    -webkit-line-clamp: 1;
+    line-clamp: 1;
   }
 }
diff --git a/src/components/viewers/AudioViewer.jsx b/src/components/viewers/AudioViewer.jsx
index 6f4a602..846fbe1 100644
--- a/src/components/viewers/AudioViewer.jsx
+++ b/src/components/viewers/AudioViewer.jsx
@@ -3,16 +3,88 @@ import React, { useState, useEffect } from 'react';
 import PropTypes from 'prop-types';
 import './VideoViewer.css'; // Reuse the same styling as VideoViewer
 
+// Helper function to determine appropriate MIME type
+const getAudioMimeType = (contentType) => {
+  if (!contentType) return 'audio/mpeg'; // Default to MP3 as fallback
+  
+  // Handle direct MIME type
+  if (typeof contentType === 'string') {
+    if (contentType.includes('audio/')) return contentType;
+    
+    // Handle extension-based detection
+    const extensionMap = {
+      'mp3': 'audio/mpeg',
+      'wav': 'audio/wav',
+      'ogg': 'audio/ogg',
+      'flac': 'audio/flac',
+      'm4a': 'audio/m4a',
+      'aac': 'audio/aac'
+    };
+    
+    for (const [ext, mime] of Object.entries(extensionMap)) {
+      if (contentType.toLowerCase().includes(ext)) {
+        return mime;
+      }
+    }
+  }
+  
+  // Handle object-based contentType with mimeType property
+  if (contentType.mimeType && contentType.mimeType.includes('audio/')) {
+    return contentType.mimeType;
+  }
+  
+  // Handle object-based contentType with extension property
+  if (contentType.extension) {
+    const ext = contentType.extension.toLowerCase();
+    switch (ext) {
+      case 'mp3': return 'audio/mpeg';
+      case 'wav': return 'audio/wav';
+      case 'ogg': return 'audio/ogg';
+      case 'flac': return 'audio/flac';
+      case 'm4a': return 'audio/m4a';
+      case 'aac': return 'audio/aac';
+      default: return 'audio/mpeg';
+    }
+  }
+  
+  return 'audio/mpeg'; // Default fallback
+};
+
 const AudioViewer = ({ content, contentType }) => {
   const [src, setSrc] = useState('');
   const [error, setError] = useState(null);
   const [downloadUrl, setDownloadUrl] = useState(null);
   const [failedToLoad, setFailedToLoad] = useState(false);
+  const [audioType, setAudioType] = useState('');
+  const [extension, setExtension] = useState('mp3');
 
   // Function to create download link
-  const createDownloadLink = (blobData, extension = 'wav') => {
+  const createDownloadLink = (blobData) => {
     try {
-      const mimeType = contentType?.mimeType || 'audio/wav';
+      // Detect MIME type for audio content
+      const mimeType = getAudioMimeType(contentType);
+      setAudioType(mimeType);
+      
+      // Set file extension based on MIME type
+      const extMap = {
+        'audio/mpeg': 'mp3',
+        'audio/wav': 'wav',
+        'audio/wave': 'wav',
+        'audio/x-wav': 'wav',
+        'audio/flac': 'flac',
+        'audio/ogg': 'ogg',
+        'audio/m4a': 'm4a',
+        'audio/x-m4a': 'm4a',
+        'audio/mp4': 'm4a',
+        'audio/aac': 'aac',
+        'audio/x-aac': 'aac'
+      };
+      
+      const fileExt = extMap[mimeType] || 
+                     (contentType?.extension ? contentType.extension.toLowerCase() : 'mp3');
+      setExtension(fileExt);
+      
+      // Create the Blob and URL
       const blob = new Blob([blobData], { type: mimeType });
       const url = URL.createObjectURL(blob);
       setDownloadUrl(url);
@@ -30,6 +102,10 @@ const AudioViewer = ({ content, contentType }) => {
       if (content) {
         console.log("AudioViewer: Processing audio content", typeof content);
         
+        // Set audio type from contentType
+        const detectedType = getAudioMimeType(contentType);
+        setAudioType(detectedType);
+        
         // Handle Buffer JSON format
         if (typeof content === 'object' && content !== null && 
             content.type === 'Buffer' && Array.isArray(content.data)) {
@@ -42,8 +118,7 @@ const AudioViewer = ({ content, contentType }) => {
           blobUrl = createDownloadLink(array);
           
           // Use explicit audio MIME type for the player
-          const mimeType = contentType?.mimeType || 'audio/wav';
-          const blob = new Blob([array], { type: mimeType });
+          const blob = new Blob([array], { type: detectedType });
           const url = URL.createObjectURL(blob);
           setSrc(url);
         }
@@ -80,7 +155,10 @@ const AudioViewer = ({ content, contentType }) => {
   const handleError = (e) => {
     console.error("Audio failed to load:", e);
     setFailedToLoad(true);
-    setError("This audio file could not be played in the browser. It may be blocked by your browser settings or extensions, or the format may not be supported.");
+    
+    // Provide more specific error messages based on audio type
+    const format = extension.toUpperCase();
+    setError(`This ${format} audio file could not be played in the browser. It may be blocked by your browser settings or extensions, or the format may not be supported.`);
   };
 
   if (error || failedToLoad) {
@@ -92,7 +170,7 @@ const AudioViewer = ({ content, contentType }) => {
           <div className="mt-4">
             <a 
               href={downloadUrl} 
-              download={`audio-${Date.now()}.${contentType?.extension || 'wav'}`}
+              download={`audio-${Date.now()}.${extension}`}
               className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 inline-block"
             >
               Download Audio File
@@ -123,7 +201,7 @@ const AudioViewer = ({ content, contentType }) => {
             <div className="download-button-container">
               <a 
                 href={downloadUrl} 
-                download={`audio-${Date.now()}.${contentType?.extension || 'wav'}`}
+                download={`audio-${Date.now()}.${extension}`}
                 className="download-button"
                 title="Download audio file"
               >
diff --git a/src/config/content-type-viewers.json b/src/config/content-type-viewers.json
index 7f32b37..1996001 100644
--- a/src/config/content-type-viewers.json
+++ b/src/config/content-type-viewers.json
@@ -90,6 +90,21 @@
       "priority": 100,
       "fallback": "BinaryViewer.jsx"
     },
+    "audio/flac": {
+      "component": "AudioViewer.jsx",
+      "priority": 100,
+      "fallback": "BinaryViewer.jsx"
+    },
+    "audio/ogg": {
+      "component": "AudioViewer.jsx",
+      "priority": 100,
+      "fallback": "BinaryViewer.jsx"
+    },
+    "audio/m4a": {
+      "component": "AudioViewer.jsx",
+      "priority": 100,
+      "fallback": "BinaryViewer.jsx"
+    },
     
     "text/html": {
       "component": "../components/viewers/CodeViewer",
@@ -166,6 +181,21 @@
       "description": "Detect Redux state format to use specialized viewer",
       "test": "typeof content === 'object' && content !== null && (content.cards || content.state || content.todos || content.clm || content.selectedHash !== undefined)",
       "mimeType": "application/redux-state"
+    },
+    {
+      "description": "Detect MP3 audio files with ID3 tags in octet-stream content",
+      "test": "typeof content === 'string' && content.includes('ID3')",
+      "mimeType": "audio/mpeg"
+    },
+    {
+      "description": "Detect WAV audio files in octet-stream content",
+      "test": "typeof content === 'string' && content.includes('RIFF') && content.includes('WAVE')",
+      "mimeType": "audio/wav"
+    },
+    {
+      "description": "Detect MP3 audio files based on content structure when misclassified",
+      "test": "typeof content === 'object' && content !== null && content.type === 'Buffer' && content.data && content.data.length > 10 && ((content.data[0] === 73 && content.data[1] === 68 && content.data[2] === 51) || (content.data[0] === 255 && (content.data[1] === 251 || content.data[1] === 243 || content.data[1] === 242)))",
+      "mimeType": "audio/mpeg"
     }
   ]
 }
diff --git a/src/utils/content_type_detector.js b/src/utils/content_type_detector.js
index 591f9a3..24b2b69 100644
--- a/src/utils/content_type_detector.js
+++ b/src/utils/content_type_detector.js
@@ -21,15 +21,33 @@ const SIGNATURES = new Map([
     [new Uint8Array([0x37, 0x7A, 0xBC, 0xAF, 0x27, 0x1C]), 'application/x-7z-compressed'],
     [new Uint8Array([0x53, 0x51, 0x4C, 0x69, 0x74, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x20, 0x33, 0x00]), 'application/x-sqlite3'],
     [new Uint8Array([0x41, 0x54, 0x26, 0x54, 0x46, 0x4F, 0x52, 0x4D]), 'image/djvu'],
-    [new Uint8Array([0x50, 0x41, 0x52, 0x31]), 'application/x-parquet']
+    [new Uint8Array([0x50, 0x41, 0x52, 0x31]), 'application/x-parquet'],
+    // Audio file signatures
+    [new Uint8Array([0x49, 0x44, 0x33]), 'audio/mpeg'], // MP3 (ID3 tags)
+    [new Uint8Array([0xFF, 0xFB]), 'audio/mpeg'], // MP3 (without ID3)
+    [new Uint8Array([0xFF, 0xF3]), 'audio/mpeg'], // MP3 (without ID3, MPEG 1 Layer 3)
+    [new Uint8Array([0xFF, 0xF2]), 'audio/mpeg'], // MP3 (without ID3, MPEG 2 Layer 3)
+    [new Uint8Array([0x52, 0x49, 0x46, 0x46]), 'audio/wav'], // WAV (RIFF header)
+    [new Uint8Array([0x66, 0x4C, 0x61, 0x43]), 'audio/flac'], // FLAC
+    [new Uint8Array([0x4F, 0x67, 0x67, 0x53]), 'audio/ogg'], // OGG
+    [new Uint8Array([0x4D, 0x34, 0x41, 0x20]), 'audio/m4a'] // M4A
   ]);
-  
+
+  // Audio tag patterns for text-based content detection
+  const AUDIO_TEXT_PATTERNS = [
+    { pattern: /^ID3/i, mimeType: 'audio/mpeg' },  // ID3 tag for MP3
+    { pattern: /^RIFF....WAVE/i, mimeType: 'audio/wav' }, // RIFF....WAVE pattern for WAV
+    { pattern: /^\xFF[\xE0-\xFF]/i, mimeType: 'audio/mpeg' }, // MP3 frame headers
+    { pattern: /^fLaC/i, mimeType: 'audio/flac' }, // FLAC header
+    { pattern: /^OggS/i, mimeType: 'audio/ogg' }  // OGG header
+  ];
+
   const MERMAID_KEYWORDS = [
     'graph', 'sequencediagram', 'classdiagram', 
     'statediagram', 'erdiagram', 'gantt', 
     'pie', 'flowchart', 'journey'
   ];
-  
+
   const EXTENSION_MAP = {
     'image/png': 'png', 'application/json': 'json',
     'text/plain': 'txt', 'text/x-mermaid': 'mmd',
@@ -45,14 +63,26 @@ const SIGNATURES = new Map([
     'application/x-sqlite3': 'db',
     'image/djvu': 'djvu',
     'application/x-parquet': 'parquet',
-    'text/vnd.graphviz': 'dot'
+    'text/vnd.graphviz': 'dot',
+    // Audio mime type to extension mappings
+    'audio/mpeg': 'mp3',
+    'audio/wav': 'wav',
+    'audio/wave': 'wav',
+    'audio/x-wav': 'wav',
+    'audio/flac': 'flac',
+    'audio/ogg': 'ogg',
+    'audio/m4a': 'm4a',
+    'audio/x-m4a': 'm4a',
+    'audio/mp4': 'm4a',
+    'audio/aac': 'aac',
+    'audio/x-aac': 'aac'
   };
-  
+
   function startsWith(content, signature) {
     return content.length >= signature.length && 
       signature.every((byte, index) => content[index] === byte);
   }
-  
+
   function detectBySignature(content) {
     for (const [signature, mimeType] of SIGNATURES.entries()) {
       if (startsWith(content, signature)) return mimeType;
@@ -62,14 +92,14 @@ const SIGNATURES = new Map([
       ? 'application/xml' 
       : 'application/octet-stream';
   }
-  
+
   function detectContentType(content) {
     if (!content) return { 
       mimeType: 'application/octet-stream', 
       extension: '', 
       isValid: false 
     };
-  
+
     if (typeof content === 'string') {
       const trimmedContent = content.trim();
       
@@ -127,6 +157,17 @@ const SIGNATURES = new Map([
         };
       }
       
+      // Audio text-based content detection
+      for (const pattern of AUDIO_TEXT_PATTERNS) {
+        if (pattern.pattern.test(trimmedContent)) {
+          return { 
+            mimeType: pattern.mimeType, 
+            extension: EXTENSION_MAP[pattern.mimeType], 
+            isValid: true 
+          };
+        }
+      }
+      
       // Plain text
       return { 
         mimeType: 'text/plain', 
@@ -134,7 +175,7 @@ const SIGNATURES = new Map([
         isValid: trimmedContent.length > 0 
       };
     }
-  
+
     if (content instanceof Uint8Array) {
       const mimeType = detectBySignature(content);
       return { 
@@ -143,41 +184,41 @@ const SIGNATURES = new Map([
         isValid: mimeType !== 'application/octet-stream'
       };
     }
-  
+
     return { 
       mimeType: 'application/octet-stream', 
       extension: '', 
       isValid: false 
     };
   }
-  
+
   function validateContent(content) {
     if (!content) {
       throw new Error('Invalid text content');
     }
-  
+
     const trimmedContent = typeof content === 'string' ? content.trim() : content;
     
     if (!trimmedContent) {
       throw new Error('Invalid text content');
     }
-  
+
     if (typeof content === 'string') {
       // Mermaid validation
       if (/^graph\s+[A-Z]+/.test(content)) {
         return true;
       }
-  
+
       // Graphviz validation
       if (/^(digraph|graph)\s+\w+\s*{/.test(content)) {
         return true;
       }
-  
+
       // PlantUML validation
       if (/^@startuml/.test(content) && /@enduml/m.test(content)) {
         return true;
       }
-  
+
       // JSON validation
       if (/^\{[\s\S]*\}$/.test(content)) {
         try {
@@ -190,7 +231,7 @@ const SIGNATURES = new Map([
           throw new Error('Invalid JSON content');
         }
       }
-  
+
       // XML validation
       if (/^<\?xml[\s\S]*\?>[\s\S]*<\w+[\s\S]*>[\s\S]*<\/\w+>$/.test(content)) {
         if (!content.includes('<?xml') || !content.includes('</')) {
@@ -198,7 +239,7 @@ const SIGNATURES = new Map([
         }
         return true;
       }
-  
+
       // Diagram validation
       const diagramPatterns = [
         { 
@@ -217,44 +258,44 @@ const SIGNATURES = new Map([
           message: 'Invalid PlantUML diagram content'
         }
       ];
-  
+
       const matchedDiagram = diagramPatterns.find(d => d.pattern.test(content));
       
       if (matchedDiagram) {
         return true;
       }
-  
+
       // Specific test case handling
       if (content === 'invalid json') {
         throw new Error('Invalid JSON content');
       }
-  
+
       if (content === '<unclosed>xml') {
         throw new Error('Invalid XML content');
       }
-  
+
       if (content === 'not a diagram') {
         throw new Error('Invalid diagram content');
       }
-  
+
       if (content === '') {
         throw new Error('Invalid text content');
       }
-  
+
       // If no specific validation passes
       return true;
     }
-  
+
     return true;
   }
-  
+
   function getExtension(mimeType) {
     return EXTENSION_MAP[mimeType] || '';
   }
-  
+
   export { ContentTypeInterpreter as default };
   export { ContentTypeInterpreter };
-  
+
   class ContentTypeInterpreter {
     constructor() {
       // Bind static methods to instance for compatibility
@@ -263,21 +304,20 @@ const SIGNATURES = new Map([
       this.validateContent = ContentTypeInterpreter.validateContent;
       this.getExtension = ContentTypeInterpreter.getExtension;
     }
-  
+
     static detectBySignature(content) {
       return detectBySignature(content);
     }
-  
+
     static detectContentType(content) {
       return detectContentType(content);
     }
-  
+
     static validateContent(content) {
       return validateContent(content);
     }
-  
+
     static getExtension(mimeType) {
       return getExtension(mimeType);
     }
-  }
-  
\ No newline at end of file
+  }
\ No newline at end of file
```
