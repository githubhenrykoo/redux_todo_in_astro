# Git Activity Log - Henry Koo
Generated at: Fri Apr 11 00:43:41 UTC 2025
## Changes by Henry Koo
```diff
commit 4c951d742da9dcac04f36968c2e168de8fa7a47e
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Thu Apr 10 22:28:07 2025 +0800

    Refactor catalog components and improve scrolling layout
    
    The changes include splitting CatalogPanel into smaller components, fixing scrolling issues, and adding CLM reference handling.

diff --git a/Docs/to-do-plan b/Docs/to-do-plan
index b7b5cfa..2716de8 160000
--- a/Docs/to-do-plan
+++ b/Docs/to-do-plan
@@ -1 +1 @@
-Subproject commit b7b5cfa2a5144b55f7a6452695d06d676d019cbb
+Subproject commit 2716de8a952a1d1645a261759e0efad2d151485e
diff --git a/src/components/panels/CLMInputPanel.jsx b/src/components/panels/CLMInputPanel.jsx
index baa8c3c..7eb1e02 100644
--- a/src/components/panels/CLMInputPanel.jsx
+++ b/src/components/panels/CLMInputPanel.jsx
@@ -188,6 +188,7 @@ const CLMInputPanel = () => {
             case 'balancedExpectations':
                 return {
                     dimensionType: "balancedExpectations",
+                    clmReference: currentClmHash || "", // Reference to parent CLM
                     practicalBoundaries: data.balancedExpectations.practicalBoundaries,
                     evaluationMetrics: data.balancedExpectations.evaluationMetrics,
                     feedbackLoops: data.balancedExpectations.feedbackLoops
@@ -215,8 +216,7 @@ const CLMInputPanel = () => {
             // Step 1: Generate JSON-formatted content for each dimension MCard
             const abstractSpecificationJson = generateJsonData('abstractSpecification');
             const concreteImplementationJson = generateJsonData('concreteImplementation');
-            const balancedExpectationsJson = generateJsonData('balancedExpectations');
-
+            
             // Step 2: Store each dimension as its own MCard to get hash references
             // First, save Abstract Specification dimension
             console.log("Saving Abstract Specification dimension...");
@@ -259,38 +259,16 @@ const CLMInputPanel = () => {
             }
             const concreteImplResult = await concreteImplResponse.json();
             const concreteImplHash = concreteImplResult.hash;
-            
-            // Finally, save Balanced Expectations dimension
-            console.log("Saving Balanced Expectations dimension...");
-            const balancedExpResponse = await fetch('/api/card-collection', {
-                method: 'POST',
-                headers: {
-                    'Content-Type': 'application/json'
-                },
-                body: JSON.stringify({
-                    action: 'add',
-                    card: {
-                        content: balancedExpectationsJson
-                    }
-                })
-            });
-            
-            if (!balancedExpResponse.ok) {
-                throw new Error(`Failed to save Balanced Expectations: ${balancedExpResponse.status}`);
-            }
-            const balancedExpResult = await balancedExpResponse.json();
-            const balancedExpHash = balancedExpResult.hash;
 
             // Step 3: Create the root CLM MCard with references to the dimension hashes
             console.log("Creating root CLM with dimension hash references...");
             const rootClmJson = {
                 title: documentTitle,
                 type: 'clm_document',
-                // Reference dimensions by their hash values according to the CLM_for_CLM_Mcard.md spec
+                // Reference only Abstract Specification and Concrete Implementation dimensions by hash
                 dimensions: {
                     abstractSpecification: abstractSpecHash,
-                    concreteImplementation: concreteImplHash,
-                    balancedExpectations: balancedExpHash
+                    concreteImplementation: concreteImplHash
                 }
             };
 
@@ -335,12 +313,42 @@ const CLMInputPanel = () => {
             
             if (result.success) {
                 // Store the CLM hash for future updates
-                setCurrentClmHash(result.hash);
+                const clmHash = result.hash;
+                setCurrentClmHash(clmHash);
+                
+                // NOW save Balanced Expectations dimension with reference to parent CLM
+                console.log("Saving Balanced Expectations dimension with CLM reference...");
+                const balancedExpectationsJson = {
+                    ...generateJsonData('balancedExpectations'),
+                    clmReference: clmHash // Ensure the CLM reference is set to the newly created CLM
+                };
+                
+                const balancedExpResponse = await fetch('/api/card-collection', {
+                    method: 'POST',
+                    headers: {
+                        'Content-Type': 'application/json'
+                    },
+                    body: JSON.stringify({
+                        action: 'add',
+                        card: {
+                            content: balancedExpectationsJson
+                        }
+                    })
+                });
+                
+                if (!balancedExpResponse.ok) {
+                    console.warn(`Note: Failed to save Balanced Expectations: ${balancedExpResponse.status}`);
+                    // Continue anyway as the CLM was saved successfully
+                } else {
+                    const balancedExpResult = await balancedExpResponse.json();
+                    console.log(`Balanced Expectations saved with hash: ${balancedExpResult.hash.substring(0, 10)}...`);
+                }
+                
                 setLastUpdated(new Date().toISOString());
                 
                 setSaveMessage({ 
                     type: 'success', 
-                    text: `CLM data saved successfully! Hash: ${result.hash.substring(0, 10)}...` 
+                    text: `CLM data saved successfully! Hash: ${clmHash.substring(0, 10)}...` 
                 });
             } else {
                 throw new Error(result.error || 'Failed to save CLM data');
@@ -459,6 +467,7 @@ const CLMInputPanel = () => {
                         data={clmData.balancedExpectations}
                         onChange={handleInputChange}
                         generateJsonData={generateJsonData}
+                        clmReference={currentClmHash}
                     />
                 );
             default:
diff --git a/src/components/panels/CatalogPanel.jsx b/src/components/panels/CatalogPanel.jsx
index e51db9e..2392fc5 100644
--- a/src/components/panels/CatalogPanel.jsx
+++ b/src/components/panels/CatalogPanel.jsx
@@ -1,29 +1,26 @@
 import React, { useState, useEffect } from 'react';
-import { useDispatch } from 'react-redux';
-import { importCardFromDatabase, selectContent } from '../../features/contentSlice';
-import { selectItem } from '../../features/selectedItemSlice';
 import '../../styles/CatalogPanel.css';
 
-// Import subcomponents from the catalog directory
+// Import subcomponents
 import CatalogHeader from './catalog/CatalogHeader';
 import GridView from './catalog/GridView';
 import DetailView from './catalog/DetailView';
 import AddItemForm from './catalog/AddItemForm';
 
-// Import our new modules
-import * as api from './catalog/api';
-import { processApiItems, updatePagination, processContentForDisplay } from './catalog/dataHelpers';
-import { getSimpleContentType } from './catalog/utils';
+// Import specialized hooks
+import { useItemActions } from './catalog/ItemActions';
+import { useItemSubmission } from './catalog/ItemSubmission';
+import { useSearchHandler } from './catalog/SearchHandler';
+import { useDataFetcher } from './catalog/DataFetcher';
 
 /**
  * CatalogPanel - Component for displaying and managing catalog items
+ * Refactored into smaller, maintainable pieces
  */
 const CatalogPanel = () => {
-  const dispatch = useDispatch();
-  
   // Main state
   const [items, setItems] = useState([]);
-  const [viewMode, setViewMode] = useState('grid'); // Default to grid view
+  const [viewMode, setViewMode] = useState('grid');
   const [selectedItem, setSelectedItem] = useState(null);
   
   // Loading and error states
@@ -49,6 +46,25 @@ const CatalogPanel = () => {
     items: [], currentPage: 1, totalPages: 1, totalItems: 0, searchTerm: ''
   });
 
+  // Initialize specialized hooks
+  const { fetchCatalogItems, fetchItemsPage } = useDataFetcher({
+    setLoading, setError, setItems, setPagination, pagination
+  });
+  
+  const { handleSelectItem, handleDeleteItem } = useItemActions({
+    setViewMode, setSelectedItem, setItemLoading, setItemError, setItems, selectedItem
+  });
+  
+  const { handleAddItem } = useItemSubmission({
+    setLoading, setError, setItems, setViewMode
+  });
+  
+  const { handleSearchSubmit, clearSearch, fetchSearchPage, handleRefresh } = useSearchHandler({
+    searchTerm, setSearchTerm, isSearchMode, setIsSearchMode, 
+    searchResults, setSearchResults, setSearchLoading, setSearchError,
+    pagination, fetchCatalogItems
+  });
+
   // Computed values
   const displayItems = isSearchMode ? searchResults.items : items;
   const paginationInfo = isSearchMode 
@@ -77,26 +93,6 @@ const CatalogPanel = () => {
     }
   }, [items]);
 
-  // API Handlers
-  const fetchCatalogItems = async () => {
-    setLoading(true);
-    try {
-      const data = await api.fetchItemsPage(1, pagination.pageSize);
-      if (data.success) {
-        const transformedItems = processApiItems(data);
-        setItems(transformedItems);
-        setPagination(updatePagination(data, transformedItems, pagination.pageSize));
-      } else {
-        setError(data.error || 'Failed to fetch items');
-      }
-    } catch (error) {
-      console.error('Error fetching catalog items:', error);
-      setError('Failed to fetch catalog items. Please try again.');
-    } finally {
-      setLoading(false);
-    }
-  };
-
   const handlePageChange = (newPage) => {
     if (isSearchMode) {
       fetchSearchPage(newPage);
@@ -105,253 +101,52 @@ const CatalogPanel = () => {
     }
   };
 
-  const fetchItemsPage = async (newPage) => {
-    setLoading(true);
-    try {
-      const data = await api.fetchItemsPage(newPage, pagination.pageSize);
-      if (data.success) {
-        const transformedItems = processApiItems(data);
-        setItems(transformedItems);
-        setPagination(updatePagination(data, transformedItems, pagination.pageSize));
-      } else {
-        setError(data.error || 'Failed to fetch items');
-      }
-    } catch (error) {
-      console.error('Error fetching catalog items:', error);
-      setError('Failed to fetch catalog items. Please try again.');
-    } finally {
-      setLoading(false);
-    }
-  };
-
-  const fetchSearchPage = async (newPage) => {
-    setSearchLoading(true);
-    try {
-      const data = await api.searchByContent(searchResults.searchTerm, newPage, pagination.pageSize);
-      if (data.success) {
-        const transformedItems = processApiItems(data);
-        setSearchResults({
-          items: transformedItems,
-          currentPage: data.currentPage || newPage,
-          totalPages: data.totalPages || Math.ceil((data.totalResults || data.totalItems || transformedItems.length) / pagination.pageSize),
-          totalItems: data.totalResults || data.totalItems || transformedItems.length,
-          searchTerm: searchResults.searchTerm
-        });
-      } else {
-        setSearchError(data.error || 'Search failed');
-      }
-    } catch (error) {
-      console.error('Error searching catalog items:', error);
-      setSearchError('Search failed. Please try again.');
-    } finally {
-      setSearchLoading(false);
-    }
-  };
-
-  // Item Actions
-  const handleSelectItem = async (item) => {
-    setItemLoading(true);
-    setViewMode('detail');
-    
-    try {
-      const data = await api.getItemByHash(item.id);
-      if (data.success) {
-        const cardData = data.card;
-        const serverContentType = cardData.contentType;
-        const simpleType = serverContentType?.extension || 
-                     (serverContentType?.mimeType ? getSimpleContentType(serverContentType.mimeType) : null) || 
-                     "txt";
-        
-        // Process content for display
-        let description = processContentForDisplay(cardData.content);
-        
-        setSelectedItem({
-          id: cardData.hash,
-          name: cardData.hash.substring(0, 8),
-          category: cardData.contentType?.mimeType || 'Unknown',
-          description: description,
-          hash: cardData.hash,
-          content: cardData.content,
-          timestamp: cardData.timestamp || new Date().toISOString(),
-          contentType: cardData.contentType
-        });
-        
-        // Update Redux store
-        dispatch(importCardFromDatabase({ 
-          hash: cardData.hash,
-          content: cardData.content,
-          metadata: { contentType: serverContentType },
-          relationships: { parentHash: null, childHashes: [], relatedHashes: [] }
-        }));
-        
-        dispatch(selectContent(cardData.hash));
-        dispatch(selectItem({
-          item: cardData.content,
-          hash: cardData.hash,
-          contentType: simpleType,
-          gtime: cardData.timestamp
-        }));
-      } else {
-        setItemError(data.error || 'Failed to fetch card');
-      }
-    } catch (error) {
-      console.error('Error fetching card by ID:', error);
-      setItemError('Failed to fetch card. Please try again.');
-    } finally {
-      setItemLoading(false);
-    }
-  };
-
-  const handleDeleteItem = async (id) => {
-    if (window.confirm('Are you sure you want to delete this item?')) {
-      try {
-        const data = await api.deleteItemByHash(id);
-        if (data.success) {
-          setItems(prevItems => prevItems.filter(item => item.id !== id));
-          if (selectedItem && selectedItem.id === id) {
-            setSelectedItem(null);
-            setViewMode('grid');
-          }
-        } else {
-          setError(data.error || 'Failed to delete item');
-        }
-      } catch (error) {
-        console.error('Error deleting catalog item:', error);
-        setError('Failed to delete item. Please try again.');
-      }
-    }
-  };
-
-  const handleAddItem = (newItemData) => {
-    if (newItemData.file) {
-      addFileItem(newItemData);
-    } else if (newItemData.description) {
-      addTextItem(newItemData);
-    }
-  };
-
-  // UI Handlers
-  const handleRefresh = () => {
-    if (isSearchMode) clearSearch();
-    fetchCatalogItems();
-  };
-
-  const handleSearchSubmit = async (e) => {
-    e.preventDefault();
-    
-    if (!searchTerm.trim()) {
-      clearSearch();
-      return;
-    }
-    
-    setIsSearchMode(true);
-    setSearchLoading(true);
-    
-    try {
-      const data = await api.searchByContent(searchTerm, 1, pagination.pageSize);
-      if (data.success) {
-        const transformedItems = processApiItems(data);
-        setSearchResults({
-          items: transformedItems,
-          currentPage: data.currentPage || 1,
-          totalPages: data.totalPages || Math.ceil((data.totalResults || data.totalItems || transformedItems.length) / pagination.pageSize),
-          totalItems: data.totalResults || data.totalItems || transformedItems.length,
-          searchTerm: searchTerm
-        });
-      } else {
-        setSearchError(data.error || 'Search failed');
-      }
-    } catch (error) {
-      console.error('Error searching catalog items:', error);
-      setSearchError('Search failed. Please try again.');
-    } finally {
-      setSearchLoading(false);
-    }
-  };
-
-  const clearSearch = () => {
-    setIsSearchMode(false);
-    setSearchResults({
-      items: [], currentPage: 1, totalPages: 1, totalItems: 0, searchTerm: ''
-    });
-    setSearchTerm('');
-  };
-
-  const addFileItem = async (newItemData) => {
-    setLoading(true);
-    try {
-      const data = await api.addFileItem(newItemData);
-      if (data.success) {
-        const newCardItem = {
-          id: data.hash,
-          name: newItemData.name,
-          description: newItemData.description || 'Added file',
-          category: newItemData.contentType || 'application/octet-stream',
-          hash: data.hash,
-          timestamp: new Date().toISOString(),
-          contentType: { mimeType: newItemData.contentType || 'application/octet-stream' }
-        };
-        
-        setItems(prevItems => [...prevItems, newCardItem]);
-        setViewMode('grid');
-      } else {
-        setError(data.error || 'Failed to add item');
-      }
-    } catch (error) {
-      console.error('Error adding catalog item:', error);
-      setError(`Failed to add item: ${error.message}`);
-    } finally {
-      setLoading(false);
-    }
-  };
-
-  const addTextItem = async (newItemData) => {
-    setLoading(true);
-    try {
-      const data = await api.addTextItem(newItemData);
-      if (data.success) {
-        const newCardItem = {
-          id: data.hash,
-          name: newItemData.name,
-          description: newItemData.description.substring(0, 100) + (newItemData.description.length > 100 ? '...' : ''),
-          category: newItemData.contentType || 'text/plain',
-          hash: data.hash,
-          timestamp: new Date().toISOString(),
-          contentType: { mimeType: newItemData.contentType || 'text/plain' }
-        };
-        
-        setItems(prevItems => [...prevItems, newCardItem]);
-        setViewMode('grid');
-      } else {
-        setError(data.error || 'Failed to add item');
-      }
-    } catch (error) {
-      console.error('Error adding catalog item:', error);
-      setError(`Failed to add item: ${error.message}`);
-    } finally {
-      setLoading(false);
-    }
-  };
-
   // Render main component
   return (
-    <div className="catalog-panel" style={{ height: '100%', width: '100%', display: 'flex', flexDirection: 'column' }}>
-      <CatalogHeader 
-        viewMode={viewMode}
-        setViewMode={setViewMode}
-        searchTerm={searchTerm}
-        setSearchTerm={setSearchTerm}
-        isSearchMode={isSearchMode}
-        categories={categories}
-        filter={filter}
-        setFilter={setFilter}
-        handleSearchSubmit={handleSearchSubmit}
-        handleClearSearch={clearSearch}
-        handleRefresh={handleRefresh}
-        searchResults={searchResults}
-      />
+    <div className="catalog-panel" style={{ 
+      height: '100%', 
+      width: '100%', 
+      position: 'relative',
+      overflow: 'hidden'
+    }}>
+      {/* Fixed header at top */}
+      <div style={{
+        position: 'absolute',
+        top: 0,
+        left: 0,
+        right: 0,
+        zIndex: 10,
+        backgroundColor: 'var(--panel-header-bg, #2c2c2c)', /* Restore original header background */
+        borderBottom: '1px solid var(--border-color, #3e3e3e)' /* Restore border */
+      }}>
+        <CatalogHeader 
+          viewMode={viewMode}
+          setViewMode={setViewMode}
+          searchTerm={searchTerm}
+          setSearchTerm={setSearchTerm}
+          isSearchMode={isSearchMode}
+          categories={categories}
+          filter={filter}
+          setFilter={setFilter}
+          handleSearchSubmit={handleSearchSubmit}
+          handleClearSearch={clearSearch}
+          handleRefresh={handleRefresh}
+          searchResults={searchResults}
+        />
+      </div>
       
-      <div className="catalog-content" style={{ flex: 1, overflow: 'auto', position: 'relative' }}>
+      {/* Scrollable content area with offset for header */}
+      <div style={{ 
+        position: 'absolute',
+        top: '110px', /* Increased from 60px to account for full header height including search */
+        bottom: 0,
+        left: 0,
+        right: 0,
+        overflowY: 'scroll',
+        overflowX: 'hidden',
+        padding: '0',
+        backgroundColor: 'var(--bg-color, #1e1e1e)' /* Use CSS variable for background */
+      }}>
         {viewMode === 'grid' && (
           <GridView 
             loading={loading || searchLoading}
diff --git a/src/components/panels/catalog/DataFetcher.jsx b/src/components/panels/catalog/DataFetcher.jsx
new file mode 100644
index 0000000..acf08dd
--- /dev/null
+++ b/src/components/panels/catalog/DataFetcher.jsx
@@ -0,0 +1,68 @@
+import React from 'react';
+import * as api from './api';
+import { processApiItems, updatePagination } from './dataHelpers';
+
+/**
+ * Custom hook for handling data fetching operations
+ * @param {Object} options - Options object
+ * @returns {Object} - Actions and state
+ */
+export const useDataFetcher = ({
+  setLoading,
+  setError,
+  setItems,
+  setPagination,
+  pagination
+}) => {
+  /**
+   * Fetch initial catalog items
+   */
+  const fetchCatalogItems = async () => {
+    setLoading(true);
+    try {
+      const data = await api.fetchItemsPage(1, pagination.pageSize);
+      if (data.success) {
+        const transformedItems = processApiItems(data);
+        setItems(transformedItems);
+        setPagination(updatePagination(data, transformedItems, pagination.pageSize));
+      } else {
+        setError(data.error || 'Failed to fetch items');
+      }
+    } catch (error) {
+      console.error('Error fetching catalog items:', error);
+      setError('Failed to fetch catalog items. Please try again.');
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  /**
+   * Fetch a specific page of items
+   * @param {number} newPage - Page number to fetch
+   */
+  const fetchItemsPage = async (newPage) => {
+    setLoading(true);
+    try {
+      const data = await api.fetchItemsPage(newPage, pagination.pageSize);
+      if (data.success) {
+        const transformedItems = processApiItems(data);
+        setItems(transformedItems);
+        setPagination(updatePagination(data, transformedItems, pagination.pageSize));
+      } else {
+        setError(data.error || 'Failed to fetch items');
+      }
+    } catch (error) {
+      console.error('Error fetching catalog items:', error);
+      setError('Failed to fetch catalog items. Please try again.');
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  return {
+    fetchCatalogItems,
+    fetchItemsPage
+  };
+};
+
+export default useDataFetcher;
diff --git a/src/components/panels/catalog/GridView.jsx b/src/components/panels/catalog/GridView.jsx
index 389aa68..0a83985 100644
--- a/src/components/panels/catalog/GridView.jsx
+++ b/src/components/panels/catalog/GridView.jsx
@@ -181,74 +181,113 @@ const GridView = ({
   }
 
   return (
-    <>
-      <div className="catalog-grid-view grid-masonry">
-        {sortedItems.map(item => {
-          // Use verified content type if available
-          const verifiedItem = verifiedItems[item.id];
-          const displayItem = verifiedItem && verifiedItem.isVerified
-            ? { ...item, contentType: verifiedItem.contentType }
-            : item;
-          
-          const isImage = isImageItem(displayItem);
-          
-          return (
-            <div 
-              key={item.id} 
-              className={`grid-item ${isImage ? 'grid-item-image' : 'grid-item-other'}`}
-              onMouseEnter={() => setHoveredItem(item.id)}
-              onMouseLeave={() => setHoveredItem(null)}
-            >
+    <div style={{
+      width: '100%',
+      height: '100%',
+      display: 'flex',
+      flexDirection: 'column',
+      position: 'relative'
+    }}>
+      {/* Main scrollable grid container */}
+      <div style={{
+        position: 'absolute',
+        top: 0,
+        left: 0,
+        right: 0,
+        bottom: '50px', /* Space for pagination */
+        overflowY: 'scroll',
+        overflowX: 'hidden',
+        padding: '16px 16px 0 16px'
+      }}>
+        {/* Grid layout */}
+        <div style={{
+          display: 'grid',
+          gridTemplateColumns: 'repeat(auto-fill, minmax(220px, 1fr))',
+          gap: '20px',
+          width: '100%',
+          paddingTop: '16px', /* Add padding to fix first row cards being cut off */
+          paddingBottom: '70px'
+        }}>
+          {sortedItems.map(item => {
+            // Use verified content type if available
+            const verifiedItem = verifiedItems[item.id];
+            const displayItem = verifiedItem && verifiedItem.isVerified
+              ? { ...item, contentType: verifiedItem.contentType }
+              : item;
+            
+            const isImage = isImageItem(displayItem);
+            
+            return (
               <div 
-                className={`grid-item-card ${hoveredItem === item.id ? 'hovered' : ''}`}
-                onClick={() => onSelectItem(item)}
+                key={item.id} 
+                className={`grid-item ${isImage ? 'grid-item-image' : 'grid-item-other'}`}
+                onMouseEnter={() => setHoveredItem(item.id)}
+                onMouseLeave={() => setHoveredItem(null)}
               >
-                <div className={`grid-item-thumbnail ${isImage ? 'image-thumbnail' : ''}`}>
-                  <GridItemPreview item={displayItem} />
-                </div>
-                <div className="grid-item-info">
-                  <h3 className="grid-item-title" style={{ color: '#000000', fontWeight: 'bold' }}>
-                    {item.id.substring(0, 8)}
-                  </h3>
-                  <div className="grid-item-meta">
-                    <span className="grid-item-type" style={{ 
-                      color: '#000000', 
-                      fontWeight: 'bold',
-                      backgroundColor: '#ffffff',
-                      border: '1px solid #000000'
-                    }}>
-                      {getFormattedContentType(displayItem)}
-                    </span>
-                    <span className="grid-item-date" style={{ color: '#000000', fontWeight: 'bold' }}>
-                      {new Date(item.timestamp).toLocaleDateString()}
-                    </span>
+                <div 
+                  className={`grid-item-card ${hoveredItem === item.id ? 'hovered' : ''}`}
+                  onClick={() => onSelectItem(item)}
+                >
+                  <div className={`grid-item-thumbnail ${isImage ? 'image-thumbnail' : ''}`}>
+                    <GridItemPreview item={displayItem} />
+                  </div>
+                  <div className="grid-item-info">
+                    <h3 className="grid-item-title" style={{ color: '#000000', fontWeight: 'bold' }}>
+                      {item.id.substring(0, 8)}
+                    </h3>
+                    <div className="grid-item-meta">
+                      <span className="grid-item-type" style={{ 
+                        color: '#000000', 
+                        fontWeight: 'bold',
+                        backgroundColor: '#ffffff',
+                        border: '1px solid #000000'
+                      }}>
+                        {getFormattedContentType(displayItem)}
+                      </span>
+                      <span className="grid-item-date" style={{ color: '#000000', fontWeight: 'bold' }}>
+                        {new Date(item.timestamp).toLocaleDateString()}
+                      </span>
+                    </div>
+                  </div>
+                  <div className={`grid-item-actions ${hoveredItem === item.id ? 'visible' : ''}`}>
+                    <button 
+                      className="btn btn-small btn-danger"
+                      onClick={(e) => {
+                        e.stopPropagation();
+                        onDeleteItem(item.id);
+                      }}
+                    >
+                      Delete
+                    </button>
                   </div>
-                  <p className="grid-item-description" style={{ color: '#000000', fontWeight: 'medium' }}>
-                    {item.description || "No description available"}
-                  </p>
-                </div>
-                <div className={`grid-item-actions ${hoveredItem === item.id ? 'visible' : ''}`}>
-                  <button 
-                    className="btn btn-small btn-danger"
-                    onClick={(e) => {
-                      e.stopPropagation();
-                      onDeleteItem(item.id);
-                    }}
-                  >
-                    Delete
-                  </button>
                 </div>
               </div>
-            </div>
-          );
-        })}
+            );
+          })}
+        </div>
       </div>
       
-      <PaginationControls 
-        paginationInfo={paginationInfo} 
-        onPageChange={onPageChange} 
-      />
-    </>
+      {/* Fixed pagination at bottom */}
+      <div style={{ 
+        position: 'absolute', 
+        bottom: 0, 
+        left: 0, 
+        right: 0, 
+        height: '50px',
+        borderTop: '1px solid var(--border-color, #3e3e3e)',
+        backgroundColor: 'var(--panel-subheader-bg, #262626)',
+        padding: '8px',
+        display: 'flex',
+        alignItems: 'center',
+        justifyContent: 'center',
+        zIndex: 5
+      }}>
+        <PaginationControls 
+          paginationInfo={paginationInfo} 
+          onPageChange={onPageChange} 
+        />
+      </div>
+    </div>
   );
 };
 
diff --git a/src/components/panels/catalog/ItemActions.jsx b/src/components/panels/catalog/ItemActions.jsx
new file mode 100644
index 0000000..883c3ac
--- /dev/null
+++ b/src/components/panels/catalog/ItemActions.jsx
@@ -0,0 +1,111 @@
+import React from 'react';
+import { useDispatch } from 'react-redux';
+import { importCardFromDatabase, selectContent } from '../../../features/contentSlice';
+import { selectItem } from '../../../features/selectedItemSlice';
+import { processContentForDisplay } from './dataHelpers';
+import { getSimpleContentType } from './utils';
+import * as api from './api';
+
+/**
+ * Custom hook for handling item-related actions
+ * @param {Object} options - Options object
+ * @returns {Object} - Actions and state
+ */
+export const useItemActions = ({
+  setViewMode,
+  setSelectedItem,
+  setItemLoading,
+  setItemError,
+  setItems,
+  selectedItem
+}) => {
+  const dispatch = useDispatch();
+
+  /**
+   * Select an item by ID and load its details
+   * @param {Object} item - The item to select
+   */
+  const handleSelectItem = async (item) => {
+    setItemLoading(true);
+    setViewMode('detail');
+    
+    try {
+      const data = await api.getItemByHash(item.id);
+      if (data.success) {
+        const cardData = data.card;
+        const serverContentType = cardData.contentType;
+        const simpleType = serverContentType?.extension || 
+                     (serverContentType?.mimeType ? getSimpleContentType(serverContentType.mimeType) : null) || 
+                     "txt";
+        
+        // Process content for display
+        let description = processContentForDisplay(cardData.content);
+        
+        setSelectedItem({
+          id: cardData.hash,
+          name: cardData.hash.substring(0, 8),
+          category: cardData.contentType?.mimeType || 'Unknown',
+          description: description,
+          hash: cardData.hash,
+          content: cardData.content,
+          timestamp: cardData.timestamp || new Date().toISOString(),
+          contentType: cardData.contentType
+        });
+        
+        // Update Redux store
+        dispatch(importCardFromDatabase({ 
+          hash: cardData.hash,
+          content: cardData.content,
+          metadata: { contentType: serverContentType },
+          relationships: { parentHash: null, childHashes: [], relatedHashes: [] }
+        }));
+        
+        dispatch(selectContent(cardData.hash));
+        dispatch(selectItem({
+          item: cardData.content,
+          hash: cardData.hash,
+          contentType: simpleType,
+          gtime: cardData.timestamp
+        }));
+      } else {
+        setItemError(data.error || 'Failed to fetch card');
+      }
+    } catch (error) {
+      console.error('Error fetching card by ID:', error);
+      setItemError('Failed to fetch card. Please try again.');
+    } finally {
+      setItemLoading(false);
+    }
+  };
+
+  /**
+   * Delete an item by ID
+   * @param {string} id - The item ID to delete
+   */
+  const handleDeleteItem = async (id) => {
+    if (window.confirm('Are you sure you want to delete this item?')) {
+      try {
+        const data = await api.deleteItemByHash(id);
+        if (data.success) {
+          setItems(prevItems => prevItems.filter(item => item.id !== id));
+          if (selectedItem && selectedItem.id === id) {
+            setSelectedItem(null);
+            setViewMode('grid');
+          }
+        } else {
+          setItemError(data.error || 'Failed to delete item');
+        }
+      } catch (error) {
+        console.error('Error deleting catalog item:', error);
+        setItemError('Failed to delete item. Please try again.');
+      }
+    }
+  };
+
+  return {
+    handleSelectItem,
+    handleDeleteItem
+  };
+};
+
+export default useItemActions;
diff --git a/src/components/panels/catalog/ItemSubmission.jsx b/src/components/panels/catalog/ItemSubmission.jsx
new file mode 100644
index 0000000..a4d76da
--- /dev/null
+++ b/src/components/panels/catalog/ItemSubmission.jsx
@@ -0,0 +1,96 @@
+import React from 'react';
+import * as api from './api';
+
+/**
+ * Custom hook for handling item submission
+ * @param {Object} options - Options object
+ * @returns {Object} - Actions and state
+ */
+export const useItemSubmission = ({
+  setLoading,
+  setError,
+  setItems,
+  setViewMode
+}) => {
+  /**
+   * Add a new item (text or file)
+   * @param {Object} newItemData - The new item data to add
+   */
+  const handleAddItem = (newItemData) => {
+    if (newItemData.file) {
+      addFileItem(newItemData);
+    } else if (newItemData.description) {
+      addTextItem(newItemData);
+    }
+  };
+
+  /**
+   * Add a file item to the catalog
+   * @param {Object} newItemData - The new item data
+   */
+  const addFileItem = async (newItemData) => {
+    setLoading(true);
+    try {
+      const data = await api.addFileItem(newItemData);
+      if (data.success) {
+        const newCardItem = {
+          id: data.hash,
+          name: newItemData.name,
+          description: newItemData.description || 'Added file',
+          category: newItemData.contentType || 'application/octet-stream',
+          hash: data.hash,
+          timestamp: new Date().toISOString(),
+          contentType: { mimeType: newItemData.contentType || 'application/octet-stream' }
+        };
+        
+        setItems(prevItems => [...prevItems, newCardItem]);
+        setViewMode('grid');
+      } else {
+        setError(data.error || 'Failed to add item');
+      }
+    } catch (error) {
+      console.error('Error adding catalog item:', error);
+      setError(`Failed to add item: ${error.message}`);
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  /**
+   * Add a text item to the catalog
+   * @param {Object} newItemData - The new item data
+   */
+  const addTextItem = async (newItemData) => {
+    setLoading(true);
+    try {
+      const data = await api.addTextItem(newItemData);
+      if (data.success) {
+        const newCardItem = {
+          id: data.hash,
+          name: newItemData.name,
+          description: newItemData.description.substring(0, 100) + (newItemData.description.length > 100 ? '...' : ''),
+          category: newItemData.contentType || 'text/plain',
+          hash: data.hash,
+          timestamp: new Date().toISOString(),
+          contentType: { mimeType: newItemData.contentType || 'text/plain' }
+        };
+        
+        setItems(prevItems => [...prevItems, newCardItem]);
+        setViewMode('grid');
+      } else {
+        setError(data.error || 'Failed to add item');
+      }
+    } catch (error) {
+      console.error('Error adding catalog item:', error);
+      setError(`Failed to add item: ${error.message}`);
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  return {
+    handleAddItem
+  };
+};
+
+export default useItemSubmission;
diff --git a/src/components/panels/catalog/SearchHandler.jsx b/src/components/panels/catalog/SearchHandler.jsx
new file mode 100644
index 0000000..5a4487c
--- /dev/null
+++ b/src/components/panels/catalog/SearchHandler.jsx
@@ -0,0 +1,114 @@
+import React from 'react';
+import * as api from './api';
+import { processApiItems } from './dataHelpers';
+
+/**
+ * Custom hook for handling search functionality
+ * @param {Object} options - Options object
+ * @returns {Object} - Actions and state
+ */
+export const useSearchHandler = ({
+  searchTerm,
+  setSearchTerm,
+  isSearchMode,
+  setIsSearchMode,
+  searchResults,
+  setSearchResults,
+  setSearchLoading,
+  setSearchError,
+  pagination,
+  fetchCatalogItems
+}) => {
+  /**
+   * Handle search form submission
+   * @param {Event} e - Form submit event
+   */
+  const handleSearchSubmit = async (e) => {
+    e.preventDefault();
+    
+    if (!searchTerm.trim()) {
+      clearSearch();
+      return;
+    }
+    
+    setIsSearchMode(true);
+    setSearchLoading(true);
+    
+    try {
+      const data = await api.searchByContent(searchTerm, 1, pagination.pageSize);
+      if (data.success) {
+        const transformedItems = processApiItems(data);
+        setSearchResults({
+          items: transformedItems,
+          currentPage: data.currentPage || 1,
+          totalPages: data.totalPages || Math.ceil((data.totalResults || data.totalItems || transformedItems.length) / pagination.pageSize),
+          totalItems: data.totalResults || data.totalItems || transformedItems.length,
+          searchTerm: searchTerm
+        });
+      } else {
+        setSearchError(data.error || 'Search failed');
+      }
+    } catch (error) {
+      console.error('Error searching catalog items:', error);
+      setSearchError('Search failed. Please try again.');
+    } finally {
+      setSearchLoading(false);
+    }
+  };
+
+  /**
+   * Clear the current search and reset to normal view
+   */
+  const clearSearch = () => {
+    setIsSearchMode(false);
+    setSearchResults({
+      items: [], currentPage: 1, totalPages: 1, totalItems: 0, searchTerm: ''
+    });
+    setSearchTerm('');
+  };
+
+  /**
+   * Fetch a specific page of search results
+   * @param {number} newPage - Page number to fetch
+   */
+  const fetchSearchPage = async (newPage) => {
+    setSearchLoading(true);
+    try {
+      const data = await api.searchByContent(searchResults.searchTerm, newPage, pagination.pageSize);
+      if (data.success) {
+        const transformedItems = processApiItems(data);
+        setSearchResults({
+          items: transformedItems,
+          currentPage: data.currentPage || newPage,
+          totalPages: data.totalPages || Math.ceil((data.totalResults || data.totalItems || transformedItems.length) / pagination.pageSize),
+          totalItems: data.totalResults || data.totalItems || transformedItems.length,
+          searchTerm: searchResults.searchTerm
+        });
+      } else {
+        setSearchError(data.error || 'Search failed');
+      }
+    } catch (error) {
+      console.error('Error searching catalog items:', error);
+      setSearchError('Search failed. Please try again.');
+    } finally {
+      setSearchLoading(false);
+    }
+  };
+
+  /**
+   * Refresh the catalog or clear search
+   */
+  const handleRefresh = () => {
+    if (isSearchMode) clearSearch();
+    fetchCatalogItems();
+  };
+
+  return {
+    handleSearchSubmit,
+    clearSearch,
+    fetchSearchPage,
+    handleRefresh
+  };
+};
+
+export default useSearchHandler;
diff --git a/src/components/panels/clm/BalancedExpectations.jsx b/src/components/panels/clm/BalancedExpectations.jsx
index 702f23f..6c93fe5 100644
--- a/src/components/panels/clm/BalancedExpectations.jsx
+++ b/src/components/panels/clm/BalancedExpectations.jsx
@@ -1,7 +1,7 @@
 import React from 'react';
 import DimensionPanel from './DimensionPanel';
 
-const BalancedExpectations = ({ data, onChange, generateJsonData }) => {
+const BalancedExpectations = ({ data, onChange, generateJsonData, clmReference }) => {
     console.log("BalancedExpectations rendered with data:", data);
     
     // Define fields according to CLM_for_CLM_Mcard.md spec
@@ -40,6 +40,7 @@ const BalancedExpectations = ({ data, onChange, generateJsonData }) => {
         // Create a clean object for JSON preview
         return {
             dimensionType: "balancedExpectations",
+            clmReference: clmReference || "", // Include reference to parent CLM
             practicalBoundaries: data.practicalBoundaries || "",
             evaluationMetrics: data.evaluationMetrics || "",
             feedbackLoops: data.feedbackLoops || ""
diff --git a/src/features/panellayoutSlice.json b/src/features/panellayoutSlice.json
index 89085a6..4e69b0d 100644
--- a/src/features/panellayoutSlice.json
+++ b/src/features/panellayoutSlice.json
@@ -187,7 +187,7 @@
             "visible": true
         },
         "middle": {
-            "type": "ContentViewerPanel", 
+            "type": "CLMInputPanel", 
             "size": 30,
             "minSize": 0,
             "visible": false
diff --git a/src/styles/CatalogPanel.css b/src/styles/CatalogPanel.css
index f33a810..2d17b68 100644
--- a/src/styles/CatalogPanel.css
+++ b/src/styles/CatalogPanel.css
@@ -8,6 +8,7 @@
   border-radius: 8px;
   overflow: hidden;
   position: relative;
+  max-height: 100vh; /* Ensure it doesn't exceed viewport height */
 }
 
 .panel-header {
@@ -142,12 +143,13 @@
   flex: 1;
   overflow-y: auto;
   overflow-x: hidden !important; /* Force no horizontal overflow */
-  padding: 15px;
+  padding: 0; /* Remove padding to let child components handle it */
   width: 100%;
   position: relative;
   display: flex;
   flex-direction: column;
-  min-height: 300px; /* Ensure minimum height */
+  min-height: 0; /* Critical for flex items to properly scroll */
+  max-height: calc(100vh - 120px); /* Subtract header heights */
   max-width: 100%;
   box-sizing: border-box;
 }
@@ -167,10 +169,13 @@
   gap: 20px;
   padding: 15px;
   width: 100%;
-  min-height: 300px;
+  min-height: 0; /* Critical for vertical scrolling */
+  overflow-y: auto; /* Enable vertical scrolling */
   overflow-x: hidden !important; /* Force no horizontal overflow */
   max-width: 100%;
+  height: 100%; /* Take full height of parent */
   box-sizing: border-box;
+  align-content: start; /* Start content at the top */
 }
 
 .catalog-detail-view {

commit 2293b454c1cb3e27bf227d4e3406eef536c6d242
Author: Henry Koo <lckoo1230@gmail.com>
Date:   Thu Apr 10 17:48:09 2025 +0800

    better catalogPanle

diff --git a/package.json b/package.json
index 4232409..9186b48 100644
--- a/package.json
+++ b/package.json
@@ -45,6 +45,7 @@
     "dotenv": "^16.4.7",
     "express": "^5.1.0",
     "gapi-script": "^1.2.0",
+    "googleapis": "^148.0.0",
     "http": "^0.0.1-security",
     "jimp": "^0.22.8",
     "lucide-react": "^0.284.0",
diff --git a/src/components/panels/CatalogPanel.jsx b/src/components/panels/CatalogPanel.jsx
index b1e1e23..e51db9e 100644
--- a/src/components/panels/CatalogPanel.jsx
+++ b/src/components/panels/CatalogPanel.jsx
@@ -9,6 +9,10 @@ import CatalogHeader from './catalog/CatalogHeader';
 import GridView from './catalog/GridView';
 import DetailView from './catalog/DetailView';
 import AddItemForm from './catalog/AddItemForm';
+
+// Import our new modules
+import * as api from './catalog/api';
+import { processApiItems, updatePagination, processContentForDisplay } from './catalog/dataHelpers';
 import { getSimpleContentType } from './catalog/utils';
 
 /**
@@ -74,24 +78,23 @@ const CatalogPanel = () => {
   }, [items]);
 
   // API Handlers
-  const fetchCatalogItems = () => {
+  const fetchCatalogItems = async () => {
     setLoading(true);
-    fetch(`/api/card-collection?action=getPage&pageNumber=1&pageSize=${pagination.pageSize}`)
-      .then(response => response.json())
-      .then(data => {
-        if (data.success) {
-          const transformedItems = processApiItems(data);
-          setItems(transformedItems);
-          updatePagination(data, transformedItems);
-        } else {
-          setError(data.error || 'Failed to fetch items');
-        }
-      })
-      .catch(error => {
-        console.error('Error fetching catalog items:', error);
-        setError('Failed to fetch catalog items. Please try again.');
-      })
-      .finally(() => setLoading(false));
+    try {
+      const data = await api.fetchItemsPage(1, pagination.pageSize);
+      if (data.success) {
+        const transformedItems = processApiItems(data);
+        setItems(transformedItems);
+        setPagination(updatePagination(data, transformedItems, pagination.pageSize));
+      } else {
+        setError(data.error || 'Failed to fetch items');
+      }
+    } catch (error) {
+      console.error('Error fetching catalog items:', error);
+      setError('Failed to fetch catalog items. Please try again.');
+    } finally {
+      setLoading(false);
+    }
   };
 
   const handlePageChange = (newPage) => {
@@ -102,125 +105,120 @@ const CatalogPanel = () => {
     }
   };
 
-  const fetchItemsPage = (newPage) => {
+  const fetchItemsPage = async (newPage) => {
     setLoading(true);
-    fetch(`/api/card-collection?action=getPage&pageNumber=${newPage}&pageSize=${pagination.pageSize}`)
-      .then(response => response.json())
-      .then(data => {
-        if (data.success) {
-          const transformedItems = processApiItems(data);
-          setItems(transformedItems);
-          updatePagination(data, transformedItems);
-        } else {
-          setError(data.error || 'Failed to fetch items');
-        }
-      })
-      .catch(error => {
-        console.error('Error fetching catalog items:', error);
-        setError('Failed to fetch catalog items. Please try again.');
-      })
-      .finally(() => setLoading(false));
+    try {
+      const data = await api.fetchItemsPage(newPage, pagination.pageSize);
+      if (data.success) {
+        const transformedItems = processApiItems(data);
+        setItems(transformedItems);
+        setPagination(updatePagination(data, transformedItems, pagination.pageSize));
+      } else {
+        setError(data.error || 'Failed to fetch items');
+      }
+    } catch (error) {
+      console.error('Error fetching catalog items:', error);
+      setError('Failed to fetch catalog items. Please try again.');
+    } finally {
+      setLoading(false);
+    }
   };
 
-  const fetchSearchPage = (newPage) => {
+  const fetchSearchPage = async (newPage) => {
     setSearchLoading(true);
-    fetch(`/api/card-collection?action=searchByContent&searchTerm=${encodeURIComponent(searchResults.searchTerm)}&pageNumber=${newPage}&pageSize=${pagination.pageSize}`)
-      .then(response => response.json())
-      .then(data => {
-        if (data.success) {
-          const transformedItems = processApiItems(data);
-          setSearchResults({
-            items: transformedItems,
-            currentPage: data.currentPage || newPage,
-            totalPages: data.totalPages || Math.ceil((data.totalResults || data.totalItems || transformedItems.length) / pagination.pageSize),
-            totalItems: data.totalResults || data.totalItems || transformedItems.length,
-            searchTerm: searchResults.searchTerm
-          });
-        } else {
-          setSearchError(data.error || 'Search failed');
-        }
-      })
-      .catch(error => {
-        console.error('Error searching catalog items:', error);
-        setSearchError('Search failed. Please try again.');
-      })
-      .finally(() => setSearchLoading(false));
+    try {
+      const data = await api.searchByContent(searchResults.searchTerm, newPage, pagination.pageSize);
+      if (data.success) {
+        const transformedItems = processApiItems(data);
+        setSearchResults({
+          items: transformedItems,
+          currentPage: data.currentPage || newPage,
+          totalPages: data.totalPages || Math.ceil((data.totalResults || data.totalItems || transformedItems.length) / pagination.pageSize),
+          totalItems: data.totalResults || data.totalItems || transformedItems.length,
+          searchTerm: searchResults.searchTerm
+        });
+      } else {
+        setSearchError(data.error || 'Search failed');
+      }
+    } catch (error) {
+      console.error('Error searching catalog items:', error);
+      setSearchError('Search failed. Please try again.');
+    } finally {
+      setSearchLoading(false);
+    }
   };
 
   // Item Actions
-  const handleSelectItem = (item) => {
+  const handleSelectItem = async (item) => {
     setItemLoading(true);
     setViewMode('detail');
     
-    fetch(`/api/card-collection?action=get&hash=${item.id}`)
-      .then(response => response.json())
-      .then(data => {
-        if (data.success) {
-          const cardData = data.card;
-          const serverContentType = cardData.contentType;
-          const simpleType = serverContentType?.extension || 
-                         (serverContentType?.mimeType ? getSimpleContentType(serverContentType.mimeType) : null) || 
-                         "txt";
-          
-          // Process content for display
-          let description = processContentForDisplay(cardData.content);
-          
-          setSelectedItem({
-            id: cardData.hash,
-            name: cardData.hash.substring(0, 8),
-            category: cardData.contentType?.mimeType || 'Unknown',
-            description: description,
-            hash: cardData.hash,
-            content: cardData.content,
-            timestamp: cardData.timestamp || new Date().toISOString(),
-            contentType: cardData.contentType
-          });
-          
-          // Update Redux store
-          dispatch(importCardFromDatabase({ 
-            hash: cardData.hash,
-            content: cardData.content,
-            metadata: { contentType: serverContentType },
-            relationships: { parentHash: null, childHashes: [], relatedHashes: [] }
-          }));
-          
-          dispatch(selectContent(cardData.hash));
-          dispatch(selectItem({
-            item: cardData.content,
-            hash: cardData.hash,
-            contentType: simpleType,
-            gtime: cardData.timestamp
-          }));
-        } else {
-          setItemError(data.error || 'Failed to fetch card');
-        }
-      })
-      .catch(error => {
-        console.error('Error fetching card by ID:', error);
-        setItemError('Failed to fetch card. Please try again.');
-      })
-      .finally(() => setItemLoading(false));
+    try {
+      const data = await api.getItemByHash(item.id);
+      if (data.success) {
+        const cardData = data.card;
+        const serverContentType = cardData.contentType;
+        const simpleType = serverContentType?.extension || 
+                     (serverContentType?.mimeType ? getSimpleContentType(serverContentType.mimeType) : null) || 
+                     "txt";
+        
+        // Process content for display
+        let description = processContentForDisplay(cardData.content);
+        
+        setSelectedItem({
+          id: cardData.hash,
+          name: cardData.hash.substring(0, 8),
+          category: cardData.contentType?.mimeType || 'Unknown',
+          description: description,
+          hash: cardData.hash,
+          content: cardData.content,
+          timestamp: cardData.timestamp || new Date().toISOString(),
+          contentType: cardData.contentType
+        });
+        
+        // Update Redux store
+        dispatch(importCardFromDatabase({ 
+          hash: cardData.hash,
+          content: cardData.content,
+          metadata: { contentType: serverContentType },
+          relationships: { parentHash: null, childHashes: [], relatedHashes: [] }
+        }));
+        
+        dispatch(selectContent(cardData.hash));
+        dispatch(selectItem({
+          item: cardData.content,
+          hash: cardData.hash,
+          contentType: simpleType,
+          gtime: cardData.timestamp
+        }));
+      } else {
+        setItemError(data.error || 'Failed to fetch card');
+      }
+    } catch (error) {
+      console.error('Error fetching card by ID:', error);
+      setItemError('Failed to fetch card. Please try again.');
+    } finally {
+      setItemLoading(false);
+    }
   };
 
-  const handleDeleteItem = (id) => {
+  const handleDeleteItem = async (id) => {
     if (window.confirm('Are you sure you want to delete this item?')) {
-      fetch(`/api/card-collection?action=delete&hash=${id}`, { method: 'DELETE' })
-        .then(response => response.json())
-        .then(data => {
-          if (data.success) {
-            setItems(prevItems => prevItems.filter(item => item.id !== id));
-            if (selectedItem && selectedItem.id === id) {
-              setSelectedItem(null);
-              setViewMode('grid');
-            }
-          } else {
-            setError(data.error || 'Failed to delete item');
+      try {
+        const data = await api.deleteItemByHash(id);
+        if (data.success) {
+          setItems(prevItems => prevItems.filter(item => item.id !== id));
+          if (selectedItem && selectedItem.id === id) {
+            setSelectedItem(null);
+            setViewMode('grid');
           }
-        })
-        .catch(error => {
-          console.error('Error deleting catalog item:', error);
-          setError('Failed to delete item. Please try again.');
-        });
+        } else {
+          setError(data.error || 'Failed to delete item');
+        }
+      } catch (error) {
+        console.error('Error deleting catalog item:', error);
+        setError('Failed to delete item. Please try again.');
+      }
     }
   };
 
@@ -238,7 +236,7 @@ const CatalogPanel = () => {
     fetchCatalogItems();
   };
 
-  const handleSearchSubmit = (e) => {
+  const handleSearchSubmit = async (e) => {
     e.preventDefault();
     
     if (!searchTerm.trim()) {
@@ -249,27 +247,26 @@ const CatalogPanel = () => {
     setIsSearchMode(true);
     setSearchLoading(true);
     
-    fetch(`/api/card-collection?action=searchByContent&searchTerm=${encodeURIComponent(searchTerm)}&pageNumber=1&pageSize=${pagination.pageSize}`)
-      .then(response => response.json())
-      .then(data => {
-        if (data.success) {
-          const transformedItems = processApiItems(data);
-          setSearchResults({
-            items: transformedItems,
-            currentPage: data.currentPage || 1,
-            totalPages: data.totalPages || Math.ceil((data.totalResults || data.totalItems || transformedItems.length) / pagination.pageSize),
-            totalItems: data.totalResults || data.totalItems || transformedItems.length,
-            searchTerm: searchTerm
-          });
-        } else {
-          setSearchError(data.error || 'Search failed');
-        }
-      })
-      .catch(error => {
-        console.error('Error searching catalog items:', error);
-        setSearchError('Search failed. Please try again.');
-      })
-      .finally(() => setSearchLoading(false));
+    try {
+      const data = await api.searchByContent(searchTerm, 1, pagination.pageSize);
+      if (data.success) {
+        const transformedItems = processApiItems(data);
+        setSearchResults({
+          items: transformedItems,
+          currentPage: data.currentPage || 1,
+          totalPages: data.totalPages || Math.ceil((data.totalResults || data.totalItems || transformedItems.length) / pagination.pageSize),
+          totalItems: data.totalResults || data.totalItems || transformedItems.length,
+          searchTerm: searchTerm
+        });
+      } else {
+        setSearchError(data.error || 'Search failed');
+      }
+    } catch (error) {
+      console.error('Error searching catalog items:', error);
+      setSearchError('Search failed. Please try again.');
+    } finally {
+      setSearchLoading(false);
+    }
   };
 
   const clearSearch = () => {
@@ -280,171 +277,60 @@ const CatalogPanel = () => {
     setSearchTerm('');
   };
 
-  // Helper functions
-  const processApiItems = (data) => {
-    if (data.cards && Array.isArray(data.cards)) {
-      return data.cards.map(card => {
-        // Ensure contentType is properly structured
-        const contentType = card.contentType || { mimeType: 'text/plain' };
-        
-        return {
-          id: card.hash,
-          name: card.hash.substring(0, 8),
-          category: contentType.mimeType || 'Unknown',
-          description: 'Card content hash: ' + card.hash,
-          timestamp: card.timestamp || new Date().toISOString(),
-          hash: card.hash,
-          contentType: contentType, // Preserve the full contentType object
-          metaData: card.metaData || {}
+  const addFileItem = async (newItemData) => {
+    setLoading(true);
+    try {
+      const data = await api.addFileItem(newItemData);
+      if (data.success) {
+        const newCardItem = {
+          id: data.hash,
+          name: newItemData.name,
+          description: newItemData.description || 'Added file',
+          category: newItemData.contentType || 'application/octet-stream',
+          hash: data.hash,
+          timestamp: new Date().toISOString(),
+          contentType: { mimeType: newItemData.contentType || 'application/octet-stream' }
         };
-      });
-    } 
-    
-    if (data.items && Array.isArray(data.items)) {
-      return data.items.map(item => {
-        // Ensure contentType is properly structured
-        const contentType = item.contentType || { mimeType: 'text/plain' };
         
-        return {
-          id: item.id || item.hash,
-          name: item.name || (item.hash ? item.hash.substring(0, 8) : 'Unknown'),
-          category: item.category || contentType.mimeType || 'Unknown',
-          description: item.description || 'No description available',
-          timestamp: item.timestamp || new Date().toISOString(),
-          hash: item.hash || item.id,
-          contentType: contentType, // Preserve the full contentType object
-          metaData: item.metaData || {}
-        };
-      });
-    }
-    
-    console.warn('Unexpected API response format:', data);
-    return [];
-  };
-
-  const updatePagination = (data, items) => {
-    setPagination({
-      currentPage: data.currentPage || 1,
-      totalPages: data.totalPages || Math.ceil((data.totalCards || data.totalItems || items.length) / pagination.pageSize),
-      totalItems: data.totalCards || data.totalItems || items.length,
-      pageSize: pagination.pageSize
-    });
-  };
-
-  const processContentForDisplay = (content) => {
-    let description = 'Binary content';
-    
-    if (typeof content === 'string') {
-      description = content.substring(0, 200) + (content.length > 200 ? '...' : '');
-    } else if (content && typeof content === 'object') {
-      if (content.type === 'string') {
-        description = content.data.substring(0, 200) + (content.data.length > 200 ? '...' : '');
-      } else if (content.type === 'base64') {
-        description = `Binary content (${content.originalType || 'unknown type'})`;
+        setItems(prevItems => [...prevItems, newCardItem]);
+        setViewMode('grid');
+      } else {
+        setError(data.error || 'Failed to add item');
       }
+    } catch (error) {
+      console.error('Error adding catalog item:', error);
+      setError(`Failed to add item: ${error.message}`);
+    } finally {
+      setLoading(false);
     }
-    
-    return description;
-  };
-
-  const addFileItem = (newItemData) => {
-    const formData = new FormData();
-    formData.append('file', newItemData.file);
-    
-    const metadata = {
-      fileName: newItemData.name,
-      mimeType: newItemData.contentType || 'application/octet-stream',
-      size: newItemData.file.size,
-      description: newItemData.description || ''
-    };
-    
-    formData.append('metadata', JSON.stringify(metadata));
-    formData.append('action', 'add');
-    
-    setLoading(true);
-    
-    fetch('/api/card-collection?action=add', {
-      method: 'POST',
-      body: formData
-    })
-      .then(response => {
-        if (!response.ok) {
-          return response.json().then(data => {
-            throw new Error(data.error || `Server responded with ${response.status}`);
-          });
-        }
-        return response.json();
-      })
-      .then(data => {
-        if (data.success) {
-          const newCardItem = {
-            id: data.hash,
-            name: newItemData.name,
-            description: newItemData.description || 'Added file',
-            category: newItemData.contentType || 'application/octet-stream',
-            hash: data.hash,
-            timestamp: new Date().toISOString(),
-            contentType: { mimeType: newItemData.contentType || 'application/octet-stream' }
-          };
-          
-          setItems(prevItems => [...prevItems, newCardItem]);
-          setViewMode('grid');
-        } else {
-          setError(data.error || 'Failed to add item');
-        }
-      })
-      .catch(error => {
-        console.error('Error adding catalog item:', error);
-        setError(`Failed to add item: ${error.message}`);
-      })
-      .finally(() => setLoading(false));
   };
 
-  const addTextItem = (newItemData) => {
+  const addTextItem = async (newItemData) => {
     setLoading(true);
-    
-    fetch('/api/card-collection?action=add', {
-      method: 'POST',
-      headers: { 'Content-Type': 'application/json' },
-      body: JSON.stringify({
-        action: 'add',
-        card: {
-          content: newItemData.description,
-          hash_algorithm: 'sha256'
-        }
-      })
-    })
-      .then(response => {
-        if (!response.ok) {
-          return response.json().then(data => {
-            throw new Error(data.error || `Server responded with ${response.status}`);
-          });
-        }
-        return response.json();
-      })
-      .then(data => {
-        if (data.success) {
-          const newCardItem = {
-            id: data.hash,
-            name: newItemData.name,
-            description: newItemData.description.substring(0, 100) + (newItemData.description.length > 100 ? '...' : ''),
-            category: newItemData.contentType || 'text/plain',
-            hash: data.hash,
-            timestamp: new Date().toISOString(),
-            contentType: { mimeType: newItemData.contentType || 'text/plain' }
-          };
-          
-          setItems(prevItems => [...prevItems, newCardItem]);
-          setViewMode('grid');
-        } else {
-          setError(data.error || 'Failed to add item');
-        }
-      })
-      .catch(error => {
-        console.error('Error adding catalog item:', error);
-        setError(`Failed to add item: ${error.message}`);
-      })
-      .finally(() => setLoading(false));
+    try {
+      const data = await api.addTextItem(newItemData);
+      if (data.success) {
+        const newCardItem = {
+          id: data.hash,
+          name: newItemData.name,
+          description: newItemData.description.substring(0, 100) + (newItemData.description.length > 100 ? '...' : ''),
+          category: newItemData.contentType || 'text/plain',
+          hash: data.hash,
+          timestamp: new Date().toISOString(),
+          contentType: { mimeType: newItemData.contentType || 'text/plain' }
+        };
+        
+        setItems(prevItems => [...prevItems, newCardItem]);
+        setViewMode('grid');
+      } else {
+        setError(data.error || 'Failed to add item');
+      }
+    } catch (error) {
+      console.error('Error adding catalog item:', error);
+      setError(`Failed to add item: ${error.message}`);
+    } finally {
+      setLoading(false);
+    }
   };
 
   // Render main component
diff --git a/src/components/panels/catalog/api.js b/src/components/panels/catalog/api.js
new file mode 100644
index 0000000..a38d754
--- /dev/null
+++ b/src/components/panels/catalog/api.js
@@ -0,0 +1,106 @@
+/**
+ * API service functions for the Catalog Panel
+ */
+
+/**
+ * Fetch a page of catalog items
+ * @param {number} pageNumber - The page number to fetch
+ * @param {number} pageSize - The number of items per page
+ * @returns {Promise} - The API response
+ */
+export const fetchItemsPage = async (pageNumber, pageSize) => {
+  const response = await fetch(`/api/card-collection?action=getPage&pageNumber=${pageNumber}&pageSize=${pageSize}`);
+  return response.json();
+};
+
+/**
+ * Search for catalog items by content
+ * @param {string} searchTerm - The search term
+ * @param {number} pageNumber - The page number to fetch
+ * @param {number} pageSize - The number of items per page
+ * @returns {Promise} - The API response
+ */
+export const searchByContent = async (searchTerm, pageNumber, pageSize) => {
+  const response = await fetch(
+    `/api/card-collection?action=searchByContent&searchTerm=${encodeURIComponent(searchTerm)}&pageNumber=${pageNumber}&pageSize=${pageSize}`
+  );
+  return response.json();
+};
+
+/**
+ * Get a catalog item by hash
+ * @param {string} hash - The item hash
+ * @returns {Promise} - The API response
+ */
+export const getItemByHash = async (hash) => {
+  const response = await fetch(`/api/card-collection?action=get&hash=${hash}`);
+  return response.json();
+};
+
+/**
+ * Delete a catalog item by hash
+ * @param {string} hash - The item hash
+ * @returns {Promise} - The API response
+ */
+export const deleteItemByHash = async (hash) => {
+  const response = await fetch(`/api/card-collection?action=delete&hash=${hash}`, { method: 'DELETE' });
+  return response.json();
+};
+
+/**
+ * Add a file item to the catalog
+ * @param {Object} itemData - The item data to add
+ * @returns {Promise} - The API response
+ */
+export const addFileItem = async (itemData) => {
+  const formData = new FormData();
+  formData.append('file', itemData.file);
+  
+  const metadata = {
+    fileName: itemData.name,
+    mimeType: itemData.contentType || 'application/octet-stream',
+    size: itemData.file.size,
+    description: itemData.description || ''
+  };
+  
+  formData.append('metadata', JSON.stringify(metadata));
+  formData.append('action', 'add');
+  
+  const response = await fetch('/api/card-collection?action=add', {
+    method: 'POST',
+    body: formData
+  });
+  
+  if (!response.ok) {
+    const errorData = await response.json();
+    throw new Error(errorData.error || `Server responded with ${response.status}`);
+  }
+  
+  return response.json();
+};
+
+/**
+ * Add a text item to the catalog
+ * @param {Object} itemData - The item data to add
+ * @returns {Promise} - The API response
+ */
+export const addTextItem = async (itemData) => {
+  const response = await fetch('/api/card-collection?action=add', {
+    method: 'POST',
+    headers: { 'Content-Type': 'application/json' },
+    body: JSON.stringify({
+      action: 'add',
+      card: {
+        content: itemData.description,
+        hash_algorithm: 'sha256'
+      }
+    })
+  });
+  
+  if (!response.ok) {
+    const errorData = await response.json();
+    throw new Error(errorData.error || `Server responded with ${response.status}`);
+  }
+  
+  return response.json();
+};
diff --git a/src/components/panels/catalog/dataHelpers.js b/src/components/panels/catalog/dataHelpers.js
new file mode 100644
index 0000000..034f4e1
--- /dev/null
+++ b/src/components/panels/catalog/dataHelpers.js
@@ -0,0 +1,114 @@
+/**
+ * Helper functions for processing catalog data
+ */
+
+/**
+ * Process API items from various response formats
+ * @param {Object} data - API response data
+ * @returns {Array} - Processed items array
+ */
+export const processApiItems = (data) => {
+  if (data.cards && Array.isArray(data.cards)) {
+    return data.cards.map(card => {
+      // Ensure contentType is properly structured
+      const contentType = card.contentType || { mimeType: 'text/plain' };
+      
+      return {
+        id: card.hash,
+        name: card.hash.substring(0, 8),
+        category: contentType.mimeType || 'Unknown',
+        description: 'Card content hash: ' + card.hash,
+        timestamp: card.timestamp || new Date().toISOString(),
+        hash: card.hash,
+        contentType: contentType, // Preserve the full contentType object
+        metaData: card.metaData || {}
+      };
+    });
+  } 
+  
+  if (data.items && Array.isArray(data.items)) {
+    return data.items.map(item => {
+      // Ensure contentType is properly structured
+      const contentType = item.contentType || { mimeType: 'text/plain' };
+      
+      return {
+        id: item.id || item.hash,
+        name: item.name || (item.hash ? item.hash.substring(0, 8) : 'Unknown'),
+        category: item.category || contentType.mimeType || 'Unknown',
+        description: item.description || 'No description available',
+        timestamp: item.timestamp || new Date().toISOString(),
+        hash: item.hash || item.id,
+        contentType: contentType, // Preserve the full contentType object
+        metaData: item.metaData || {}
+      };
+    });
+  }
+  
+  console.warn('Unexpected API response format:', data);
+  return [];
+};
+
+/**
+ * Update pagination information based on API response
+ * @param {Object} data - API response data
+ * @param {Array} items - Processed items array
+ * @param {number} pageSize - Current page size
+ * @returns {Object} - Updated pagination information
+ */
+export const updatePagination = (data, items, pageSize) => {
+  return {
+    currentPage: data.currentPage || 1,
+    totalPages: data.totalPages || Math.ceil((data.totalCards || data.totalItems || items.length) / pageSize),
+    totalItems: data.totalCards || data.totalItems || items.length,
+    pageSize: pageSize
+  };
+};
+
+/**
+ * Process content for display in UI
+ * @param {any} content - Card content to process
+ * @returns {string} - Processed display text
+ */
+export const processContentForDisplay = (content) => {
+  let description = 'Binary content';
+  
+  if (typeof content === 'string') {
+    description = content.substring(0, 200) + (content.length > 200 ? '...' : '');
+  } else if (content && typeof content === 'object') {
+    if (content.type === 'string') {
+      description = content.data.substring(0, 200) + (content.data.length > 200 ? '...' : '');
+    } else if (content.type === 'base64') {
+      description = `Binary content (${content.originalType || 'unknown type'})`;
+    } else if (content.type === 'Buffer' && Array.isArray(content.data)) {
+      description = `Binary data (${content.data.length} bytes)`;
+    }
+  }
+  
+  return description;
+};
+
+/**
+ * Get a simple content type from mime type
+ * @param {string} mimeType - The mime type
+ * @returns {string} - Simple content type
+ */
+export const getSimpleContentType = (mimeType) => {
+  if (!mimeType) return 'txt';
+  
+  const mimeMap = {
+    'image/jpeg': 'jpg',
+    'image/png': 'png',
+    'image/gif': 'gif',
+    'text/plain': 'txt',
+    'text/csv': 'csv',
+    'application/json': 'json',
+    'application/pdf': 'pdf',
+    'application/xml': 'xml',
+    'video/mp4': 'mp4',
+    'video/quicktime': 'mov',
+    'audio/wav': 'wav',
+    'audio/mpeg': 'mp3'
+  };
+  
+  return mimeMap[mimeType] || mimeType.split('/').pop() || 'txt';
+};
diff --git a/src/components/panels/catalog/useCatalogData.js b/src/components/panels/catalog/useCatalogData.js
new file mode 100644
index 0000000..a2ff997
--- /dev/null
+++ b/src/components/panels/catalog/useCatalogData.js
@@ -0,0 +1,363 @@
+import { useState, useEffect } from 'react';
+import { useDispatch } from 'react-redux';
+import { importCardFromDatabase, selectContent } from '../../../features/contentSlice';
+import { selectItem } from '../../../features/selectedItemSlice';
+import * as api from './api';
+import { processApiItems, updatePagination, processContentForDisplay, getSimpleContentType } from './dataHelpers';
+
+/**
+ * Custom hook for catalog data management
+ * @returns {Object} - Catalog data and functions
+ */
+const useCatalogData = () => {
+  const dispatch = useDispatch();
+  
+  // Main state
+  const [items, setItems] = useState([]);
+  const [viewMode, setViewMode] = useState('grid');
+  const [selectedItem, setSelectedItem] = useState(null);
+  
+  // Loading and error states
+  const [loading, setLoading] = useState(false);
+  const [itemLoading, setItemLoading] = useState(false);
+  const [searchLoading, setSearchLoading] = useState(false);
+  const [error, setError] = useState(null);
+  const [itemError, setItemError] = useState(null);
+  const [searchError, setSearchError] = useState(null);
+  
+  // Search and filter state
+  const [searchTerm, setSearchTerm] = useState('');
+  const [isSearchMode, setIsSearchMode] = useState(false);
+  const [categories, setCategories] = useState(['all']);
+  const [filter, setFilter] = useState('all');
+  const [sortBy, setSortBy] = useState('name');
+  
+  // Pagination state
+  const [pagination, setPagination] = useState({
+    currentPage: 1, totalPages: 1, totalItems: 0, pageSize: 20
+  });
+  const [searchResults, setSearchResults] = useState({
+    items: [], currentPage: 1, totalPages: 1, totalItems: 0, searchTerm: ''
+  });
+
+  // Initialize
+  useEffect(() => {
+    fetchCatalogItems();
+  }, []);
+
+  // Update categories whenever items change
+  useEffect(() => {
+    if (items.length > 0) {
+      const catSet = new Set(items.map(item => item.category));
+      setCategories(['all', ...Array.from(catSet)].filter(Boolean));
+    }
+  }, [items]);
+
+  // Computed values
+  const displayItems = isSearchMode ? searchResults.items : items;
+  const paginationInfo = isSearchMode 
+    ? { currentPage: searchResults.currentPage, totalPages: searchResults.totalPages, 
+        totalItems: searchResults.totalItems, pageSize: 20 } 
+    : pagination;
+  const filteredItems = displayItems.filter(item => 
+    isSearchMode || filter === 'all' || item.category === filter
+  );
+  const sortedItems = [...filteredItems].sort((a, b) => 
+    sortBy === 'name' 
+      ? a.name.localeCompare(b.name) 
+      : new Date(b.timestamp) - new Date(a.timestamp)
+  );
+
+  // API Handlers
+  const fetchCatalogItems = async () => {
+    setLoading(true);
+    try {
+      const data = await api.fetchItemsPage(1, pagination.pageSize);
+      if (data.success) {
+        const transformedItems = processApiItems(data);
+        setItems(transformedItems);
+        setPagination(updatePagination(data, transformedItems, pagination.pageSize));
+      } else {
+        setError(data.error || 'Failed to fetch items');
+      }
+    } catch (error) {
+      console.error('Error fetching catalog items:', error);
+      setError('Failed to fetch catalog items. Please try again.');
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  const handlePageChange = (newPage) => {
+    if (isSearchMode) {
+      fetchSearchPage(newPage);
+    } else {
+      fetchItemsPage(newPage);
+    }
+  };
+
+  const fetchItemsPage = async (newPage) => {
+    setLoading(true);
+    try {
+      const data = await api.fetchItemsPage(newPage, pagination.pageSize);
+      if (data.success) {
+        const transformedItems = processApiItems(data);
+        setItems(transformedItems);
+        setPagination(updatePagination(data, transformedItems, pagination.pageSize));
+      } else {
+        setError(data.error || 'Failed to fetch items');
+      }
+    } catch (error) {
+      console.error('Error fetching catalog items:', error);
+      setError('Failed to fetch catalog items. Please try again.');
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  const fetchSearchPage = async (newPage) => {
+    setSearchLoading(true);
+    try {
+      const data = await api.searchByContent(searchResults.searchTerm, newPage, pagination.pageSize);
+      if (data.success) {
+        const transformedItems = processApiItems(data);
+        setSearchResults({
+          items: transformedItems,
+          currentPage: data.currentPage || newPage,
+          totalPages: data.totalPages || Math.ceil((data.totalResults || data.totalItems || transformedItems.length) / pagination.pageSize),
+          totalItems: data.totalResults || data.totalItems || transformedItems.length,
+          searchTerm: searchResults.searchTerm
+        });
+      } else {
+        setSearchError(data.error || 'Search failed');
+      }
+    } catch (error) {
+      console.error('Error searching catalog items:', error);
+      setSearchError('Search failed. Please try again.');
+    } finally {
+      setSearchLoading(false);
+    }
+  };
+
+  // Item Actions
+  const handleSelectItem = async (item) => {
+    setItemLoading(true);
+    setViewMode('detail');
+    
+    try {
+      const data = await api.getItemByHash(item.id);
+      if (data.success) {
+        const cardData = data.card;
+        const serverContentType = cardData.contentType;
+        const simpleType = serverContentType?.extension || 
+                     (serverContentType?.mimeType ? getSimpleContentType(serverContentType.mimeType) : null) || 
+                     "txt";
+        
+        // Process content for display
+        let description = processContentForDisplay(cardData.content);
+        
+        setSelectedItem({
+          id: cardData.hash,
+          name: cardData.hash.substring(0, 8),
+          category: cardData.contentType?.mimeType || 'Unknown',
+          description: description,
+          hash: cardData.hash,
+          content: cardData.content,
+          timestamp: cardData.timestamp || new Date().toISOString(),
+          contentType: cardData.contentType
+        });
+        
+        // Update Redux store
+        dispatch(importCardFromDatabase({ 
+          hash: cardData.hash,
+          content: cardData.content,
+          metadata: { contentType: serverContentType },
+          relationships: { parentHash: null, childHashes: [], relatedHashes: [] }
+        }));
+        
+        dispatch(selectContent(cardData.hash));
+        dispatch(selectItem({
+          item: cardData.content,
+          hash: cardData.hash,
+          contentType: simpleType,
+          gtime: cardData.timestamp
+        }));
+      } else {
+        setItemError(data.error || 'Failed to fetch card');
+      }
+    } catch (error) {
+      console.error('Error fetching card by ID:', error);
+      setItemError('Failed to fetch card. Please try again.');
+    } finally {
+      setItemLoading(false);
+    }
+  };
+
+  const handleDeleteItem = async (id) => {
+    if (window.confirm('Are you sure you want to delete this item?')) {
+      try {
+        const data = await api.deleteItemByHash(id);
+        if (data.success) {
+          setItems(prevItems => prevItems.filter(item => item.id !== id));
+          if (selectedItem && selectedItem.id === id) {
+            setSelectedItem(null);
+            setViewMode('grid');
+          }
+        } else {
+          setError(data.error || 'Failed to delete item');
+        }
+      } catch (error) {
+        console.error('Error deleting catalog item:', error);
+        setError('Failed to delete item. Please try again.');
+      }
+    }
+  };
+
+  const handleAddItem = (newItemData) => {
+    if (newItemData.file) {
+      addFileItem(newItemData);
+    } else if (newItemData.description) {
+      addTextItem(newItemData);
+    }
+  };
+
+  const addFileItem = async (newItemData) => {
+    setLoading(true);
+    try {
+      const data = await api.addFileItem(newItemData);
+      if (data.success) {
+        const newCardItem = {
+          id: data.hash,
+          name: newItemData.name,
+          description: newItemData.description || 'Added file',
+          category: newItemData.contentType || 'application/octet-stream',
+          hash: data.hash,
+          timestamp: new Date().toISOString(),
+          contentType: { mimeType: newItemData.contentType || 'application/octet-stream' }
+        };
+        
+        setItems(prevItems => [...prevItems, newCardItem]);
+        setViewMode('grid');
+      } else {
+        setError(data.error || 'Failed to add item');
+      }
+    } catch (error) {
+      console.error('Error adding catalog item:', error);
+      setError(`Failed to add item: ${error.message}`);
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  const addTextItem = async (newItemData) => {
+    setLoading(true);
+    try {
+      const data = await api.addTextItem(newItemData);
+      if (data.success) {
+        const newCardItem = {
+          id: data.hash,
+          name: newItemData.name,
+          description: newItemData.description.substring(0, 100) + (newItemData.description.length > 100 ? '...' : ''),
+          category: newItemData.contentType || 'text/plain',
+          hash: data.hash,
+          timestamp: new Date().toISOString(),
+          contentType: { mimeType: newItemData.contentType || 'text/plain' }
+        };
+        
+        setItems(prevItems => [...prevItems, newCardItem]);
+        setViewMode('grid');
+      } else {
+        setError(data.error || 'Failed to add item');
+      }
+    } catch (error) {
+      console.error('Error adding catalog item:', error);
+      setError(`Failed to add item: ${error.message}`);
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  // UI Handlers
+  const handleRefresh = () => {
+    if (isSearchMode) clearSearch();
+    fetchCatalogItems();
+  };
+
+  const handleSearchSubmit = async (e) => {
+    e.preventDefault();
+    
+    if (!searchTerm.trim()) {
+      clearSearch();
+      return;
+    }
+    
+    setIsSearchMode(true);
+    setSearchLoading(true);
+    
+    try {
+      const data = await api.searchByContent(searchTerm, 1, pagination.pageSize);
+      if (data.success) {
+        const transformedItems = processApiItems(data);
+        setSearchResults({
+          items: transformedItems,
+          currentPage: data.currentPage || 1,
+          totalPages: data.totalPages || Math.ceil((data.totalResults || data.totalItems || transformedItems.length) / pagination.pageSize),
+          totalItems: data.totalResults || data.totalItems || transformedItems.length,
+          searchTerm: searchTerm
+        });
+      } else {
+        setSearchError(data.error || 'Search failed');
+      }
+    } catch (error) {
+      console.error('Error searching catalog items:', error);
+      setSearchError('Search failed. Please try again.');
+    } finally {
+      setSearchLoading(false);
+    }
+  };
+
+  const clearSearch = () => {
+    setIsSearchMode(false);
+    setSearchResults({
+      items: [], currentPage: 1, totalPages: 1, totalItems: 0, searchTerm: ''
+    });
+    setSearchTerm('');
+  };
+
+  return {
+    // State
+    items,
+    viewMode,
+    setViewMode,
+    selectedItem,
+    loading,
+    itemLoading,
+    searchLoading,
+    error,
+    itemError,
+    searchError,
+    searchTerm,
+    setSearchTerm,
+    isSearchMode,
+    categories,
+    filter,
+    setFilter,
+    sortBy,
+    setSortBy,
+    pagination,
+    searchResults,
+    sortedItems,
+    paginationInfo,
+    
+    // Functions
+    handleSelectItem,
+    handleDeleteItem,
+    handleAddItem,
+    handleRefresh,
+    handleSearchSubmit,
+    clearSearch,
+    handlePageChange
+  };
+};
+
+export default useCatalogData;
diff --git a/src/features/useCatalogData.js b/src/features/useCatalogData.js
new file mode 100644
index 0000000..7267026
--- /dev/null
+++ b/src/features/useCatalogData.js
@@ -0,0 +1,364 @@
+import { useState, useEffect } from 'react';
+import { useDispatch } from 'react-redux';
+import { importCardFromDatabase, selectContent } from './contentSlice';
+import { selectItem } from './selectedItemSlice';
+import * as api from '../components/panels/catalog/api';
+import { processApiItems, updatePagination, processContentForDisplay } from '../components/panels/catalog/dataHelpers';
+import { getSimpleContentType } from '../components/panels/catalog/utils';
+
+/**
+ * Custom hook for catalog data management
+ * @returns {Object} - Catalog data and functions
+ */
+const useCatalogData = () => {
+  const dispatch = useDispatch();
+  
+  // Main state
+  const [items, setItems] = useState([]);
+  const [viewMode, setViewMode] = useState('grid');
+  const [selectedItem, setSelectedItem] = useState(null);
+  
+  // Loading and error states
+  const [loading, setLoading] = useState(false);
+  const [itemLoading, setItemLoading] = useState(false);
+  const [searchLoading, setSearchLoading] = useState(false);
+  const [error, setError] = useState(null);
+  const [itemError, setItemError] = useState(null);
+  const [searchError, setSearchError] = useState(null);
+  
+  // Search and filter state
+  const [searchTerm, setSearchTerm] = useState('');
+  const [isSearchMode, setIsSearchMode] = useState(false);
+  const [categories, setCategories] = useState(['all']);
+  const [filter, setFilter] = useState('all');
+  const [sortBy, setSortBy] = useState('name');
+  
+  // Pagination state
+  const [pagination, setPagination] = useState({
+    currentPage: 1, totalPages: 1, totalItems: 0, pageSize: 20
+  });
+  const [searchResults, setSearchResults] = useState({
+    items: [], currentPage: 1, totalPages: 1, totalItems: 0, searchTerm: ''
+  });
+
+  // Initialize
+  useEffect(() => {
+    fetchCatalogItems();
+  }, []);
+
+  // Update categories whenever items change
+  useEffect(() => {
+    if (items.length > 0) {
+      const catSet = new Set(items.map(item => item.category));
+      setCategories(['all', ...Array.from(catSet)].filter(Boolean));
+    }
+  }, [items]);
+
+  // Computed values
+  const displayItems = isSearchMode ? searchResults.items : items;
+  const paginationInfo = isSearchMode 
+    ? { currentPage: searchResults.currentPage, totalPages: searchResults.totalPages, 
+        totalItems: searchResults.totalItems, pageSize: 20 } 
+    : pagination;
+  const filteredItems = displayItems.filter(item => 
+    isSearchMode || filter === 'all' || item.category === filter
+  );
+  const sortedItems = [...filteredItems].sort((a, b) => 
+    sortBy === 'name' 
+      ? a.name.localeCompare(b.name) 
+      : new Date(b.timestamp) - new Date(a.timestamp)
+  );
+
+  // API Handlers
+  const fetchCatalogItems = async () => {
+    setLoading(true);
+    try {
+      const data = await api.fetchItemsPage(1, pagination.pageSize);
+      if (data.success) {
+        const transformedItems = processApiItems(data);
+        setItems(transformedItems);
+        setPagination(updatePagination(data, transformedItems, pagination.pageSize));
+      } else {
+        setError(data.error || 'Failed to fetch items');
+      }
+    } catch (error) {
+      console.error('Error fetching catalog items:', error);
+      setError('Failed to fetch catalog items. Please try again.');
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  const handlePageChange = (newPage) => {
+    if (isSearchMode) {
+      fetchSearchPage(newPage);
+    } else {
+      fetchItemsPage(newPage);
+    }
+  };
+
+  const fetchItemsPage = async (newPage) => {
+    setLoading(true);
+    try {
+      const data = await api.fetchItemsPage(newPage, pagination.pageSize);
+      if (data.success) {
+        const transformedItems = processApiItems(data);
+        setItems(transformedItems);
+        setPagination(updatePagination(data, transformedItems, pagination.pageSize));
+      } else {
+        setError(data.error || 'Failed to fetch items');
+      }
+    } catch (error) {
+      console.error('Error fetching catalog items:', error);
+      setError('Failed to fetch catalog items. Please try again.');
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  const fetchSearchPage = async (newPage) => {
+    setSearchLoading(true);
+    try {
+      const data = await api.searchByContent(searchResults.searchTerm, newPage, pagination.pageSize);
+      if (data.success) {
+        const transformedItems = processApiItems(data);
+        setSearchResults({
+          items: transformedItems,
+          currentPage: data.currentPage || newPage,
+          totalPages: data.totalPages || Math.ceil((data.totalResults || data.totalItems || transformedItems.length) / pagination.pageSize),
+          totalItems: data.totalResults || data.totalItems || transformedItems.length,
+          searchTerm: searchResults.searchTerm
+        });
+      } else {
+        setSearchError(data.error || 'Search failed');
+      }
+    } catch (error) {
+      console.error('Error searching catalog items:', error);
+      setSearchError('Search failed. Please try again.');
+    } finally {
+      setSearchLoading(false);
+    }
+  };
+
+  // Item Actions
+  const handleSelectItem = async (item) => {
+    setItemLoading(true);
+    setViewMode('detail');
+    
+    try {
+      const data = await api.getItemByHash(item.id);
+      if (data.success) {
+        const cardData = data.card;
+        const serverContentType = cardData.contentType;
+        const simpleType = serverContentType?.extension || 
+                     (serverContentType?.mimeType ? getSimpleContentType(serverContentType.mimeType) : null) || 
+                     "txt";
+        
+        // Process content for display
+        let description = processContentForDisplay(cardData.content);
+        
+        setSelectedItem({
+          id: cardData.hash,
+          name: cardData.hash.substring(0, 8),
+          category: cardData.contentType?.mimeType || 'Unknown',
+          description: description,
+          hash: cardData.hash,
+          content: cardData.content,
+          timestamp: cardData.timestamp || new Date().toISOString(),
+          contentType: cardData.contentType
+        });
+        
+        // Update Redux store
+        dispatch(importCardFromDatabase({ 
+          hash: cardData.hash,
+          content: cardData.content,
+          metadata: { contentType: serverContentType },
+          relationships: { parentHash: null, childHashes: [], relatedHashes: [] }
+        }));
+        
+        dispatch(selectContent(cardData.hash));
+        dispatch(selectItem({
+          item: cardData.content,
+          hash: cardData.hash,
+          contentType: simpleType,
+          gtime: cardData.timestamp
+        }));
+      } else {
+        setItemError(data.error || 'Failed to fetch card');
+      }
+    } catch (error) {
+      console.error('Error fetching card by ID:', error);
+      setItemError('Failed to fetch card. Please try again.');
+    } finally {
+      setItemLoading(false);
+    }
+  };
+
+  const handleDeleteItem = async (id) => {
+    if (window.confirm('Are you sure you want to delete this item?')) {
+      try {
+        const data = await api.deleteItemByHash(id);
+        if (data.success) {
+          setItems(prevItems => prevItems.filter(item => item.id !== id));
+          if (selectedItem && selectedItem.id === id) {
+            setSelectedItem(null);
+            setViewMode('grid');
+          }
+        } else {
+          setError(data.error || 'Failed to delete item');
+        }
+      } catch (error) {
+        console.error('Error deleting catalog item:', error);
+        setError('Failed to delete item. Please try again.');
+      }
+    }
+  };
+
+  const handleAddItem = (newItemData) => {
+    if (newItemData.file) {
+      addFileItem(newItemData);
+    } else if (newItemData.description) {
+      addTextItem(newItemData);
+    }
+  };
+
+  const addFileItem = async (newItemData) => {
+    setLoading(true);
+    try {
+      const data = await api.addFileItem(newItemData);
+      if (data.success) {
+        const newCardItem = {
+          id: data.hash,
+          name: newItemData.name,
+          description: newItemData.description || 'Added file',
+          category: newItemData.contentType || 'application/octet-stream',
+          hash: data.hash,
+          timestamp: new Date().toISOString(),
+          contentType: { mimeType: newItemData.contentType || 'application/octet-stream' }
+        };
+        
+        setItems(prevItems => [...prevItems, newCardItem]);
+        setViewMode('grid');
+      } else {
+        setError(data.error || 'Failed to add item');
+      }
+    } catch (error) {
+      console.error('Error adding catalog item:', error);
+      setError(`Failed to add item: ${error.message}`);
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  const addTextItem = async (newItemData) => {
+    setLoading(true);
+    try {
+      const data = await api.addTextItem(newItemData);
+      if (data.success) {
+        const newCardItem = {
+          id: data.hash,
+          name: newItemData.name,
+          description: newItemData.description.substring(0, 100) + (newItemData.description.length > 100 ? '...' : ''),
+          category: newItemData.contentType || 'text/plain',
+          hash: data.hash,
+          timestamp: new Date().toISOString(),
+          contentType: { mimeType: newItemData.contentType || 'text/plain' }
+        };
+        
+        setItems(prevItems => [...prevItems, newCardItem]);
+        setViewMode('grid');
+      } else {
+        setError(data.error || 'Failed to add item');
+      }
+    } catch (error) {
+      console.error('Error adding catalog item:', error);
+      setError(`Failed to add item: ${error.message}`);
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  // UI Handlers
+  const handleRefresh = () => {
+    if (isSearchMode) clearSearch();
+    fetchCatalogItems();
+  };
+
+  const handleSearchSubmit = async (e) => {
+    e.preventDefault();
+    
+    if (!searchTerm.trim()) {
+      clearSearch();
+      return;
+    }
+    
+    setIsSearchMode(true);
+    setSearchLoading(true);
+    
+    try {
+      const data = await api.searchByContent(searchTerm, 1, pagination.pageSize);
+      if (data.success) {
+        const transformedItems = processApiItems(data);
+        setSearchResults({
+          items: transformedItems,
+          currentPage: data.currentPage || 1,
+          totalPages: data.totalPages || Math.ceil((data.totalResults || data.totalItems || transformedItems.length) / pagination.pageSize),
+          totalItems: data.totalResults || data.totalItems || transformedItems.length,
+          searchTerm: searchTerm
+        });
+      } else {
+        setSearchError(data.error || 'Search failed');
+      }
+    } catch (error) {
+      console.error('Error searching catalog items:', error);
+      setSearchError('Search failed. Please try again.');
+    } finally {
+      setSearchLoading(false);
+    }
+  };
+
+  const clearSearch = () => {
+    setIsSearchMode(false);
+    setSearchResults({
+      items: [], currentPage: 1, totalPages: 1, totalItems: 0, searchTerm: ''
+    });
+    setSearchTerm('');
+  };
+
+  return {
+    // State
+    items,
+    viewMode,
+    setViewMode,
+    selectedItem,
+    loading,
+    itemLoading,
+    searchLoading,
+    error,
+    itemError,
+    searchError,
+    searchTerm,
+    setSearchTerm,
+    isSearchMode,
+    categories,
+    filter,
+    setFilter,
+    sortBy,
+    setSortBy,
+    pagination,
+    searchResults,
+    sortedItems,
+    paginationInfo,
+    
+    // Functions
+    handleSelectItem,
+    handleDeleteItem,
+    handleAddItem,
+    handleRefresh,
+    handleSearchSubmit,
+    clearSearch,
+    handlePageChange
+  };
+};
+
+export default useCatalogData;
```
