import { Buffer } from 'buffer';
import GTime from './g_time.js';
import { HashAlgorithm } from '../../config/config_constants.js';
import HashValidator from './hash/validator.js';
import ContentTypeInterpreter from './content_type_detector.js';

class MCard {
  constructor(content, hashFunction = HashAlgorithm.DEFAULT, options = {}) {
    // Validate input
    if (content === null) {
      throw new Error('Content cannot be None');
    }

    if (hashFunction === null) {
      throw new Error('hash_function cannot be None');
    }

    // Store content directly without any conversions
    this.content = content;

    // Validate content is not empty
    if (content === undefined || 
        (typeof content === 'string' && content.length === 0) || 
        (Buffer.isBuffer(content) && content.length === 0) ||
        (typeof content === 'object' && Object.keys(content).length === 0)) {
      throw new Error('Content cannot be empty');
    }

    // Compute hash - convert to buffer for hashing if needed
    const forcedHashAlgorithm = options.forceHashAlgorithm || hashFunction;
    
    // Convert to buffer only for hash computation
    let contentForHash;
    if (Buffer.isBuffer(content)) {
      contentForHash = content;
    } else if (typeof content === 'string') {
      contentForHash = Buffer.from(content, 'utf-8');
    } else {
      // For hashing, we need to stringify objects
      contentForHash = Buffer.from(JSON.stringify(content), 'utf-8');
    }
      
    this.hash = HashValidator.computeHash(contentForHash, HashAlgorithm(forcedHashAlgorithm));
    this.hash_algorithm = HashAlgorithm(forcedHashAlgorithm);

    // Generate timestamp
    this.g_time = GTime.stamp_now(this.hash_algorithm);
  }

  // Getter methods
  get_content() {
    return this.content;
  }

  get_hash() {
    return this.hash;
  }

  get_g_time() {
    return this.g_time;
  }

  // Utility methods
  equals(other) {
    return this.hash === other.hash;
  }

  to_dict() {
    return {
      content: this.content,
      hash: this.hash,
      g_time: this.g_time
    };
  }
}

class MCardFromData extends MCard {
  constructor(content, hash_value, g_time_str) {
    // Validate input parameters
    if (!content) {
      throw new Error("Content cannot be null or empty");
    }

    if (!hash_value) {
      throw new Error("Hash value cannot be None or empty");
    }

    if (!g_time_str) {
      throw new Error("g_time string cannot be None or empty");
    }

    // Call parent constructor with content and hash function
    super(content, GTime.get_hash_function(g_time_str));

    // Override the hash generated by parent constructor
    this.hash = hash_value;
    this.g_time = g_time_str; // Directly assign the provided g_time string
    this.hash_function = GTime.get_hash_function(this.g_time);

    // Detect content type (for metadata only, don't modify the content)
    const interpreter = new ContentTypeInterpreter();
    let contentForType = content;
    
    // For type detection, convert to Buffer if needed
    if (!(content instanceof Buffer) && typeof content !== 'string') {
      contentForType = Buffer.from(JSON.stringify(content), 'utf-8');
    } else if (typeof content === 'string') {
      contentForType = Buffer.from(content, 'utf-8');
    }
    
    this._content_type = interpreter.detectContentType(contentForType);
  }

  // Getter method for content type
  get_content_type() {
    return this._content_type;
  }

  // Async method for content type (for compatibility)
  async getContentType() {
    return this._content_type;
  }

  // Update to_dict to include content type
  to_dict() {
    return {
      content: this.content,
      hash: this.hash,
      g_time: this.g_time,
      content_type: this._content_type
    };
  }
}

export { MCard, MCardFromData };