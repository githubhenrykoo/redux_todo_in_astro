import { Buffer } from 'buffer';
import GTime from './g_time.js';
import { HashAlgorithm } from '../../config/config_constants.js';
import HashValidator from './hash/validator.js';
import ContentTypeInterpreter from './content_type_detector.js';

class MCard {
  constructor(content, hashFunction = HashAlgorithm.DEFAULT, options = {}) {
    // Validate input
    if (content === null) {
      throw new Error('Content cannot be None');
    }

    if (hashFunction === null) {
      throw new Error('hash_function cannot be None');
    }

    // Direct buffer assignment to prevent recursion
    if (content instanceof Buffer) {
      this.content = content;
    } else {
      // Use a primitive conversion method
      const contentValue = content === undefined 
        ? '' 
        : (typeof content === 'object' 
            ? JSON.stringify(content) 
            : content.toString());
      
      // Create buffer using a primitive method
      this.content = Buffer.allocUnsafe(Buffer.byteLength(contentValue)).fill(0);
      this.content.write(contentValue, 0, 'utf-8');
    }

    // Validate content is not empty
    if (this.content.length === 0) {
      throw new Error('Content cannot be empty');
    }

    // Compute hash with optional forced hash algorithm
    const forcedHashAlgorithm = options.forceHashAlgorithm || hashFunction;
    
    this.hash = HashValidator.computeHash(this.content, HashAlgorithm(forcedHashAlgorithm));
    this.hash_algorithm = HashAlgorithm(forcedHashAlgorithm);

    // Generate timestamp
    this.g_time = GTime.stamp_now(this.hash_algorithm);
  }

  // Getter methods
  get_content() {
    return this.content;
  }

  get_hash() {
    return this.hash;
  }

  get_g_time() {
    return this.g_time;
  }

  // Utility methods
  equals(other) {
    return this.hash === other.hash;
  }

  to_dict() {
    return {
      content: this.content.toString('base64'),
      hash: this.hash,
      g_time: this.g_time
    };
  }
}

class MCardFromData extends MCard {
  constructor(content, hash_value, g_time_str) {
    // Validate input parameters
    if (!(content instanceof Buffer)) {
      throw new TypeError("Content must be a Buffer when initializing from existing data.");
    }

    if (!hash_value) {
      throw new Error("Hash value cannot be None or empty");
    }

    if (!g_time_str) {
      throw new Error("g_time string cannot be None or empty");
    }

    // Call parent constructor with content and hash function
    super(content, GTime.get_hash_function(g_time_str));

    // Override the hash generated by parent constructor
    this.hash = hash_value;
    this.g_time = g_time_str; // Directly assign the provided g_time string
    this.hash_function = GTime.get_hash_function(this.g_time);

    // Detect content type
    const interpreter = new ContentTypeInterpreter();
    this._content_type = interpreter.detectContentType(this.content);
  }

  // Getter method for content type
  get_content_type() {
    return this._content_type;
  }

  // Async method for content type (for compatibility)
  async getContentType() {
    return this._content_type;
  }

  // Update to_dict to include content type
  to_dict() {
    return {
      content: this.content.toString('base64'),
      hash: this.hash,
      g_time: this.g_time,
      content_type: this._content_type
    };
  }
}

export { MCard, MCardFromData };